{"ast":null,"code":"\"use strict\";\n/**\n * @packageDocumentation\n * @module harmony-network\n * @hidden\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BaseBlockTracker = void 0;\n\nvar tslib_1 = require(\"tslib\");\n\nvar utils_1 = require(\"@harmony-js/utils\");\n\nvar emitter_1 = require(\"../providers/emitter\");\n\nvar sec = 1000;\n\nvar calculateSum = function (accumulator, currentValue) {\n  return accumulator + currentValue;\n};\n\nvar blockTrackerEvents = ['sync', 'latest'];\n\nvar BaseBlockTracker = function (_super) {\n  tslib_1.__extends(BaseBlockTracker, _super);\n\n  function BaseBlockTracker(opts) {\n    if (opts === void 0) {\n      opts = {\n        blockResetDuration: undefined,\n        retryTimeout: undefined,\n        keepEventLoopActive: undefined,\n        setSkipCacheFlag: false\n      };\n    }\n\n    var _this = _super.call(this) || this; // config\n\n\n    _this._blockResetDuration = opts.blockResetDuration || 20 * sec; // state\n    // tslint:disable-next-line: no-unused-expression\n\n    _this._blockResetTimeout;\n    _this._currentBlock = null;\n    _this._isRunning = false; // bind functions for internal use\n    // this._onNewListener = this._onNewListener.bind(this);\n    // this._onRemoveListener = this._onRemoveListener.bind(this);\n    // this._resetCurrentBlock = this._resetCurrentBlock.bind(this);\n    // listen for handler changes\n    // this._setupInternalEvents();\n\n    _this._maybeStart();\n\n    return _this;\n  }\n\n  BaseBlockTracker.prototype.isRunning = function () {\n    return this._isRunning;\n  };\n\n  BaseBlockTracker.prototype.getCurrentBlock = function () {\n    return this._currentBlock;\n  };\n\n  BaseBlockTracker.prototype.getLatestBlock = function () {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var latestBlock;\n\n      var _this = this;\n\n      return tslib_1.__generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            // return if available\n            if (this._currentBlock) {\n              return [2\n              /*return*/\n              , this._currentBlock];\n            }\n\n            return [4\n            /*yield*/\n            , new Promise(function (resolve) {\n              return _this.once('latest', resolve);\n            })];\n\n          case 1:\n            latestBlock = _a.sent(); // return newly set current block\n\n            return [2\n            /*return*/\n            , latestBlock];\n        }\n      });\n    });\n  }; // dont allow module consumer to remove our internal event listeners\n\n\n  BaseBlockTracker.prototype.removeAllListeners = function (eventName) {\n    // perform default behavior, preserve fn arity\n    if (eventName) {\n      _super.prototype.removeEventListener.call(this, eventName);\n    } else {\n      _super.prototype.removeEventListener.call(this, '*');\n    } // re-add internal events\n\n\n    this._setupInternalEvents(); // trigger stop check just in case\n\n\n    this._onRemoveListener('*');\n  }; //\n  // to be implemented in subclass\n  //\n\n\n  BaseBlockTracker.prototype._start = function () {// default behavior is noop\n  };\n\n  BaseBlockTracker.prototype._end = function () {// default behavior is noop\n  }; //\n  // private\n  //\n\n\n  BaseBlockTracker.prototype._setupInternalEvents = function () {\n    // first remove listeners for idempotence\n    this.removeEventListener('newListener', this._onNewListener);\n    this.removeEventListener('removeListener', this._onRemoveListener); // then add them\n\n    this.on('newListener', this._onNewListener);\n    this.on('removeListener', this._onRemoveListener);\n  };\n\n  BaseBlockTracker.prototype._onNewListener = function (eventName, handler) {\n    // `newListener` is called *before* the listener is added\n    if (!blockTrackerEvents.includes(eventName)) {\n      return;\n    }\n\n    this._maybeStart();\n  };\n\n  BaseBlockTracker.prototype._onRemoveListener = function (eventName, handler) {\n    // `removeListener` is called *after* the listener is removed\n    if (this._getBlockTrackerEventCount() > 0) {\n      return;\n    }\n\n    this._maybeEnd();\n  };\n\n  BaseBlockTracker.prototype._maybeStart = function () {\n    if (this._isRunning) {\n      return;\n    }\n\n    this._isRunning = true; // cancel setting latest block to stale\n\n    this._cancelBlockResetTimeout();\n\n    this._start();\n  };\n\n  BaseBlockTracker.prototype._maybeEnd = function () {\n    if (!this._isRunning) {\n      return;\n    }\n\n    this._isRunning = false;\n\n    this._setupBlockResetTimeout();\n\n    this._end();\n  };\n\n  BaseBlockTracker.prototype._getBlockTrackerEventCount = function () {\n    var _this = this;\n\n    return blockTrackerEvents.map(function (eventName) {\n      return _this.listenerCount(eventName);\n    }).reduce(calculateSum);\n  };\n\n  BaseBlockTracker.prototype._newPotentialLatest = function (newBlock) {\n    var currentBlock = this._currentBlock; // only update if blok number is higher\n\n    if (currentBlock && utils_1.isHex(currentBlock) && utils_1.isHex(newBlock) && utils_1.hexToNumber(newBlock) <= utils_1.hexToNumber(currentBlock)) {\n      return;\n    }\n\n    this._setCurrentBlock(newBlock);\n  };\n\n  BaseBlockTracker.prototype._setCurrentBlock = function (newBlock) {\n    var oldBlock = this._currentBlock;\n    this._currentBlock = newBlock;\n    this.emit('latest', newBlock);\n    this.emit('sync', {\n      oldBlock: oldBlock,\n      newBlock: newBlock\n    });\n  };\n\n  BaseBlockTracker.prototype._setupBlockResetTimeout = function () {\n    // clear any existing timeout\n    this._cancelBlockResetTimeout(); // clear latest block when stale\n\n\n    this._blockResetTimeout = setTimeout(this._resetCurrentBlock, this._blockResetDuration); // nodejs - dont hold process open\n\n    if (this._blockResetTimeout.unref) {\n      this._blockResetTimeout.unref();\n    }\n  };\n\n  BaseBlockTracker.prototype._cancelBlockResetTimeout = function () {\n    clearTimeout(this._blockResetTimeout);\n  };\n\n  BaseBlockTracker.prototype._resetCurrentBlock = function () {\n    this._currentBlock = null;\n  };\n\n  return BaseBlockTracker;\n}(emitter_1.Emitter);\n\nexports.BaseBlockTracker = BaseBlockTracker;","map":{"version":3,"sources":["../../src/tracker/baseTracker.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n * @packageDocumentation\n * @module harmony-network\n * @hidden\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BaseBlockTracker = void 0;\nvar tslib_1 = require(\"tslib\");\nvar utils_1 = require(\"@harmony-js/utils\");\nvar emitter_1 = require(\"../providers/emitter\");\nvar sec = 1000;\nvar calculateSum = function (accumulator, currentValue) { return accumulator + currentValue; };\nvar blockTrackerEvents = ['sync', 'latest'];\nvar BaseBlockTracker = /** @class */ (function (_super) {\n    tslib_1.__extends(BaseBlockTracker, _super);\n    function BaseBlockTracker(opts) {\n        if (opts === void 0) { opts = {\n            blockResetDuration: undefined,\n            retryTimeout: undefined,\n            keepEventLoopActive: undefined,\n            setSkipCacheFlag: false,\n        }; }\n        var _this = _super.call(this) || this;\n        // config\n        _this._blockResetDuration = opts.blockResetDuration || 20 * sec;\n        // state\n        // tslint:disable-next-line: no-unused-expression\n        _this._blockResetTimeout;\n        _this._currentBlock = null;\n        _this._isRunning = false;\n        // bind functions for internal use\n        // this._onNewListener = this._onNewListener.bind(this);\n        // this._onRemoveListener = this._onRemoveListener.bind(this);\n        // this._resetCurrentBlock = this._resetCurrentBlock.bind(this);\n        // listen for handler changes\n        // this._setupInternalEvents();\n        _this._maybeStart();\n        return _this;\n    }\n    BaseBlockTracker.prototype.isRunning = function () {\n        return this._isRunning;\n    };\n    BaseBlockTracker.prototype.getCurrentBlock = function () {\n        return this._currentBlock;\n    };\n    BaseBlockTracker.prototype.getLatestBlock = function () {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var latestBlock;\n            var _this = this;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        // return if available\n                        if (this._currentBlock) {\n                            return [2 /*return*/, this._currentBlock];\n                        }\n                        return [4 /*yield*/, new Promise(function (resolve) { return _this.once('latest', resolve); })];\n                    case 1:\n                        latestBlock = _a.sent();\n                        // return newly set current block\n                        return [2 /*return*/, latestBlock];\n                }\n            });\n        });\n    };\n    // dont allow module consumer to remove our internal event listeners\n    BaseBlockTracker.prototype.removeAllListeners = function (eventName) {\n        // perform default behavior, preserve fn arity\n        if (eventName) {\n            _super.prototype.removeEventListener.call(this, eventName);\n        }\n        else {\n            _super.prototype.removeEventListener.call(this, '*');\n        }\n        // re-add internal events\n        this._setupInternalEvents();\n        // trigger stop check just in case\n        this._onRemoveListener('*');\n    };\n    //\n    // to be implemented in subclass\n    //\n    BaseBlockTracker.prototype._start = function () {\n        // default behavior is noop\n    };\n    BaseBlockTracker.prototype._end = function () {\n        // default behavior is noop\n    };\n    //\n    // private\n    //\n    BaseBlockTracker.prototype._setupInternalEvents = function () {\n        // first remove listeners for idempotence\n        this.removeEventListener('newListener', this._onNewListener);\n        this.removeEventListener('removeListener', this._onRemoveListener);\n        // then add them\n        this.on('newListener', this._onNewListener);\n        this.on('removeListener', this._onRemoveListener);\n    };\n    BaseBlockTracker.prototype._onNewListener = function (eventName, handler) {\n        // `newListener` is called *before* the listener is added\n        if (!blockTrackerEvents.includes(eventName)) {\n            return;\n        }\n        this._maybeStart();\n    };\n    BaseBlockTracker.prototype._onRemoveListener = function (eventName, handler) {\n        // `removeListener` is called *after* the listener is removed\n        if (this._getBlockTrackerEventCount() > 0) {\n            return;\n        }\n        this._maybeEnd();\n    };\n    BaseBlockTracker.prototype._maybeStart = function () {\n        if (this._isRunning) {\n            return;\n        }\n        this._isRunning = true;\n        // cancel setting latest block to stale\n        this._cancelBlockResetTimeout();\n        this._start();\n    };\n    BaseBlockTracker.prototype._maybeEnd = function () {\n        if (!this._isRunning) {\n            return;\n        }\n        this._isRunning = false;\n        this._setupBlockResetTimeout();\n        this._end();\n    };\n    BaseBlockTracker.prototype._getBlockTrackerEventCount = function () {\n        var _this = this;\n        return blockTrackerEvents\n            .map(function (eventName) { return _this.listenerCount(eventName); })\n            .reduce(calculateSum);\n    };\n    BaseBlockTracker.prototype._newPotentialLatest = function (newBlock) {\n        var currentBlock = this._currentBlock;\n        // only update if blok number is higher\n        if (currentBlock &&\n            utils_1.isHex(currentBlock) &&\n            utils_1.isHex(newBlock) &&\n            utils_1.hexToNumber(newBlock) <= utils_1.hexToNumber(currentBlock)) {\n            return;\n        }\n        this._setCurrentBlock(newBlock);\n    };\n    BaseBlockTracker.prototype._setCurrentBlock = function (newBlock) {\n        var oldBlock = this._currentBlock;\n        this._currentBlock = newBlock;\n        this.emit('latest', newBlock);\n        this.emit('sync', { oldBlock: oldBlock, newBlock: newBlock });\n    };\n    BaseBlockTracker.prototype._setupBlockResetTimeout = function () {\n        // clear any existing timeout\n        this._cancelBlockResetTimeout();\n        // clear latest block when stale\n        this._blockResetTimeout = setTimeout(this._resetCurrentBlock, this._blockResetDuration);\n        // nodejs - dont hold process open\n        if (this._blockResetTimeout.unref) {\n            this._blockResetTimeout.unref();\n        }\n    };\n    BaseBlockTracker.prototype._cancelBlockResetTimeout = function () {\n        clearTimeout(this._blockResetTimeout);\n    };\n    BaseBlockTracker.prototype._resetCurrentBlock = function () {\n        this._currentBlock = null;\n    };\n    return BaseBlockTracker;\n}(emitter_1.Emitter));\nexports.BaseBlockTracker = BaseBlockTracker;\n//# sourceMappingURL=baseTracker.js.map"]},"metadata":{},"sourceType":"script"}