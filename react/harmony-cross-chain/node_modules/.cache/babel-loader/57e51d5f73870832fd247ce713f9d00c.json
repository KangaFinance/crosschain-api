{"ast":null,"code":"\"use strict\";\n/**\n * @packageDocumentation\n * @module harmony-utils\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.assertObject = exports.generateValidateObjects = exports.validateArgs = exports.validatorArray = exports.AssertType = void 0;\n\nvar validators_1 = require(\"./validators\");\n/** @hidden */\n\n\nvar AssertType;\n\n(function (AssertType) {\n  AssertType[\"required\"] = \"required\";\n  AssertType[\"optional\"] = \"optional\";\n})(AssertType = exports.AssertType || (exports.AssertType = {}));\n/** @hidden */\n\n\nexports.validatorArray = {\n  isNumber: [validators_1.isNumber],\n  isString: [validators_1.isString],\n  isBoolean: [validators_1.isBoolean],\n  isArray: [validators_1.isArray],\n  isJsonString: [validators_1.isJsonString],\n  isObject: [validators_1.isObject],\n  isFunction: [validators_1.isFunction],\n  isHex: [validators_1.isHex],\n  isPublicKey: [validators_1.isPublicKey],\n  isPrivateKey: [validators_1.isPrivateKey],\n  isAddress: [validators_1.isAddress],\n  isHash: [validators_1.isHash],\n  isBlockNumber: [validators_1.isBlockNumber],\n  isBech32Address: [validators_1.isBech32Address],\n  isBech32TestNetAddress: [validators_1.isBech32TestNetAddress],\n  isValidAddress: [validators_1.isValidAddress]\n};\n\nfunction validateArgs(args, requiredArgs, optionalArgs) {\n  for (var key in requiredArgs) {\n    if (args[key] !== undefined) {\n      // tslint:disable-next-line: prefer-for-of\n      for (var i = 0; i < requiredArgs[key].length; i += 1) {\n        if (typeof requiredArgs[key][i] !== 'function') {\n          throw new Error('Validator is not a function');\n        }\n\n        if (!requiredArgs[key][i](args[key])) {\n          throw new Error(\"Validation failed for \" + key + \",should be validated by \" + requiredArgs[key][i].validator);\n        }\n      }\n    } else {\n      throw new Error(\"Key not found: \" + key);\n    }\n  }\n\n  for (var key in optionalArgs) {\n    if (args[key]) {\n      // tslint:disable-next-line: prefer-for-of\n      for (var i = 0; i < optionalArgs[key].length; i += 1) {\n        if (typeof optionalArgs[key][i] !== 'function') {\n          throw new Error('Validator is not a function');\n        }\n\n        if (!optionalArgs[key][i](args[key])) {\n          throw new Error(\"Validation failed for \" + key + \",should be validated by \" + optionalArgs[key][i].validator);\n        }\n      }\n    }\n  }\n\n  return true;\n}\n\nexports.validateArgs = validateArgs;\n\nfunction generateValidateObjects(validatorObject) {\n  var requiredArgs = {};\n  var optionalArgs = {};\n\n  for (var index in validatorObject) {\n    if (index !== undefined) {\n      var newObjectKey = index;\n      var newObjectValid = validatorObject[index][0];\n      var isRequired = validatorObject[index][1];\n\n      if (isRequired === AssertType.required) {\n        requiredArgs[newObjectKey] = exports.validatorArray[newObjectValid];\n      } else {\n        optionalArgs[newObjectKey] = exports.validatorArray[newObjectValid];\n      }\n    }\n  }\n\n  return {\n    requiredArgs: requiredArgs,\n    optionalArgs: optionalArgs\n  };\n}\n\nexports.generateValidateObjects = generateValidateObjects;\n\nvar assertObject = function (input) {\n  return function (target, key, descriptor) {\n    var _a = generateValidateObjects(input),\n        requiredArgs = _a.requiredArgs,\n        optionalArgs = _a.optionalArgs;\n\n    var original = descriptor.value;\n\n    function interceptor() {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      validateArgs(args[0], requiredArgs, optionalArgs);\n      return original.apply(this, args);\n    }\n\n    descriptor.value = interceptor;\n    return descriptor;\n  };\n};\n\nexports.assertObject = assertObject;","map":{"version":3,"sources":["../src/utils.ts"],"names":[],"mappings":";AAAA;;;AAGG;;;;;;;AAEH,IAAA,YAAA,GAAA,OAAA,CAAA,cAAA,CAAA;AAmBA;;;AACA,IAAY,UAAZ;;AAAA,CAAA,UAAY,UAAZ,EAAsB;AACpB,EAAA,UAAA,CAAA,UAAA,CAAA,GAAA,UAAA;AACA,EAAA,UAAA,CAAA,UAAA,CAAA,GAAA,UAAA;AACD,CAHD,EAAY,UAAU,GAAV,OAAA,CAAA,UAAA,KAAA,OAAA,CAAA,UAAA,GAAU,EAAV,CAAZ;AAKA;;;AACa,OAAA,CAAA,cAAA,GAAsB;AACjC,EAAA,QAAQ,EAAE,CAAC,YAAA,CAAA,QAAD,CADuB;AAEjC,EAAA,QAAQ,EAAE,CAAC,YAAA,CAAA,QAAD,CAFuB;AAGjC,EAAA,SAAS,EAAE,CAAC,YAAA,CAAA,SAAD,CAHsB;AAIjC,EAAA,OAAO,EAAE,CAAC,YAAA,CAAA,OAAD,CAJwB;AAKjC,EAAA,YAAY,EAAE,CAAC,YAAA,CAAA,YAAD,CALmB;AAMjC,EAAA,QAAQ,EAAE,CAAC,YAAA,CAAA,QAAD,CANuB;AAOjC,EAAA,UAAU,EAAE,CAAC,YAAA,CAAA,UAAD,CAPqB;AAQjC,EAAA,KAAK,EAAE,CAAC,YAAA,CAAA,KAAD,CAR0B;AASjC,EAAA,WAAW,EAAE,CAAC,YAAA,CAAA,WAAD,CAToB;AAUjC,EAAA,YAAY,EAAE,CAAC,YAAA,CAAA,YAAD,CAVmB;AAWjC,EAAA,SAAS,EAAE,CAAC,YAAA,CAAA,SAAD,CAXsB;AAYjC,EAAA,MAAM,EAAE,CAAC,YAAA,CAAA,MAAD,CAZyB;AAajC,EAAA,aAAa,EAAE,CAAC,YAAA,CAAA,aAAD,CAbkB;AAcjC,EAAA,eAAe,EAAE,CAAC,YAAA,CAAA,eAAD,CAdgB;AAejC,EAAA,sBAAsB,EAAE,CAAC,YAAA,CAAA,sBAAD,CAfS;AAgBjC,EAAA,cAAc,EAAE,CAAC,YAAA,CAAA,cAAD;AAhBiB,CAAtB;;AAmBb,SAAgB,YAAhB,CAA6B,IAA7B,EAAwC,YAAxC,EAA2D,YAA3D,EAA4E;AAC1E,OAAK,IAAM,GAAX,IAAkB,YAAlB,EAAgC;AAC9B,QAAI,IAAI,CAAC,GAAD,CAAJ,KAAc,SAAlB,EAA6B;AAC3B;AACA,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,YAAY,CAAC,GAAD,CAAZ,CAAkB,MAAtC,EAA8C,CAAC,IAAI,CAAnD,EAAsD;AACpD,YAAI,OAAO,YAAY,CAAC,GAAD,CAAZ,CAAkB,CAAlB,CAAP,KAAgC,UAApC,EAAgD;AAC9C,gBAAM,IAAI,KAAJ,CAAU,6BAAV,CAAN;AACD;;AAED,YAAI,CAAC,YAAY,CAAC,GAAD,CAAZ,CAAkB,CAAlB,EAAqB,IAAI,CAAC,GAAD,CAAzB,CAAL,EAAsC;AACpC,gBAAM,IAAI,KAAJ,CACJ,2BAAyB,GAAzB,GAA4B,0BAA5B,GAAuD,YAAY,CAAC,GAAD,CAAZ,CAAkB,CAAlB,EAAqB,SADxE,CAAN;AAGD;AACF;AACF,KAbD,MAaO;AACL,YAAM,IAAI,KAAJ,CAAU,oBAAkB,GAA5B,CAAN;AACD;AACF;;AAED,OAAK,IAAM,GAAX,IAAkB,YAAlB,EAAgC;AAC9B,QAAI,IAAI,CAAC,GAAD,CAAR,EAAe;AACb;AACA,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,YAAY,CAAC,GAAD,CAAZ,CAAkB,MAAtC,EAA8C,CAAC,IAAI,CAAnD,EAAsD;AACpD,YAAI,OAAO,YAAY,CAAC,GAAD,CAAZ,CAAkB,CAAlB,CAAP,KAAgC,UAApC,EAAgD;AAC9C,gBAAM,IAAI,KAAJ,CAAU,6BAAV,CAAN;AACD;;AAED,YAAI,CAAC,YAAY,CAAC,GAAD,CAAZ,CAAkB,CAAlB,EAAqB,IAAI,CAAC,GAAD,CAAzB,CAAL,EAAsC;AACpC,gBAAM,IAAI,KAAJ,CACJ,2BAAyB,GAAzB,GAA4B,0BAA5B,GAAuD,YAAY,CAAC,GAAD,CAAZ,CAAkB,CAAlB,EAAqB,SADxE,CAAN;AAGD;AACF;AACF;AACF;;AACD,SAAO,IAAP;AACD;;AArCD,OAAA,CAAA,YAAA,GAAA,YAAA;;AAuCA,SAAgB,uBAAhB,CAAwC,eAAxC,EAA+E;AAC7E,MAAM,YAAY,GAAQ,EAA1B;AACA,MAAM,YAAY,GAAQ,EAA1B;;AACA,OAAK,IAAM,KAAX,IAAoB,eAApB,EAAqC;AACnC,QAAI,KAAK,KAAK,SAAd,EAAyB;AACvB,UAAM,YAAY,GAAG,KAArB;AACA,UAAM,cAAc,GAAG,eAAe,CAAC,KAAD,CAAf,CAAuB,CAAvB,CAAvB;AACA,UAAM,UAAU,GAAG,eAAe,CAAC,KAAD,CAAf,CAAuB,CAAvB,CAAnB;;AACA,UAAI,UAAU,KAAK,UAAU,CAAC,QAA9B,EAAwC;AACtC,QAAA,YAAY,CAAC,YAAD,CAAZ,GAA6B,OAAA,CAAA,cAAA,CAAe,cAAf,CAA7B;AACD,OAFD,MAEO;AACL,QAAA,YAAY,CAAC,YAAD,CAAZ,GAA6B,OAAA,CAAA,cAAA,CAAe,cAAf,CAA7B;AACD;AACF;AACF;;AACD,SAAO;AAAE,IAAA,YAAY,EAAA,YAAd;AAAgB,IAAA,YAAY,EAAA;AAA5B,GAAP;AACD;;AAhBD,OAAA,CAAA,uBAAA,GAAA,uBAAA;;AAkBA,IAAM,YAAY,GAAG,UAAC,KAAD,EAAW;AAAK,SAAA,UAAC,MAAD,EAAc,GAAd,EAAwB,UAAxB,EAAsD;AACnF,QAAA,EAAA,GAAiC,uBAAuB,CAAC,KAAD,CAAxD;AAAA,QAAE,YAAY,GAAA,EAAA,CAAA,YAAd;AAAA,QAAgB,YAAY,GAAA,EAAA,CAAA,YAA5B;;AACN,QAAM,QAAQ,GAAG,UAAU,CAAC,KAA5B;;AACA,aAAS,WAAT,GAAoB;AAAY,UAAA,IAAA,GAAA,EAAA;;WAAA,IAAA,EAAA,GAAA,C,EAAA,EAAA,GAAA,SAAA,CAAA,M,EAAA,EAAA,E,EAAc;AAAd,QAAA,IAAA,CAAA,EAAA,CAAA,GAAA,SAAA,CAAA,EAAA,CAAA;;;AAC9B,MAAA,YAAY,CAAC,IAAI,CAAC,CAAD,CAAL,EAAU,YAAV,EAAwB,YAAxB,CAAZ;AACA,aAAO,QAAQ,CAAC,KAAT,CAAe,IAAf,EAAqB,IAArB,CAAP;AACD;;AACD,IAAA,UAAU,CAAC,KAAX,GAAmB,WAAnB;AACA,WAAO,UAAP;AARmC,GAAA;AASpC,CATD;;AAWS,OAAA,CAAA,YAAA,GAAA,YAAA","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n * @packageDocumentation\n * @module harmony-utils\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.assertObject = exports.generateValidateObjects = exports.validateArgs = exports.validatorArray = exports.AssertType = void 0;\nvar validators_1 = require(\"./validators\");\n/** @hidden */\nvar AssertType;\n(function (AssertType) {\n    AssertType[\"required\"] = \"required\";\n    AssertType[\"optional\"] = \"optional\";\n})(AssertType = exports.AssertType || (exports.AssertType = {}));\n/** @hidden */\nexports.validatorArray = {\n    isNumber: [validators_1.isNumber],\n    isString: [validators_1.isString],\n    isBoolean: [validators_1.isBoolean],\n    isArray: [validators_1.isArray],\n    isJsonString: [validators_1.isJsonString],\n    isObject: [validators_1.isObject],\n    isFunction: [validators_1.isFunction],\n    isHex: [validators_1.isHex],\n    isPublicKey: [validators_1.isPublicKey],\n    isPrivateKey: [validators_1.isPrivateKey],\n    isAddress: [validators_1.isAddress],\n    isHash: [validators_1.isHash],\n    isBlockNumber: [validators_1.isBlockNumber],\n    isBech32Address: [validators_1.isBech32Address],\n    isBech32TestNetAddress: [validators_1.isBech32TestNetAddress],\n    isValidAddress: [validators_1.isValidAddress],\n};\nfunction validateArgs(args, requiredArgs, optionalArgs) {\n    for (var key in requiredArgs) {\n        if (args[key] !== undefined) {\n            // tslint:disable-next-line: prefer-for-of\n            for (var i = 0; i < requiredArgs[key].length; i += 1) {\n                if (typeof requiredArgs[key][i] !== 'function') {\n                    throw new Error('Validator is not a function');\n                }\n                if (!requiredArgs[key][i](args[key])) {\n                    throw new Error(\"Validation failed for \" + key + \",should be validated by \" + requiredArgs[key][i].validator);\n                }\n            }\n        }\n        else {\n            throw new Error(\"Key not found: \" + key);\n        }\n    }\n    for (var key in optionalArgs) {\n        if (args[key]) {\n            // tslint:disable-next-line: prefer-for-of\n            for (var i = 0; i < optionalArgs[key].length; i += 1) {\n                if (typeof optionalArgs[key][i] !== 'function') {\n                    throw new Error('Validator is not a function');\n                }\n                if (!optionalArgs[key][i](args[key])) {\n                    throw new Error(\"Validation failed for \" + key + \",should be validated by \" + optionalArgs[key][i].validator);\n                }\n            }\n        }\n    }\n    return true;\n}\nexports.validateArgs = validateArgs;\nfunction generateValidateObjects(validatorObject) {\n    var requiredArgs = {};\n    var optionalArgs = {};\n    for (var index in validatorObject) {\n        if (index !== undefined) {\n            var newObjectKey = index;\n            var newObjectValid = validatorObject[index][0];\n            var isRequired = validatorObject[index][1];\n            if (isRequired === AssertType.required) {\n                requiredArgs[newObjectKey] = exports.validatorArray[newObjectValid];\n            }\n            else {\n                optionalArgs[newObjectKey] = exports.validatorArray[newObjectValid];\n            }\n        }\n    }\n    return { requiredArgs: requiredArgs, optionalArgs: optionalArgs };\n}\nexports.generateValidateObjects = generateValidateObjects;\nvar assertObject = function (input) { return function (target, key, descriptor) {\n    var _a = generateValidateObjects(input), requiredArgs = _a.requiredArgs, optionalArgs = _a.optionalArgs;\n    var original = descriptor.value;\n    function interceptor() {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        validateArgs(args[0], requiredArgs, optionalArgs);\n        return original.apply(this, args);\n    }\n    descriptor.value = interceptor;\n    return descriptor;\n}; };\nexports.assertObject = assertObject;\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"script"}