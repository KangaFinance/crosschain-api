{"ast":null,"code":"\"use strict\";\n/**\n * @packageDocumentation\n * @module harmony-crypto\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decryptPhrase = exports.encryptPhrase = exports.decrypt = exports.encrypt = void 0;\n\nvar tslib_1 = require(\"tslib\");\n\nvar aes_js_1 = tslib_1.__importDefault(require(\"aes-js\")); // import scrypt from 'scrypt.js';\n\n\nvar scrypt_shim_1 = tslib_1.__importDefault(require(\"scrypt-shim\"));\n\nvar pbkdf2_1 = require(\"pbkdf2\");\n\nvar uuid_1 = tslib_1.__importDefault(require(\"uuid\"));\n\nvar utils_1 = require(\"@harmony-js/utils\");\n\nvar random_1 = require(\"./random\");\n\nvar keyTool_1 = require(\"./keyTool\");\n\nvar bytes_1 = require(\"./bytes\");\n\nvar keccak256_1 = require(\"./keccak256\");\n/** @hidden */\n\n\nvar DEFAULT_ALGORITHM = 'aes-128-ctr';\n/**\n * getDerivedKey\n *\n * NOTE: only scrypt and pbkdf2 are supported.\n *\n * @param {Buffer} key - the passphrase\n * @param {KDF} kdf - the key derivation function to be used\n * @param {KDFParams} params - params for the kdf\n *\n * @returns {Promise<Buffer>}\n */\n\nfunction getDerivedKey(key, kdf, params) {\n  return tslib_1.__awaiter(this, void 0, void 0, function () {\n    var salt, _a, c, dklen, _b, n, r, p, dklen;\n\n    return tslib_1.__generator(this, function (_c) {\n      salt = Buffer.from(params.salt, 'hex');\n\n      if (kdf === 'pbkdf2') {\n        _a = params, c = _a.c, dklen = _a.dklen;\n        return [2\n        /*return*/\n        , pbkdf2_1.pbkdf2Sync(key, salt, c, dklen, 'sha256')];\n      }\n\n      if (kdf === 'scrypt') {\n        _b = params, n = _b.n, r = _b.r, p = _b.p, dklen = _b.dklen;\n        return [2\n        /*return*/\n        , scrypt_shim_1.default(key, salt, n, r, p, dklen)];\n      }\n\n      throw new Error('Only pbkdf2 and scrypt are supported');\n    });\n  });\n}\n/**\n * This method will map the current Account object to V3Keystore object.\n *\n * @method encrypt\n *\n * @param {string} privateKey\n * @param {string} password\n * @param {object} options\n *\n * @return {{version, id, address, crypto}}\n */\n\n\nexports.encrypt = function (privateKey, password, options) {\n  return tslib_1.__awaiter(void 0, void 0, void 0, function () {\n    var address, salt, iv, kdf, level, uuidRandom, n, kdfparams, derivedKey, cipher, ciphertext, mac;\n    return tslib_1.__generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          if (!utils_1.isPrivateKey(privateKey)) {\n            throw new Error('privateKey is not correct');\n          }\n\n          if (typeof password !== 'string') {\n            throw new Error('password is not found');\n          }\n\n          address = keyTool_1.getAddressFromPrivateKey(privateKey);\n          salt = random_1.randomBytes(32);\n          iv = Buffer.from(random_1.randomBytes(16), 'hex');\n          kdf = options !== undefined ? options.kdf ? options.kdf : 'scrypt' : 'scrypt';\n          level = options !== undefined ? options.level ? options.level : 8192 : 8192;\n          uuidRandom = options !== undefined ? options.uuid : undefined;\n          n = kdf === 'pbkdf2' ? 262144 : level;\n          kdfparams = {\n            salt: salt,\n            n: n,\n            r: 8,\n            p: 1,\n            dklen: 32\n          };\n          return [4\n          /*yield*/\n          , getDerivedKey(Buffer.from(password), kdf, kdfparams)];\n\n        case 1:\n          derivedKey = _a.sent();\n          cipher = new aes_js_1.default.ModeOfOperation.ctr(derivedKey.slice(0, 16), new aes_js_1.default.Counter(iv));\n\n          if (!cipher) {\n            throw new Error('Unsupported cipher');\n          }\n\n          ciphertext = Buffer.from(cipher.encrypt(Buffer.from(privateKey.replace('0x', ''), 'hex')));\n          mac = keccak256_1.keccak256(bytes_1.concat([derivedKey.slice(16, 32), ciphertext]));\n          return [2\n          /*return*/\n          , JSON.stringify({\n            version: 3,\n            id: uuid_1.default.v4({\n              random: uuidRandom || bytes_1.hexToIntArray(random_1.randomBytes(16))\n            }),\n            address: address.toLowerCase().replace('0x', ''),\n            crypto: {\n              ciphertext: ciphertext.toString('hex'),\n              cipherparams: {\n                iv: iv.toString('hex')\n              },\n              cipher: DEFAULT_ALGORITHM,\n              kdf: kdf,\n              kdfparams: kdfparams,\n              mac: mac.replace('0x', '')\n            }\n          })];\n      }\n    });\n  });\n};\n/**\n * @function decrypt\n * @param  {Keystore} keystore - Keystore file\n * @param  {string} password - password string\n * @return {string} privateKey\n */\n\n\nexports.decrypt = function (keystore, password) {\n  return tslib_1.__awaiter(void 0, void 0, void 0, function () {\n    var ciphertext, iv, kdfparams, derivedKey, mac, CTR, cipher, decrypted;\n    return tslib_1.__generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          ciphertext = Buffer.from(keystore.crypto.ciphertext, 'hex');\n          iv = Buffer.from(keystore.crypto.cipherparams.iv, 'hex');\n          kdfparams = keystore.crypto.kdfparams;\n          return [4\n          /*yield*/\n          , getDerivedKey(Buffer.from(password), keystore.crypto.kdf, kdfparams)];\n\n        case 1:\n          derivedKey = _a.sent();\n          mac = keccak256_1.keccak256(bytes_1.concat([derivedKey.slice(16, 32), ciphertext])).replace('0x', '');\n\n          if (mac.toUpperCase() !== keystore.crypto.mac.toUpperCase()) {\n            return [2\n            /*return*/\n            , Promise.reject(new Error('Failed to decrypt.'))];\n          }\n\n          CTR = aes_js_1.default.ModeOfOperation.ctr;\n          cipher = new CTR(derivedKey.slice(0, 16), new aes_js_1.default.Counter(iv));\n          decrypted = '0x' + Buffer.from(cipher.decrypt(ciphertext)).toString('hex');\n          return [2\n          /*return*/\n          , decrypted];\n      }\n    });\n  });\n};\n/**\n * encrypt Phrase\n */\n\n\nexports.encryptPhrase = function (phrase, password, options) {\n  return tslib_1.__awaiter(void 0, void 0, void 0, function () {\n    var salt, iv, kdf, level, uuidRandom, n, kdfparams, derivedKey, cipher, ciphertext, mac;\n    return tslib_1.__generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          if (typeof password !== 'string') {\n            throw new Error('password is not found');\n          }\n\n          salt = random_1.randomBytes(32);\n          iv = Buffer.from(random_1.randomBytes(16), 'hex');\n          kdf = options !== undefined ? options.kdf ? options.kdf : 'scrypt' : 'scrypt';\n          level = options !== undefined ? options.level ? options.level : 8192 : 8192;\n          uuidRandom = options !== undefined ? options.uuid : undefined;\n          n = kdf === 'pbkdf2' ? 262144 : level;\n          kdfparams = {\n            salt: salt,\n            n: n,\n            r: 8,\n            p: 1,\n            dklen: 32\n          };\n          return [4\n          /*yield*/\n          , getDerivedKey(Buffer.from(password), kdf, kdfparams)];\n\n        case 1:\n          derivedKey = _a.sent();\n          cipher = new aes_js_1.default.ModeOfOperation.ctr(derivedKey.slice(0, 16), new aes_js_1.default.Counter(iv));\n\n          if (!cipher) {\n            throw new Error('Unsupported cipher');\n          }\n\n          ciphertext = Buffer.from(cipher.encrypt(Buffer.from(phrase)));\n          mac = keccak256_1.keccak256(bytes_1.concat([derivedKey.slice(16, 32), ciphertext]));\n          return [2\n          /*return*/\n          , JSON.stringify({\n            version: 3,\n            id: uuid_1.default.v4({\n              random: uuidRandom || bytes_1.hexToIntArray(random_1.randomBytes(16))\n            }),\n            crypto: {\n              ciphertext: ciphertext.toString('hex'),\n              cipherparams: {\n                iv: iv.toString('hex')\n              },\n              cipher: DEFAULT_ALGORITHM,\n              kdf: kdf,\n              kdfparams: kdfparams,\n              mac: mac.replace('0x', '')\n            }\n          })];\n      }\n    });\n  });\n};\n/**\n * decrypt phrase\n */\n\n\nexports.decryptPhrase = function (keystore, password) {\n  return tslib_1.__awaiter(void 0, void 0, void 0, function () {\n    var result;\n    return tslib_1.__generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          return [4\n          /*yield*/\n          , exports.decrypt(keystore, password)];\n\n        case 1:\n          result = _a.sent();\n          return [2\n          /*return*/\n          , Buffer.from(result.replace('0x', ''), 'hex').toString()];\n      }\n    });\n  });\n};","map":{"version":3,"sources":["../src/keystore.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n * @packageDocumentation\n * @module harmony-crypto\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decryptPhrase = exports.encryptPhrase = exports.decrypt = exports.encrypt = void 0;\nvar tslib_1 = require(\"tslib\");\nvar aes_js_1 = tslib_1.__importDefault(require(\"aes-js\"));\n// import scrypt from 'scrypt.js';\nvar scrypt_shim_1 = tslib_1.__importDefault(require(\"scrypt-shim\"));\nvar pbkdf2_1 = require(\"pbkdf2\");\nvar uuid_1 = tslib_1.__importDefault(require(\"uuid\"));\nvar utils_1 = require(\"@harmony-js/utils\");\nvar random_1 = require(\"./random\");\nvar keyTool_1 = require(\"./keyTool\");\nvar bytes_1 = require(\"./bytes\");\nvar keccak256_1 = require(\"./keccak256\");\n/** @hidden */\nvar DEFAULT_ALGORITHM = 'aes-128-ctr';\n/**\n * getDerivedKey\n *\n * NOTE: only scrypt and pbkdf2 are supported.\n *\n * @param {Buffer} key - the passphrase\n * @param {KDF} kdf - the key derivation function to be used\n * @param {KDFParams} params - params for the kdf\n *\n * @returns {Promise<Buffer>}\n */\nfunction getDerivedKey(key, kdf, params) {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n        var salt, _a, c, dklen, _b, n, r, p, dklen;\n        return tslib_1.__generator(this, function (_c) {\n            salt = Buffer.from(params.salt, 'hex');\n            if (kdf === 'pbkdf2') {\n                _a = params, c = _a.c, dklen = _a.dklen;\n                return [2 /*return*/, pbkdf2_1.pbkdf2Sync(key, salt, c, dklen, 'sha256')];\n            }\n            if (kdf === 'scrypt') {\n                _b = params, n = _b.n, r = _b.r, p = _b.p, dklen = _b.dklen;\n                return [2 /*return*/, scrypt_shim_1.default(key, salt, n, r, p, dklen)];\n            }\n            throw new Error('Only pbkdf2 and scrypt are supported');\n        });\n    });\n}\n/**\n * This method will map the current Account object to V3Keystore object.\n *\n * @method encrypt\n *\n * @param {string} privateKey\n * @param {string} password\n * @param {object} options\n *\n * @return {{version, id, address, crypto}}\n */\nexports.encrypt = function (privateKey, password, options) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {\n    var address, salt, iv, kdf, level, uuidRandom, n, kdfparams, derivedKey, cipher, ciphertext, mac;\n    return tslib_1.__generator(this, function (_a) {\n        switch (_a.label) {\n            case 0:\n                if (!utils_1.isPrivateKey(privateKey)) {\n                    throw new Error('privateKey is not correct');\n                }\n                if (typeof password !== 'string') {\n                    throw new Error('password is not found');\n                }\n                address = keyTool_1.getAddressFromPrivateKey(privateKey);\n                salt = random_1.randomBytes(32);\n                iv = Buffer.from(random_1.randomBytes(16), 'hex');\n                kdf = options !== undefined ? (options.kdf ? options.kdf : 'scrypt') : 'scrypt';\n                level = options !== undefined ? (options.level ? options.level : 8192) : 8192;\n                uuidRandom = options !== undefined ? options.uuid : undefined;\n                n = kdf === 'pbkdf2' ? 262144 : level;\n                kdfparams = {\n                    salt: salt,\n                    n: n,\n                    r: 8,\n                    p: 1,\n                    dklen: 32,\n                };\n                return [4 /*yield*/, getDerivedKey(Buffer.from(password), kdf, kdfparams)];\n            case 1:\n                derivedKey = _a.sent();\n                cipher = new aes_js_1.default.ModeOfOperation.ctr(derivedKey.slice(0, 16), new aes_js_1.default.Counter(iv));\n                if (!cipher) {\n                    throw new Error('Unsupported cipher');\n                }\n                ciphertext = Buffer.from(cipher.encrypt(Buffer.from(privateKey.replace('0x', ''), 'hex')));\n                mac = keccak256_1.keccak256(bytes_1.concat([derivedKey.slice(16, 32), ciphertext]));\n                return [2 /*return*/, JSON.stringify({\n                        version: 3,\n                        id: uuid_1.default.v4({ random: uuidRandom || bytes_1.hexToIntArray(random_1.randomBytes(16)) }),\n                        address: address.toLowerCase().replace('0x', ''),\n                        crypto: {\n                            ciphertext: ciphertext.toString('hex'),\n                            cipherparams: {\n                                iv: iv.toString('hex'),\n                            },\n                            cipher: DEFAULT_ALGORITHM,\n                            kdf: kdf,\n                            kdfparams: kdfparams,\n                            mac: mac.replace('0x', ''),\n                        },\n                    })];\n        }\n    });\n}); };\n/**\n * @function decrypt\n * @param  {Keystore} keystore - Keystore file\n * @param  {string} password - password string\n * @return {string} privateKey\n */\nexports.decrypt = function (keystore, password) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {\n    var ciphertext, iv, kdfparams, derivedKey, mac, CTR, cipher, decrypted;\n    return tslib_1.__generator(this, function (_a) {\n        switch (_a.label) {\n            case 0:\n                ciphertext = Buffer.from(keystore.crypto.ciphertext, 'hex');\n                iv = Buffer.from(keystore.crypto.cipherparams.iv, 'hex');\n                kdfparams = keystore.crypto.kdfparams;\n                return [4 /*yield*/, getDerivedKey(Buffer.from(password), keystore.crypto.kdf, kdfparams)];\n            case 1:\n                derivedKey = _a.sent();\n                mac = keccak256_1.keccak256(bytes_1.concat([derivedKey.slice(16, 32), ciphertext])).replace('0x', '');\n                if (mac.toUpperCase() !== keystore.crypto.mac.toUpperCase()) {\n                    return [2 /*return*/, Promise.reject(new Error('Failed to decrypt.'))];\n                }\n                CTR = aes_js_1.default.ModeOfOperation.ctr;\n                cipher = new CTR(derivedKey.slice(0, 16), new aes_js_1.default.Counter(iv));\n                decrypted = '0x' + Buffer.from(cipher.decrypt(ciphertext)).toString('hex');\n                return [2 /*return*/, decrypted];\n        }\n    });\n}); };\n/**\n * encrypt Phrase\n */\nexports.encryptPhrase = function (phrase, password, options) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {\n    var salt, iv, kdf, level, uuidRandom, n, kdfparams, derivedKey, cipher, ciphertext, mac;\n    return tslib_1.__generator(this, function (_a) {\n        switch (_a.label) {\n            case 0:\n                if (typeof password !== 'string') {\n                    throw new Error('password is not found');\n                }\n                salt = random_1.randomBytes(32);\n                iv = Buffer.from(random_1.randomBytes(16), 'hex');\n                kdf = options !== undefined ? (options.kdf ? options.kdf : 'scrypt') : 'scrypt';\n                level = options !== undefined ? (options.level ? options.level : 8192) : 8192;\n                uuidRandom = options !== undefined ? options.uuid : undefined;\n                n = kdf === 'pbkdf2' ? 262144 : level;\n                kdfparams = {\n                    salt: salt,\n                    n: n,\n                    r: 8,\n                    p: 1,\n                    dklen: 32,\n                };\n                return [4 /*yield*/, getDerivedKey(Buffer.from(password), kdf, kdfparams)];\n            case 1:\n                derivedKey = _a.sent();\n                cipher = new aes_js_1.default.ModeOfOperation.ctr(derivedKey.slice(0, 16), new aes_js_1.default.Counter(iv));\n                if (!cipher) {\n                    throw new Error('Unsupported cipher');\n                }\n                ciphertext = Buffer.from(cipher.encrypt(Buffer.from(phrase)));\n                mac = keccak256_1.keccak256(bytes_1.concat([derivedKey.slice(16, 32), ciphertext]));\n                return [2 /*return*/, JSON.stringify({\n                        version: 3,\n                        id: uuid_1.default.v4({ random: uuidRandom || bytes_1.hexToIntArray(random_1.randomBytes(16)) }),\n                        crypto: {\n                            ciphertext: ciphertext.toString('hex'),\n                            cipherparams: {\n                                iv: iv.toString('hex'),\n                            },\n                            cipher: DEFAULT_ALGORITHM,\n                            kdf: kdf,\n                            kdfparams: kdfparams,\n                            mac: mac.replace('0x', ''),\n                        },\n                    })];\n        }\n    });\n}); };\n/**\n * decrypt phrase\n */\nexports.decryptPhrase = function (keystore, password) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {\n    var result;\n    return tslib_1.__generator(this, function (_a) {\n        switch (_a.label) {\n            case 0: return [4 /*yield*/, exports.decrypt(keystore, password)];\n            case 1:\n                result = _a.sent();\n                return [2 /*return*/, Buffer.from(result.replace('0x', ''), 'hex').toString()];\n        }\n    });\n}); };\n//# sourceMappingURL=keystore.js.map"]},"metadata":{},"sourceType":"script"}