{"ast":null,"code":"\"use strict\";\n/**\n * @packageDocumentation\n * @module harmony-crypto\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.randomBytes = void 0;\n/**\n * Uses JS-native CSPRNG to generate a specified number of bytes.\n * @NOTE\n * this method throws if no PRNG is available.\n * @param {Number} bytes bytes number to generate\n * @return {String} ramdom hex string\n */\n\nexports.randomBytes = function (bytes) {\n  var randBz;\n\n  if (typeof window !== 'undefined' && window.crypto && window.crypto.getRandomValues) {\n    randBz = window.crypto.getRandomValues(new Uint8Array(bytes));\n  } else if (typeof require !== 'undefined') {\n    randBz = require('crypto').randomBytes(bytes);\n  } else {\n    throw new Error('Unable to generate safe random numbers.');\n  }\n\n  var randStr = '';\n\n  for (var i = 0; i < bytes; i += 1) {\n    randStr += (\"00\" + randBz[i].toString(16)).slice(-2);\n  }\n\n  return randStr;\n};","map":{"version":3,"sources":["../src/random.ts"],"names":[],"mappings":";AAAA;;;AAGG;;;;;;AAEH;;;;;;AAMG;;AACU,OAAA,CAAA,WAAA,GAAc,UAAC,KAAD,EAAc;AACvC,MAAI,MAAJ;;AAEA,MAAI,OAAO,MAAP,KAAkB,WAAlB,IAAiC,MAAM,CAAC,MAAxC,IAAkD,MAAM,CAAC,MAAP,CAAc,eAApE,EAAqF;AACnF,IAAA,MAAM,GAAG,MAAM,CAAC,MAAP,CAAc,eAAd,CAA8B,IAAI,UAAJ,CAAe,KAAf,CAA9B,CAAT;AACD,GAFD,MAEO,IAAI,OAAO,OAAP,KAAmB,WAAvB,EAAoC;AACzC,IAAA,MAAM,GAAG,OAAO,CAAC,QAAD,CAAP,CAAkB,WAAlB,CAA8B,KAA9B,CAAT;AACD,GAFM,MAEA;AACL,UAAM,IAAI,KAAJ,CAAU,yCAAV,CAAN;AACD;;AAED,MAAI,OAAO,GAAG,EAAd;;AACA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAApB,EAA2B,CAAC,IAAI,CAAhC,EAAmC;AACjC,IAAA,OAAO,IAAI,CAAA,OAAK,MAAM,CAAC,CAAD,CAAN,CAAU,QAAV,CAAmB,EAAnB,CAAL,EAA8B,KAA9B,CAAoC,CAAC,CAArC,CAAX;AACD;;AAED,SAAO,OAAP;AACD,CAjBY","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n * @packageDocumentation\n * @module harmony-crypto\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.randomBytes = void 0;\n/**\n * Uses JS-native CSPRNG to generate a specified number of bytes.\n * @NOTE\n * this method throws if no PRNG is available.\n * @param {Number} bytes bytes number to generate\n * @return {String} ramdom hex string\n */\nexports.randomBytes = function (bytes) {\n    var randBz;\n    if (typeof window !== 'undefined' && window.crypto && window.crypto.getRandomValues) {\n        randBz = window.crypto.getRandomValues(new Uint8Array(bytes));\n    }\n    else if (typeof require !== 'undefined') {\n        randBz = require('crypto').randomBytes(bytes);\n    }\n    else {\n        throw new Error('Unable to generate safe random numbers.');\n    }\n    var randStr = '';\n    for (var i = 0; i < bytes; i += 1) {\n        randStr += (\"00\" + randBz[i].toString(16)).slice(-2);\n    }\n    return randStr;\n};\n//# sourceMappingURL=random.js.map"]},"metadata":{},"sourceType":"script"}