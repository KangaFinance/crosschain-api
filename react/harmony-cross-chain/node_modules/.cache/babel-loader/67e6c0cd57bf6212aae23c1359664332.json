{"ast":null,"code":"\"use strict\";\n/**\n * @packageDocumentation\n * @module harmony-crypto\n * @hidden\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fromBech32 = exports.toBech32 = exports.convertBits = exports.tHRP = exports.HRP = exports.bech32Decode = exports.bech32Encode = void 0;\n\nvar utils_1 = require(\"@harmony-js/utils\");\n\nvar keyTool_1 = require(\"./keyTool\"); // This code is taken from https://github.com/sipa/bech32/tree/bdc264f84014c234e908d72026b7b780122be11f/ref/javascript\n// Copyright (c) 2017 Pieter Wuille\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\nvar CHARSET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';\nvar GENERATOR = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\n\nvar polymod = function (values) {\n  var chk = 1; // tslint:disable-next-line\n\n  for (var p = 0; p < values.length; ++p) {\n    var top_1 = chk >> 25;\n    chk = (chk & 0x1ffffff) << 5 ^ values[p];\n\n    for (var i = 0; i < 5; ++i) {\n      if (top_1 >> i & 1) {\n        chk ^= GENERATOR[i];\n      }\n    }\n  }\n\n  return chk;\n};\n\nvar hrpExpand = function (hrp) {\n  var ret = [];\n  var p;\n\n  for (p = 0; p < hrp.length; ++p) {\n    ret.push(hrp.charCodeAt(p) >> 5);\n  }\n\n  ret.push(0);\n\n  for (p = 0; p < hrp.length; ++p) {\n    ret.push(hrp.charCodeAt(p) & 31);\n  }\n\n  return Buffer.from(ret);\n};\n\nfunction verifyChecksum(hrp, data) {\n  return polymod(Buffer.concat([hrpExpand(hrp), data])) === 1;\n}\n\nfunction createChecksum(hrp, data) {\n  var values = Buffer.concat([Buffer.from(hrpExpand(hrp)), data, Buffer.from([0, 0, 0, 0, 0, 0])]); // var values = hrpExpand(hrp).concat(data).concat([0, 0, 0, 0, 0, 0]);\n\n  var mod = polymod(values) ^ 1;\n  var ret = [];\n\n  for (var p = 0; p < 6; ++p) {\n    ret.push(mod >> 5 * (5 - p) & 31);\n  }\n\n  return Buffer.from(ret);\n}\n\nexports.bech32Encode = function (hrp, data) {\n  var combined = Buffer.concat([data, createChecksum(hrp, data)]);\n  var ret = hrp + '1'; // tslint:disable-next-line\n\n  for (var p = 0; p < combined.length; ++p) {\n    ret += CHARSET.charAt(combined[p]);\n  }\n\n  return ret;\n};\n\nexports.bech32Decode = function (bechString) {\n  var p;\n  var hasLower = false;\n  var hasUpper = false;\n\n  for (p = 0; p < bechString.length; ++p) {\n    if (bechString.charCodeAt(p) < 33 || bechString.charCodeAt(p) > 126) {\n      return null;\n    }\n\n    if (bechString.charCodeAt(p) >= 97 && bechString.charCodeAt(p) <= 122) {\n      hasLower = true;\n    }\n\n    if (bechString.charCodeAt(p) >= 65 && bechString.charCodeAt(p) <= 90) {\n      hasUpper = true;\n    }\n  }\n\n  if (hasLower && hasUpper) {\n    return null;\n  }\n\n  bechString = bechString.toLowerCase();\n  var pos = bechString.lastIndexOf('1');\n\n  if (pos < 1 || pos + 7 > bechString.length || bechString.length > 90) {\n    return null;\n  }\n\n  var hrp = bechString.substring(0, pos);\n  var data = [];\n\n  for (p = pos + 1; p < bechString.length; ++p) {\n    var d = CHARSET.indexOf(bechString.charAt(p));\n\n    if (d === -1) {\n      return null;\n    }\n\n    data.push(d);\n  }\n\n  if (!verifyChecksum(hrp, Buffer.from(data))) {\n    return null;\n  }\n\n  return {\n    hrp: hrp,\n    data: Buffer.from(data.slice(0, data.length - 6))\n  };\n}; // HRP is the human-readable part of Harmony bech32 addresses\n\n\nexports.HRP = 'one';\nexports.tHRP = 'tone';\n/**\n * convertBits\n *\n * groups buffers of a certain width to buffers of the desired width.\n *\n * For example, converts byte buffers to buffers of maximum 5 bit numbers,\n * padding those numbers as necessary. Necessary for encoding Ethereum-style\n * addresses as bech32 ones.\n *\n * @param {Buffer} data\n * @param {number} fromWidth\n * @param {number} toWidth\n * @param {boolean} pad\n * @returns {Buffer|null}\n */\n\nexports.convertBits = function (data, fromWidth, toWidth, pad) {\n  if (pad === void 0) {\n    pad = true;\n  }\n\n  var acc = 0;\n  var bits = 0;\n  var ret = [];\n  var maxv = (1 << toWidth) - 1; // tslint:disable-next-line\n\n  for (var p = 0; p < data.length; ++p) {\n    var value = data[p];\n\n    if (value < 0 || value >> fromWidth !== 0) {\n      return null;\n    }\n\n    acc = acc << fromWidth | value;\n    bits += fromWidth;\n\n    while (bits >= toWidth) {\n      bits -= toWidth;\n      ret.push(acc >> bits & maxv);\n    }\n  }\n\n  if (pad) {\n    if (bits > 0) {\n      ret.push(acc << toWidth - bits & maxv);\n    }\n  } else if (bits >= fromWidth || acc << toWidth - bits & maxv) {\n    return null;\n  }\n\n  return Buffer.from(ret);\n};\n/**\n * toBech32Address\n *\n * bech32Encodes a canonical 20-byte Ethereum-style address as a bech32 Harmony\n * address.\n *\n * The expected format is one1<address><checksum> where address and checksum\n * are the result of bech32 encoding a Buffer containing the address bytes.\n *\n * @param {string} 20 byte canonical address\n * @returns {string} 38 char bech32 bech32Encoded Harmony address\n */\n\n\nexports.toBech32 = function (address, useHRP) {\n  if (useHRP === void 0) {\n    useHRP = exports.HRP;\n  }\n\n  if (!utils_1.isAddress(address)) {\n    throw new Error('Invalid address format.');\n  }\n\n  var addrBz = exports.convertBits(Buffer.from(address.replace('0x', ''), 'hex'), 8, 5);\n\n  if (addrBz === null) {\n    throw new Error('Could not convert byte Buffer to 5-bit Buffer');\n  }\n\n  return exports.bech32Encode(useHRP, addrBz);\n};\n/**\n * fromBech32Address\n *\n * @param {string} address - a valid Harmony bech32 address\n * @returns {string} a canonical 20-byte Ethereum-style address\n */\n\n\nexports.fromBech32 = function (address, useHRP) {\n  if (useHRP === void 0) {\n    useHRP = exports.HRP;\n  }\n\n  var res = exports.bech32Decode(address);\n\n  if (res === null) {\n    throw new Error('Invalid bech32 address');\n  }\n\n  var hrp = res.hrp,\n      data = res.data;\n\n  if (hrp !== useHRP) {\n    throw new Error(\"Expected hrp to be \" + useHRP + \" but got \" + hrp);\n  }\n\n  var buf = exports.convertBits(data, 5, 8, false);\n\n  if (buf === null) {\n    throw new Error('Could not convert buffer to bytes');\n  }\n\n  return keyTool_1.toChecksumAddress('0x' + buf.toString('hex'));\n};","map":{"version":3,"sources":["../src/bech32.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n * @packageDocumentation\n * @module harmony-crypto\n * @hidden\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.fromBech32 = exports.toBech32 = exports.convertBits = exports.tHRP = exports.HRP = exports.bech32Decode = exports.bech32Encode = void 0;\nvar utils_1 = require(\"@harmony-js/utils\");\nvar keyTool_1 = require(\"./keyTool\");\n// This code is taken from https://github.com/sipa/bech32/tree/bdc264f84014c234e908d72026b7b780122be11f/ref/javascript\n// Copyright (c) 2017 Pieter Wuille\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nvar CHARSET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';\nvar GENERATOR = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\nvar polymod = function (values) {\n    var chk = 1;\n    // tslint:disable-next-line\n    for (var p = 0; p < values.length; ++p) {\n        var top_1 = chk >> 25;\n        chk = ((chk & 0x1ffffff) << 5) ^ values[p];\n        for (var i = 0; i < 5; ++i) {\n            if ((top_1 >> i) & 1) {\n                chk ^= GENERATOR[i];\n            }\n        }\n    }\n    return chk;\n};\nvar hrpExpand = function (hrp) {\n    var ret = [];\n    var p;\n    for (p = 0; p < hrp.length; ++p) {\n        ret.push(hrp.charCodeAt(p) >> 5);\n    }\n    ret.push(0);\n    for (p = 0; p < hrp.length; ++p) {\n        ret.push(hrp.charCodeAt(p) & 31);\n    }\n    return Buffer.from(ret);\n};\nfunction verifyChecksum(hrp, data) {\n    return polymod(Buffer.concat([hrpExpand(hrp), data])) === 1;\n}\nfunction createChecksum(hrp, data) {\n    var values = Buffer.concat([\n        Buffer.from(hrpExpand(hrp)),\n        data,\n        Buffer.from([0, 0, 0, 0, 0, 0]),\n    ]);\n    // var values = hrpExpand(hrp).concat(data).concat([0, 0, 0, 0, 0, 0]);\n    var mod = polymod(values) ^ 1;\n    var ret = [];\n    for (var p = 0; p < 6; ++p) {\n        ret.push((mod >> (5 * (5 - p))) & 31);\n    }\n    return Buffer.from(ret);\n}\nexports.bech32Encode = function (hrp, data) {\n    var combined = Buffer.concat([data, createChecksum(hrp, data)]);\n    var ret = hrp + '1';\n    // tslint:disable-next-line\n    for (var p = 0; p < combined.length; ++p) {\n        ret += CHARSET.charAt(combined[p]);\n    }\n    return ret;\n};\nexports.bech32Decode = function (bechString) {\n    var p;\n    var hasLower = false;\n    var hasUpper = false;\n    for (p = 0; p < bechString.length; ++p) {\n        if (bechString.charCodeAt(p) < 33 || bechString.charCodeAt(p) > 126) {\n            return null;\n        }\n        if (bechString.charCodeAt(p) >= 97 && bechString.charCodeAt(p) <= 122) {\n            hasLower = true;\n        }\n        if (bechString.charCodeAt(p) >= 65 && bechString.charCodeAt(p) <= 90) {\n            hasUpper = true;\n        }\n    }\n    if (hasLower && hasUpper) {\n        return null;\n    }\n    bechString = bechString.toLowerCase();\n    var pos = bechString.lastIndexOf('1');\n    if (pos < 1 || pos + 7 > bechString.length || bechString.length > 90) {\n        return null;\n    }\n    var hrp = bechString.substring(0, pos);\n    var data = [];\n    for (p = pos + 1; p < bechString.length; ++p) {\n        var d = CHARSET.indexOf(bechString.charAt(p));\n        if (d === -1) {\n            return null;\n        }\n        data.push(d);\n    }\n    if (!verifyChecksum(hrp, Buffer.from(data))) {\n        return null;\n    }\n    return { hrp: hrp, data: Buffer.from(data.slice(0, data.length - 6)) };\n};\n// HRP is the human-readable part of Harmony bech32 addresses\nexports.HRP = 'one';\nexports.tHRP = 'tone';\n/**\n * convertBits\n *\n * groups buffers of a certain width to buffers of the desired width.\n *\n * For example, converts byte buffers to buffers of maximum 5 bit numbers,\n * padding those numbers as necessary. Necessary for encoding Ethereum-style\n * addresses as bech32 ones.\n *\n * @param {Buffer} data\n * @param {number} fromWidth\n * @param {number} toWidth\n * @param {boolean} pad\n * @returns {Buffer|null}\n */\nexports.convertBits = function (data, fromWidth, toWidth, pad) {\n    if (pad === void 0) { pad = true; }\n    var acc = 0;\n    var bits = 0;\n    var ret = [];\n    var maxv = (1 << toWidth) - 1;\n    // tslint:disable-next-line\n    for (var p = 0; p < data.length; ++p) {\n        var value = data[p];\n        if (value < 0 || value >> fromWidth !== 0) {\n            return null;\n        }\n        acc = (acc << fromWidth) | value;\n        bits += fromWidth;\n        while (bits >= toWidth) {\n            bits -= toWidth;\n            ret.push((acc >> bits) & maxv);\n        }\n    }\n    if (pad) {\n        if (bits > 0) {\n            ret.push((acc << (toWidth - bits)) & maxv);\n        }\n    }\n    else if (bits >= fromWidth || (acc << (toWidth - bits)) & maxv) {\n        return null;\n    }\n    return Buffer.from(ret);\n};\n/**\n * toBech32Address\n *\n * bech32Encodes a canonical 20-byte Ethereum-style address as a bech32 Harmony\n * address.\n *\n * The expected format is one1<address><checksum> where address and checksum\n * are the result of bech32 encoding a Buffer containing the address bytes.\n *\n * @param {string} 20 byte canonical address\n * @returns {string} 38 char bech32 bech32Encoded Harmony address\n */\nexports.toBech32 = function (address, useHRP) {\n    if (useHRP === void 0) { useHRP = exports.HRP; }\n    if (!utils_1.isAddress(address)) {\n        throw new Error('Invalid address format.');\n    }\n    var addrBz = exports.convertBits(Buffer.from(address.replace('0x', ''), 'hex'), 8, 5);\n    if (addrBz === null) {\n        throw new Error('Could not convert byte Buffer to 5-bit Buffer');\n    }\n    return exports.bech32Encode(useHRP, addrBz);\n};\n/**\n * fromBech32Address\n *\n * @param {string} address - a valid Harmony bech32 address\n * @returns {string} a canonical 20-byte Ethereum-style address\n */\nexports.fromBech32 = function (address, useHRP) {\n    if (useHRP === void 0) { useHRP = exports.HRP; }\n    var res = exports.bech32Decode(address);\n    if (res === null) {\n        throw new Error('Invalid bech32 address');\n    }\n    var hrp = res.hrp, data = res.data;\n    if (hrp !== useHRP) {\n        throw new Error(\"Expected hrp to be \" + useHRP + \" but got \" + hrp);\n    }\n    var buf = exports.convertBits(data, 5, 8, false);\n    if (buf === null) {\n        throw new Error('Could not convert buffer to bytes');\n    }\n    return keyTool_1.toChecksumAddress('0x' + buf.toString('hex'));\n};\n//# sourceMappingURL=bech32.js.map"]},"metadata":{},"sourceType":"script"}