{"ast":null,"code":"\"use strict\";\n/**\n * @packageDocumentation\n * @module harmony-crypto\n * @hidden\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isHex = exports.hexToIntArray = exports.hexToByteArray = exports.joinSignature = exports.splitSignature = exports.isSignature = exports.bytesPadRight = exports.bytesPadLeft = exports.hexZeroPad = exports.hexStripZeros = exports.hexDataSlice = exports.hexDataLength = exports.hexlify = exports.isHexString = exports.padZeros = exports.stripZeros = exports.concat = exports.arrayify = exports.isArrayish = exports.isHexable = void 0;\n\nvar tslib_1 = require(\"tslib\"); // This file is ported from ether.js/src.ts/utils/bytes.ts\n// and done some fixes\n\n\nvar errors = tslib_1.__importStar(require(\"./errors\")); ///////////////////////////////\n\n\nfunction isHexable(value) {\n  return !!value.toHexString;\n}\n\nexports.isHexable = isHexable;\n\nfunction addSlice(array) {\n  if (typeof array === 'object' && typeof array.slice === 'function') {\n    return array;\n  } // tslint:disable-next-line: only-arrow-functions\n\n\n  array.slice = function () {\n    var args = Array.prototype.slice.call(arguments);\n    return addSlice(new Uint8Array(Array.prototype.slice.apply(array, [args[0], args[1]])));\n  };\n\n  return array;\n}\n\nfunction isArrayish(value) {\n  if (!value || // tslint:disable-next-line: radix\n  parseInt(String(value.length)) !== value.length || typeof value === 'string') {\n    return false;\n  } // tslint:disable-next-line: prefer-for-of\n\n\n  for (var i = 0; i < value.length; i++) {\n    var v = value[i]; // tslint:disable-next-line: radix\n\n    if (v < 0 || v >= 256 || parseInt(String(v)) !== v) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexports.isArrayish = isArrayish;\n\nfunction arrayify(value) {\n  if (value == null) {\n    errors.throwError('cannot convert null value to array', errors.INVALID_ARGUMENT, {\n      arg: 'value',\n      value: value\n    });\n  }\n\n  if (isHexable(value)) {\n    value = value.toHexString();\n  }\n\n  if (typeof value === 'string') {\n    var match = value.match(/^(0x)?[0-9a-fA-F]*$/);\n\n    if (!match) {\n      errors.throwError('invalid hexidecimal string', errors.INVALID_ARGUMENT, {\n        arg: 'value',\n        value: value\n      });\n    }\n\n    if (match !== null && match[1] !== '0x') {\n      errors.throwError('hex string must have 0x prefix', errors.INVALID_ARGUMENT, {\n        arg: 'value',\n        value: value\n      });\n    }\n\n    value = value.substring(2);\n\n    if (value.length % 2) {\n      value = '0' + value;\n    }\n\n    var result = [];\n\n    for (var i = 0; i < value.length; i += 2) {\n      result.push(parseInt(value.substr(i, 2), 16));\n    }\n\n    return addSlice(new Uint8Array(result));\n  }\n\n  if (isArrayish(value)) {\n    return addSlice(new Uint8Array(value));\n  }\n\n  errors.throwError('invalid arrayify value', null, {\n    arg: 'value',\n    value: value,\n    type: typeof value\n  });\n  return null;\n}\n\nexports.arrayify = arrayify;\n\nfunction concat(objects) {\n  if (objects === null) {\n    throw new Error(\"concat objects is null\");\n  }\n\n  var arrays = [];\n  var length = 0; // tslint:disable-next-line: prefer-for-of\n\n  for (var i = 0; i < objects.length; i++) {\n    var object = arrayify(objects[i]);\n\n    if (object == null) {\n      throw new Error('arrayify failed');\n    }\n\n    arrays.push(object);\n    length += object.length;\n  }\n\n  var result = new Uint8Array(length);\n  var offset = 0; // tslint:disable-next-line: prefer-for-of\n\n  for (var i = 0; i < arrays.length; i++) {\n    result.set(arrays[i], offset);\n    offset += arrays[i].length;\n  }\n\n  return addSlice(result);\n}\n\nexports.concat = concat;\n\nfunction stripZeros(value) {\n  var result = arrayify(value);\n\n  if (result === null) {\n    throw new Error('arrayify failed');\n  }\n\n  if (result.length === 0) {\n    return result;\n  } // Find the first non-zero entry\n\n\n  var start = 0;\n\n  while (result[start] === 0) {\n    start++;\n  } // If we started with zeros, strip them\n\n\n  if (start) {\n    result = result.slice(start);\n  }\n\n  return result;\n}\n\nexports.stripZeros = stripZeros;\n\nfunction padZeros(value, length) {\n  var arrayifyValue = arrayify(value);\n\n  if (arrayifyValue === null) {\n    throw new Error('arrayify failed');\n  }\n\n  if (length < arrayifyValue.length) {\n    throw new Error('cannot pad');\n  }\n\n  var result = new Uint8Array(length);\n  result.set(arrayifyValue, length - arrayifyValue.length);\n  return addSlice(result);\n}\n\nexports.padZeros = padZeros;\n\nfunction isHexString(value, length) {\n  if (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n    return false;\n  }\n\n  if (length && value.length !== 2 + 2 * length) {\n    return false;\n  }\n\n  return true;\n}\n\nexports.isHexString = isHexString;\nvar HexCharacters = '0123456789abcdef';\n\nfunction hexlify(value) {\n  if (isHexable(value)) {\n    return value.toHexString();\n  }\n\n  if (typeof value === 'number') {\n    if (value < 0) {\n      errors.throwError('cannot hexlify negative value', errors.INVALID_ARGUMENT, {\n        arg: 'value',\n        value: value\n      });\n    } // @TODO: Roll this into the above error as a numeric fault (overflow); next version, not backward compatible\n    // We can about (value == MAX_INT) to as well, since that may indicate we underflowed already\n\n\n    if (value >= 9007199254740991) {\n      errors.throwError('out-of-range', errors.NUMERIC_FAULT, {\n        operartion: 'hexlify',\n        fault: 'out-of-safe-range'\n      });\n    }\n\n    var hex = '';\n\n    while (value) {\n      hex = HexCharacters[value & 0x0f] + hex;\n      value = Math.floor(value / 16);\n    }\n\n    if (hex.length) {\n      if (hex.length % 2) {\n        hex = '0' + hex;\n      }\n\n      return '0x' + hex;\n    }\n\n    return '0x00';\n  }\n\n  if (typeof value === 'string') {\n    var match = value.match(/^(0x)?[0-9a-fA-F]*$/);\n\n    if (!match) {\n      errors.throwError('invalid hexidecimal string', errors.INVALID_ARGUMENT, {\n        arg: 'value',\n        value: value\n      });\n    }\n\n    if (match !== null && match[1] !== '0x') {\n      errors.throwError('hex string must have 0x prefix', errors.INVALID_ARGUMENT, {\n        arg: 'value',\n        value: value\n      });\n    }\n\n    if (value.length % 2) {\n      value = '0x0' + value.substring(2);\n    }\n\n    return value;\n  }\n\n  if (isArrayish(value)) {\n    var result = []; // tslint:disable-next-line: prefer-for-of\n\n    for (var i = 0; i < value.length; i++) {\n      var v = value[i];\n      result.push(HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f]);\n    }\n\n    return '0x' + result.join('');\n  }\n\n  errors.throwError('invalid hexlify value', null, {\n    arg: 'value',\n    value: value\n  });\n  return 'never';\n}\n\nexports.hexlify = hexlify;\n\nfunction hexDataLength(data) {\n  if (!isHexString(data) || data.length % 2 !== 0) {\n    return null;\n  }\n\n  return (data.length - 2) / 2;\n}\n\nexports.hexDataLength = hexDataLength;\n\nfunction hexDataSlice(data, offset, endOffset) {\n  if (!isHexString(data)) {\n    errors.throwError('invalid hex data', errors.INVALID_ARGUMENT, {\n      arg: 'value',\n      value: data\n    });\n  }\n\n  if (data.length % 2 !== 0) {\n    errors.throwError('hex data length must be even', errors.INVALID_ARGUMENT, {\n      arg: 'value',\n      value: data\n    });\n  }\n\n  offset = 2 + 2 * offset;\n\n  if (endOffset != null) {\n    return '0x' + data.substring(offset, 2 + 2 * endOffset);\n  }\n\n  return '0x' + data.substring(offset);\n}\n\nexports.hexDataSlice = hexDataSlice;\n\nfunction hexStripZeros(value) {\n  if (!isHexString(value)) {\n    errors.throwError('invalid hex string', errors.INVALID_ARGUMENT, {\n      arg: 'value',\n      value: value\n    });\n  }\n\n  while (value.length > 3 && value.substring(0, 3) === '0x0') {\n    value = '0x' + value.substring(3);\n  }\n\n  return value;\n}\n\nexports.hexStripZeros = hexStripZeros;\n\nfunction hexZeroPad(value, length) {\n  if (!isHexString(value)) {\n    errors.throwError('invalid hex string', errors.INVALID_ARGUMENT, {\n      arg: 'value',\n      value: value\n    });\n  }\n\n  while (value.length < 2 * length + 2) {\n    value = '0x0' + value.substring(2);\n  }\n\n  return value;\n}\n\nexports.hexZeroPad = hexZeroPad;\n\nfunction bytesPadLeft(value, byteLength) {\n  if (!isHexString(value)) {\n    errors.throwError('invalid hex string', errors.INVALID_ARGUMENT, {\n      arg: 'value',\n      value: value\n    });\n  }\n\n  var striped = value.substring(2);\n\n  if (striped.length > byteLength * 2) {\n    throw new Error(\"hex string length = \" + striped.length + \" beyond byteLength=\" + byteLength);\n  }\n\n  var padLength = byteLength * 2 - striped.length;\n  var returnValue = '0x' + '0'.repeat(padLength) + striped;\n  return returnValue;\n}\n\nexports.bytesPadLeft = bytesPadLeft;\n\nfunction bytesPadRight(value, byteLength) {\n  if (!isHexString(value)) {\n    errors.throwError('invalid hex string', errors.INVALID_ARGUMENT, {\n      arg: 'value',\n      value: value\n    });\n  }\n\n  var striped = value.substring(2);\n\n  if (striped.length > byteLength * 2) {\n    throw new Error(\"hex string length = \" + striped.length + \" beyond byteLength=\" + byteLength);\n  }\n\n  var padLength = byteLength * 2 - striped.length;\n  var returnValue = '0x' + striped + '0'.repeat(padLength);\n  return returnValue;\n}\n\nexports.bytesPadRight = bytesPadRight;\n\nfunction isSignature(value) {\n  return value && value.r != null && value.s != null;\n}\n\nexports.isSignature = isSignature;\n\nfunction splitSignature(signature) {\n  if (signature !== undefined) {\n    var v = 0;\n    var r = '0x';\n    var s = '0x';\n\n    if (isSignature(signature)) {\n      if (signature.v == null && signature.recoveryParam == null) {\n        errors.throwError('at least on of recoveryParam or v must be specified', errors.INVALID_ARGUMENT, {\n          argument: 'signature',\n          value: signature\n        });\n      }\n\n      r = hexZeroPad(signature.r, 32);\n      s = hexZeroPad(signature.s, 32);\n      v = signature.v || 0;\n\n      if (typeof v === 'string') {\n        v = parseInt(v, 16);\n      }\n\n      var recoveryParam = signature.recoveryParam || 0;\n\n      if (recoveryParam == null && signature.v != null) {\n        recoveryParam = 1 - v % 2;\n      }\n\n      v = 27 + recoveryParam;\n    } else {\n      var bytes = arrayify(signature) || new Uint8Array();\n\n      if (bytes.length !== 65) {\n        throw new Error('invalid signature');\n      }\n\n      r = hexlify(bytes.slice(0, 32));\n      s = hexlify(bytes.slice(32, 64));\n      v = bytes[64];\n\n      if (v !== 27 && v !== 28) {\n        v = 27 + v % 2;\n      }\n    }\n\n    return {\n      r: r,\n      s: s,\n      recoveryParam: v - 27,\n      v: v\n    };\n  } else {\n    throw new Error('signature is not found');\n  }\n}\n\nexports.splitSignature = splitSignature;\n\nfunction joinSignature(signature) {\n  signature = splitSignature(signature);\n  return hexlify(concat([signature.r, signature.s, signature.recoveryParam ? '0x1c' : '0x1b']));\n}\n\nexports.joinSignature = joinSignature;\n/**\n * hexToByteArray\n *\n * Convers a hex string to a Uint8Array\n *\n * @param {string} hex\n * @returns {Uint8Array}\n */\n\nexports.hexToByteArray = function (hex) {\n  var res = new Uint8Array(hex.length / 2);\n\n  for (var i = 0; i < hex.length; i += 2) {\n    res[i / 2] = parseInt(hex.substring(i, i + 2), 16);\n  }\n\n  return res;\n};\n/**\n * hexToIntArray\n *\n * @param {string} hex\n * @returns {number[]}\n */\n\n\nexports.hexToIntArray = function (hex) {\n  if (!hex || !exports.isHex(hex)) {\n    return [];\n  }\n\n  var res = [];\n\n  for (var i = 0; i < hex.length; i++) {\n    var c = hex.charCodeAt(i);\n    var hi = c >> 8;\n    var lo = c & 0xff;\n    hi ? res.push(hi, lo) : res.push(lo);\n  }\n\n  return res;\n};\n/**\n * isHex\n *\n * @param {string} str - string to be tested\n * @returns {boolean}\n */\n\n\nexports.isHex = function (str) {\n  var plain = str.replace('0x', '');\n  return /[0-9a-f]*$/i.test(plain);\n};","map":{"version":3,"sources":["../src/bytes.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n * @packageDocumentation\n * @module harmony-crypto\n * @hidden\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isHex = exports.hexToIntArray = exports.hexToByteArray = exports.joinSignature = exports.splitSignature = exports.isSignature = exports.bytesPadRight = exports.bytesPadLeft = exports.hexZeroPad = exports.hexStripZeros = exports.hexDataSlice = exports.hexDataLength = exports.hexlify = exports.isHexString = exports.padZeros = exports.stripZeros = exports.concat = exports.arrayify = exports.isArrayish = exports.isHexable = void 0;\nvar tslib_1 = require(\"tslib\");\n// This file is ported from ether.js/src.ts/utils/bytes.ts\n// and done some fixes\nvar errors = tslib_1.__importStar(require(\"./errors\"));\n///////////////////////////////\nfunction isHexable(value) {\n    return !!value.toHexString;\n}\nexports.isHexable = isHexable;\nfunction addSlice(array) {\n    if (typeof array === 'object' && typeof array.slice === 'function') {\n        return array;\n    }\n    // tslint:disable-next-line: only-arrow-functions\n    array.slice = function () {\n        var args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, [args[0], args[1]])));\n    };\n    return array;\n}\nfunction isArrayish(value) {\n    if (!value ||\n        // tslint:disable-next-line: radix\n        parseInt(String(value.length)) !== value.length ||\n        typeof value === 'string') {\n        return false;\n    }\n    // tslint:disable-next-line: prefer-for-of\n    for (var i = 0; i < value.length; i++) {\n        var v = value[i];\n        // tslint:disable-next-line: radix\n        if (v < 0 || v >= 256 || parseInt(String(v)) !== v) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.isArrayish = isArrayish;\nfunction arrayify(value) {\n    if (value == null) {\n        errors.throwError('cannot convert null value to array', errors.INVALID_ARGUMENT, {\n            arg: 'value',\n            value: value,\n        });\n    }\n    if (isHexable(value)) {\n        value = value.toHexString();\n    }\n    if (typeof value === 'string') {\n        var match = value.match(/^(0x)?[0-9a-fA-F]*$/);\n        if (!match) {\n            errors.throwError('invalid hexidecimal string', errors.INVALID_ARGUMENT, {\n                arg: 'value',\n                value: value,\n            });\n        }\n        if (match !== null && match[1] !== '0x') {\n            errors.throwError('hex string must have 0x prefix', errors.INVALID_ARGUMENT, {\n                arg: 'value',\n                value: value,\n            });\n        }\n        value = value.substring(2);\n        if (value.length % 2) {\n            value = '0' + value;\n        }\n        var result = [];\n        for (var i = 0; i < value.length; i += 2) {\n            result.push(parseInt(value.substr(i, 2), 16));\n        }\n        return addSlice(new Uint8Array(result));\n    }\n    if (isArrayish(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n    errors.throwError('invalid arrayify value', null, {\n        arg: 'value',\n        value: value,\n        type: typeof value,\n    });\n    return null;\n}\nexports.arrayify = arrayify;\nfunction concat(objects) {\n    if (objects === null) {\n        throw new Error(\"concat objects is null\");\n    }\n    var arrays = [];\n    var length = 0;\n    // tslint:disable-next-line: prefer-for-of\n    for (var i = 0; i < objects.length; i++) {\n        var object = arrayify(objects[i]);\n        if (object == null) {\n            throw new Error('arrayify failed');\n        }\n        arrays.push(object);\n        length += object.length;\n    }\n    var result = new Uint8Array(length);\n    var offset = 0;\n    // tslint:disable-next-line: prefer-for-of\n    for (var i = 0; i < arrays.length; i++) {\n        result.set(arrays[i], offset);\n        offset += arrays[i].length;\n    }\n    return addSlice(result);\n}\nexports.concat = concat;\nfunction stripZeros(value) {\n    var result = arrayify(value);\n    if (result === null) {\n        throw new Error('arrayify failed');\n    }\n    if (result.length === 0) {\n        return result;\n    }\n    // Find the first non-zero entry\n    var start = 0;\n    while (result[start] === 0) {\n        start++;\n    }\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n    return result;\n}\nexports.stripZeros = stripZeros;\nfunction padZeros(value, length) {\n    var arrayifyValue = arrayify(value);\n    if (arrayifyValue === null) {\n        throw new Error('arrayify failed');\n    }\n    if (length < arrayifyValue.length) {\n        throw new Error('cannot pad');\n    }\n    var result = new Uint8Array(length);\n    result.set(arrayifyValue, length - arrayifyValue.length);\n    return addSlice(result);\n}\nexports.padZeros = padZeros;\nfunction isHexString(value, length) {\n    if (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false;\n    }\n    if (length && value.length !== 2 + 2 * length) {\n        return false;\n    }\n    return true;\n}\nexports.isHexString = isHexString;\nvar HexCharacters = '0123456789abcdef';\nfunction hexlify(value) {\n    if (isHexable(value)) {\n        return value.toHexString();\n    }\n    if (typeof value === 'number') {\n        if (value < 0) {\n            errors.throwError('cannot hexlify negative value', errors.INVALID_ARGUMENT, {\n                arg: 'value',\n                value: value,\n            });\n        }\n        // @TODO: Roll this into the above error as a numeric fault (overflow); next version, not backward compatible\n        // We can about (value == MAX_INT) to as well, since that may indicate we underflowed already\n        if (value >= 9007199254740991) {\n            errors.throwError('out-of-range', errors.NUMERIC_FAULT, {\n                operartion: 'hexlify',\n                fault: 'out-of-safe-range',\n            });\n        }\n        var hex = '';\n        while (value) {\n            hex = HexCharacters[value & 0x0f] + hex;\n            value = Math.floor(value / 16);\n        }\n        if (hex.length) {\n            if (hex.length % 2) {\n                hex = '0' + hex;\n            }\n            return '0x' + hex;\n        }\n        return '0x00';\n    }\n    if (typeof value === 'string') {\n        var match = value.match(/^(0x)?[0-9a-fA-F]*$/);\n        if (!match) {\n            errors.throwError('invalid hexidecimal string', errors.INVALID_ARGUMENT, {\n                arg: 'value',\n                value: value,\n            });\n        }\n        if (match !== null && match[1] !== '0x') {\n            errors.throwError('hex string must have 0x prefix', errors.INVALID_ARGUMENT, {\n                arg: 'value',\n                value: value,\n            });\n        }\n        if (value.length % 2) {\n            value = '0x0' + value.substring(2);\n        }\n        return value;\n    }\n    if (isArrayish(value)) {\n        var result = [];\n        // tslint:disable-next-line: prefer-for-of\n        for (var i = 0; i < value.length; i++) {\n            var v = value[i];\n            result.push(HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f]);\n        }\n        return '0x' + result.join('');\n    }\n    errors.throwError('invalid hexlify value', null, {\n        arg: 'value',\n        value: value,\n    });\n    return 'never';\n}\nexports.hexlify = hexlify;\nfunction hexDataLength(data) {\n    if (!isHexString(data) || data.length % 2 !== 0) {\n        return null;\n    }\n    return (data.length - 2) / 2;\n}\nexports.hexDataLength = hexDataLength;\nfunction hexDataSlice(data, offset, endOffset) {\n    if (!isHexString(data)) {\n        errors.throwError('invalid hex data', errors.INVALID_ARGUMENT, {\n            arg: 'value',\n            value: data,\n        });\n    }\n    if (data.length % 2 !== 0) {\n        errors.throwError('hex data length must be even', errors.INVALID_ARGUMENT, {\n            arg: 'value',\n            value: data,\n        });\n    }\n    offset = 2 + 2 * offset;\n    if (endOffset != null) {\n        return '0x' + data.substring(offset, 2 + 2 * endOffset);\n    }\n    return '0x' + data.substring(offset);\n}\nexports.hexDataSlice = hexDataSlice;\nfunction hexStripZeros(value) {\n    if (!isHexString(value)) {\n        errors.throwError('invalid hex string', errors.INVALID_ARGUMENT, {\n            arg: 'value',\n            value: value,\n        });\n    }\n    while (value.length > 3 && value.substring(0, 3) === '0x0') {\n        value = '0x' + value.substring(3);\n    }\n    return value;\n}\nexports.hexStripZeros = hexStripZeros;\nfunction hexZeroPad(value, length) {\n    if (!isHexString(value)) {\n        errors.throwError('invalid hex string', errors.INVALID_ARGUMENT, {\n            arg: 'value',\n            value: value,\n        });\n    }\n    while (value.length < 2 * length + 2) {\n        value = '0x0' + value.substring(2);\n    }\n    return value;\n}\nexports.hexZeroPad = hexZeroPad;\nfunction bytesPadLeft(value, byteLength) {\n    if (!isHexString(value)) {\n        errors.throwError('invalid hex string', errors.INVALID_ARGUMENT, {\n            arg: 'value',\n            value: value,\n        });\n    }\n    var striped = value.substring(2);\n    if (striped.length > byteLength * 2) {\n        throw new Error(\"hex string length = \" + striped.length + \" beyond byteLength=\" + byteLength);\n    }\n    var padLength = byteLength * 2 - striped.length;\n    var returnValue = '0x' + '0'.repeat(padLength) + striped;\n    return returnValue;\n}\nexports.bytesPadLeft = bytesPadLeft;\nfunction bytesPadRight(value, byteLength) {\n    if (!isHexString(value)) {\n        errors.throwError('invalid hex string', errors.INVALID_ARGUMENT, {\n            arg: 'value',\n            value: value,\n        });\n    }\n    var striped = value.substring(2);\n    if (striped.length > byteLength * 2) {\n        throw new Error(\"hex string length = \" + striped.length + \" beyond byteLength=\" + byteLength);\n    }\n    var padLength = byteLength * 2 - striped.length;\n    var returnValue = '0x' + striped + '0'.repeat(padLength);\n    return returnValue;\n}\nexports.bytesPadRight = bytesPadRight;\nfunction isSignature(value) {\n    return value && value.r != null && value.s != null;\n}\nexports.isSignature = isSignature;\nfunction splitSignature(signature) {\n    if (signature !== undefined) {\n        var v = 0;\n        var r = '0x';\n        var s = '0x';\n        if (isSignature(signature)) {\n            if (signature.v == null && signature.recoveryParam == null) {\n                errors.throwError('at least on of recoveryParam or v must be specified', errors.INVALID_ARGUMENT, { argument: 'signature', value: signature });\n            }\n            r = hexZeroPad(signature.r, 32);\n            s = hexZeroPad(signature.s, 32);\n            v = signature.v || 0;\n            if (typeof v === 'string') {\n                v = parseInt(v, 16);\n            }\n            var recoveryParam = signature.recoveryParam || 0;\n            if (recoveryParam == null && signature.v != null) {\n                recoveryParam = 1 - (v % 2);\n            }\n            v = 27 + recoveryParam;\n        }\n        else {\n            var bytes = arrayify(signature) || new Uint8Array();\n            if (bytes.length !== 65) {\n                throw new Error('invalid signature');\n            }\n            r = hexlify(bytes.slice(0, 32));\n            s = hexlify(bytes.slice(32, 64));\n            v = bytes[64];\n            if (v !== 27 && v !== 28) {\n                v = 27 + (v % 2);\n            }\n        }\n        return {\n            r: r,\n            s: s,\n            recoveryParam: v - 27,\n            v: v,\n        };\n    }\n    else {\n        throw new Error('signature is not found');\n    }\n}\nexports.splitSignature = splitSignature;\nfunction joinSignature(signature) {\n    signature = splitSignature(signature);\n    return hexlify(concat([signature.r, signature.s, signature.recoveryParam ? '0x1c' : '0x1b']));\n}\nexports.joinSignature = joinSignature;\n/**\n * hexToByteArray\n *\n * Convers a hex string to a Uint8Array\n *\n * @param {string} hex\n * @returns {Uint8Array}\n */\nexports.hexToByteArray = function (hex) {\n    var res = new Uint8Array(hex.length / 2);\n    for (var i = 0; i < hex.length; i += 2) {\n        res[i / 2] = parseInt(hex.substring(i, i + 2), 16);\n    }\n    return res;\n};\n/**\n * hexToIntArray\n *\n * @param {string} hex\n * @returns {number[]}\n */\nexports.hexToIntArray = function (hex) {\n    if (!hex || !exports.isHex(hex)) {\n        return [];\n    }\n    var res = [];\n    for (var i = 0; i < hex.length; i++) {\n        var c = hex.charCodeAt(i);\n        var hi = c >> 8;\n        var lo = c & 0xff;\n        hi ? res.push(hi, lo) : res.push(lo);\n    }\n    return res;\n};\n/**\n * isHex\n *\n * @param {string} str - string to be tested\n * @returns {boolean}\n */\nexports.isHex = function (str) {\n    var plain = str.replace('0x', '');\n    return /[0-9a-f]*$/i.test(plain);\n};\n//# sourceMappingURL=bytes.js.map"]},"metadata":{},"sourceType":"script"}