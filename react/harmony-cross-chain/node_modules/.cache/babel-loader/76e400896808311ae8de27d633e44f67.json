{"ast":null,"code":"\"use strict\";\n/**\n # @harmony-js/contract\n\nThis package provides a collection of apis to create, deploy, and interact with smart contracts. In Harmony, smart contracts all fully EVM compatible and the formats and terminologies match 1-to-1 with EVM smart contracts.\n\n## Installation\n\n```\nnpm install @harmony-js/contract\n```\n\n## Usage\n\nDeploying a contract using `contractConstructor`\n```javascript\nconst { ContractFactory } = require('@harmony-js/contract');\nconst { Wallet } = require('@harmony-js/account');\nconst { Messenger, HttpProvider } = require('@harmony-js/network');\nconst { ChainID, ChainType, hexToNumber } = require('@harmony-js/utils');\n\n* const wallet = new Wallet(\n*   new Messenger(\n*     new HttpProvider('https://api.s0.b.hmny.io'),\n*     ChainType.Harmony,\n*     ChainID.HmyTestnet,\n*   ),\n* );\n* const factory = new ContractFactory(wallet);\n\n* const contractJson = require(\"./Counter.json\");\n* const contract = factory.createContract(contractJson.abi);\n\n* const options1 = { gasPrice: '0x3B9ACA00' }; // gas price in hex corresponds to 1 Gwei or 1000000000\n* let options2 = { gasPrice: 1000000000, gasLimit: 21000 }; // setting the default gas limit, but changing later based on estimate gas\n\n* const options3 = { data: contractJson.bytecode }; // contractConstructor needs contract bytecode to deploy\n\n* contract.wallet.addByPrivateKey('1f054c21a0f57ebc402c00e14bd1707ddf45542d4ed9989933dbefc4ea96ca68');\n\n* contract.methods.contractConstructor(options3).estimateGas(options1).then(gas => {\n*   options2 = {...options2, gasLimit: hexToNumber(gas)};\n*   contract.methods.contractConstructor(options3).send(options2).then(response => {\n*     console.log('contract deployed at ' + response.transaction.receipt.contractAddress);\n*   });\n* });\n```\nInstead of `contract.methods.contractConstructor`, `contract.deploy` could be used and it will work.\n\nLoading a contract object using the contract json and contract address for interacting with it\n```javascript\n* const { Harmony } = require(\"@harmony-js/core\");\n* const { ChainID, ChainType } = require(\"@harmony-js/utils\");\n* const hmy = new Harmony(\"https://api.s0.b.hmny.io\", {\n*   chainType: ChainType.Harmony,\n*   chainId: ChainID.HmyTestnet,\n* });\n\nconst contractJson = require(\"./Counter.json\");\nconst contractAddr = \"0x19f64050e6b2d376e52AC426E366c49EEb0724B1\";\n\nconst contract = hmy.contracts.createContract(contractJson.abi, contractAddr);\nconsole.log(contract.methods);\n```\n\nDirectly loading contract using `ContractFactory`\n```javascript\nconst { ContractFactory } = require('@harmony-js/contract');\nconst { Wallet } = require('@harmony-js/account');\nconst { Messenger, HttpProvider } = require('@harmony-js/network');\nconst { ChainID, ChainType, hexToNumber } = require('@harmony-js/utils');\n\n* const wallet = new Wallet(new Messenger(\n*   new HttpProvider('https://api.s0.b.hmny.io'),\n*   ChainType.Harmony,\n*   ChainID.HmyTestnet,\n* ));\nconst factory = new ContractFactory(wallet);\nconst contract = factory.createContract(contractJson.abi, contractAddr);\n```\n\nEstimate gas for contract methods\n```javascript\n* const options1 = { gasPrice: '0x3B9ACA00' }; // gas price in hex corresponds to 1 Gwei or 1000000000\n\n* contract.methods.getCount().estimateGas(options1).then(gas => {\n*   console.log('gas required for getCount is ' + hexToNumber(gas));\n* });\n```\n\nCall contract read-only methods. Harmony uses 1 Gwei gas price and gas limit of 21000 by default. Use the estimate gas api to correctly set the gas limit.\n```javascript\n* const options1 = { gasPrice: '0x3B9ACA00' }; // gas price in hex corresponds to 1 Gwei or 1000000000\n* let options2 = { gasPrice: 1000000000, gasLimit: 21000 }; // setting the default gas limit, but changing later based on estimate gas\n\n* contract.methods.getCount().estimateGas(options1).then(gas => {\n*   options2 = {...options2, gasLimit: hexToNumber(gas)};\n*   contract.methods.getCount().call(options2).then(count => {\n*     console.log('counter value: ' + count);\n*   });\n* });\n```\n\nInvoking contract modification methods using `send` api. Need to add a signing account to the contract wallet, otherwise `send` api will not work.\n```javascript\n* const options1 = { gasPrice: '0x3B9ACA00' }; // gas price in hex corresponds to 1 Gwei or 1000000000\n* let options2 = { gasPrice: 1000000000, gasLimit: 21000 }; // setting the default gas limit, but changing later based on estimate gas\n\n* contract.wallet.addByPrivateKey('1f054c21a0f57ebc402c00e14bd1707ddf45542d4ed9989933dbefc4ea96ca68');\n\n* contract.methods.incrementCounter().estimateGas(options1).then(gas => {\n*   options2 = {...options2, gasLimit: hexToNumber(gas)};\n*   contract.methods.incrementCounter().send(options2).then(response => {\n*     console.log(response.transaction.receipt);\n*   });\n* });\n```\n\nAll the above apis can also be asynchronously executed using `async` and `await`.\n\nSubscribing to the contract events requires web socket based messenger.\n```javascript\n* const { ContractFactory } = require('@harmony-js/contract');\n* const { Wallet } = require('@harmony-js/account');\n* const { Messenger, WSProvider } = require('@harmony-js/network');\n* const { ChainID, ChainType, hexToNumber } = require('@harmony-js/utils');\n* const ws = new WSProvider('wss://ws.s0.b.hmny.io');\n\n* const wallet = new Wallet(\n*   new Messenger(\n*     ws,\n*     ChainType.Harmony,\n*     ChainID.HmyTestnet,\n*   ),\n* );\n* const factory = new ContractFactory(wallet);\n\n* const contractJson = require(\"./Counter.json\");\n* const contractAddr = '0x8ada52172abda19b9838eb00498a40952be6a019';\n\n* const contract = factory.createContract(contractJson.abi, contractAddr);\n\n* contract.events\n*   .IncrementedBy()\n*   .on('data', (event) => {\n*     console.log(event);\n*   })\n*   .on('error', console.error);\n```\n *\n * @packageDocumentation\n * @module harmony-contract\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.defaultAbiCoder = exports.AbiCoder = exports.deepCopy = exports.shallowCopy = exports.isType = exports.parseBytes32String = exports.formatBytes32String = exports.toUtf8String = exports.toUtf8Bytes = exports.UnicodeNormalizationForm = exports.parseSignature = exports.formatSignature = exports.formatParamType = exports.parseParamType = exports.defaultCoerceFunc = void 0;\n\nvar tslib_1 = require(\"tslib\"); // this file is mainly ported from `ethers.js`, but done some fixes\n// 1. added bytesPadRight support\n// 2. ts-lint\n// 3. use BN as default Bignumber instance\n\n\nvar crypto_1 = require(\"@harmony-js/crypto\");\n\nvar utils_1 = require(\"@harmony-js/utils\");\n/** @hidden */\n\n\nvar NegativeOne = new crypto_1.BN(-1);\n/** @hidden */\n\nvar One = new crypto_1.BN(1);\n/** @hidden */\n\nvar Zero = new crypto_1.BN(0);\n/** @hidden */\n\nvar HashZero = '0x0000000000000000000000000000000000000000000000000000000000000000';\n/** @hidden */\n\nvar MaxUint256 = utils_1.hexToBN('0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'); ///////////////////////////////\n\n/** @hidden */\n\nvar paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\n/** @hidden */\n\nvar paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\n/** @hidden */\n\nvar paramTypeArray = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\n/** @hidden */\n\nexports.defaultCoerceFunc = function (type, value) {\n  var match = type.match(paramTypeNumber);\n\n  if (match && parseInt(match[2], 10) <= 48) {\n    // return value.toNumber();\n    return value.toString('hex');\n  }\n\n  return value;\n}; ///////////////////////////////////\n// Parsing for Solidity Signatures\n///////////////////////////////////\n// Parsing for Solidity Signatures\n\n/** @hidden */\n\n\nvar regexParen = new RegExp('^([^)(]*)\\\\((.*)\\\\)([^)(]*)$');\n/** @hidden */\n\nvar regexIdentifier = new RegExp('^[A-Za-z_][A-Za-z0-9_]*$');\n/** @hidden */\n\nfunction verifyType(type) {\n  // These need to be transformed to their full description\n  if (type.match(/^uint($|[^1-9])/)) {\n    type = 'uint256' + type.substring(4);\n  } else if (type.match(/^int($|[^1-9])/)) {\n    type = 'int256' + type.substring(3);\n  }\n\n  return type;\n}\n/** @hidden */\n\n\nfunction parseParam(param, allowIndexed) {\n  var originalParam = param; // tslint:disable-next-line: no-shadowed-variable\n\n  function throwError(i) {\n    throw new Error('unexpected character \"' + originalParam[i] + '\" at position ' + i + ' in \"' + originalParam + '\"');\n  }\n\n  param = param.replace(/\\s/g, ' ');\n  var parent = {\n    type: '',\n    name: '',\n    state: {\n      allowType: true\n    }\n  };\n  var node = parent;\n\n  for (var i = 0; i < param.length; i++) {\n    var c = param[i];\n\n    switch (c) {\n      case '(':\n        if (!node.state || !node.state.allowParams) {\n          throwError(i);\n        }\n\n        if (node.state) {\n          node.state.allowType = false;\n        }\n\n        if (node.type) {\n          node.type = verifyType(node.type);\n        }\n\n        node.components = [{\n          type: '',\n          name: '',\n          parent: node,\n          state: {\n            allowType: true\n          }\n        }];\n        node = node.components[0];\n        break;\n\n      case ')':\n        delete node.state;\n\n        if (allowIndexed && node.name === 'indexed') {\n          node.indexed = true;\n          node.name = '';\n        }\n\n        if (node.type) {\n          node.type = verifyType(node.type);\n        }\n\n        var child = node;\n        node = node.parent;\n\n        if (!node) {\n          throwError(i);\n        }\n\n        delete child.parent;\n\n        if (node.state) {\n          node.state.allowParams = false;\n          node.state.allowName = true;\n          node.state.allowArray = true;\n        }\n\n        break;\n\n      case ',':\n        delete node.state;\n\n        if (allowIndexed && node.name === 'indexed') {\n          node.indexed = true;\n          node.name = '';\n        }\n\n        if (node.type) {\n          node.type = verifyType(node.type);\n        }\n\n        var sibling = {\n          type: '',\n          name: '',\n          parent: node.parent,\n          state: {\n            allowType: true\n          }\n        };\n        node.parent.components.push(sibling);\n        delete node.parent;\n        node = sibling;\n        break;\n      // Hit a space...\n\n      case ' ':\n        // If reading type, the type is done and may read a param or name\n        if (node.state) {\n          if (node.state.allowType) {\n            if (node.type !== '' && node.type) {\n              node.type = verifyType(node.type);\n              delete node.state.allowType;\n              node.state.allowName = true;\n              node.state.allowParams = true;\n            }\n          } // If reading name, the name is done\n\n\n          if (node.state.allowName) {\n            if (node.name !== '') {\n              if (allowIndexed && node.name === 'indexed') {\n                node.indexed = true;\n                node.name = '';\n              } else {\n                node.state.allowName = false;\n              }\n            }\n          }\n        }\n\n        break;\n\n      case '[':\n        if (!node.state || !node.state.allowArray) {\n          throwError(i);\n        }\n\n        if (node.state) {\n          node.type += c;\n          node.state.allowArray = false;\n          node.state.allowName = false;\n          node.state.readArray = true;\n        }\n\n        break;\n\n      case ']':\n        if (!node.state || !node.state.readArray) {\n          throwError(i);\n        }\n\n        if (node.state) {\n          node.type += c;\n          node.state.readArray = false;\n          node.state.allowArray = true;\n          node.state.allowName = true;\n        }\n\n        break;\n\n      default:\n        if (node.state) {\n          if (node.state.allowType) {\n            node.type += c;\n            node.state.allowParams = true;\n            node.state.allowArray = true;\n          } else if (node.state.allowName) {\n            node.name += c;\n            delete node.state.allowArray;\n          } else if (node.state.readArray) {\n            node.type += c;\n          } else {\n            throwError(i);\n          }\n        }\n\n    }\n  }\n\n  if (node.parent) {\n    throw new Error('unexpected eof');\n  }\n\n  delete parent.state;\n\n  if (allowIndexed && node.name === 'indexed') {\n    node.indexed = true;\n    node.name = '';\n  }\n\n  if (parent.type) {\n    parent.type = verifyType(parent.type);\n  }\n\n  return parent;\n} // @TODO: Better return type\n\n/** @hidden */\n\n\nfunction parseSignatureEvent(fragment) {\n  var abi = {\n    anonymous: false,\n    inputs: [],\n    name: '',\n    type: 'event'\n  };\n  var match = fragment.match(regexParen);\n\n  if (!match) {\n    throw new Error('invalid event: ' + fragment);\n  }\n\n  abi.name = match[1].trim();\n  splitNesting(match[2]).forEach(function (param) {\n    param = parseParam(param, true);\n    param.indexed = !!param.indexed;\n    abi.inputs.push(param);\n  });\n  match[3].split(' ').forEach(function (modifier) {\n    switch (modifier) {\n      case 'anonymous':\n        abi.anonymous = true;\n        break;\n\n      case '':\n        break;\n\n      default:\n        crypto_1.info('unknown modifier: ' + modifier);\n    }\n  });\n\n  if (abi.name && !abi.name.match(regexIdentifier)) {\n    throw new Error('invalid identifier: \"' + abi.name + '\"');\n  }\n\n  return abi;\n}\n/** @hidden */\n\n\nfunction parseParamType(type) {\n  return parseParam(type, true);\n}\n\nexports.parseParamType = parseParamType; // @TODO: Allow a second boolean to expose names\n\n/** @hidden */\n\nfunction formatParamType(paramType) {\n  return getParamCoder(exports.defaultCoerceFunc, paramType).type;\n}\n\nexports.formatParamType = formatParamType;\n/** @hidden */\n\nfunction parseSignatureFunction(fragment) {\n  var abi = {\n    constant: false,\n    gas: null,\n    inputs: [],\n    name: '',\n    outputs: [],\n    payable: false,\n    stateMutability: null,\n    type: 'function'\n  };\n  var comps = fragment.split('@');\n\n  if (comps.length !== 1) {\n    if (comps.length > 2) {\n      throw new Error('invalid signature');\n    }\n\n    if (!comps[1].match(/^[0-9]+$/)) {\n      throw new Error('invalid signature gas');\n    }\n\n    abi.gas = new crypto_1.BN(comps[1]);\n    fragment = comps[0];\n  }\n\n  comps = fragment.split(' returns ');\n  var left = comps[0].match(regexParen);\n\n  if (!left) {\n    throw new Error('invalid signature');\n  }\n\n  abi.name = left[1].trim();\n\n  if (!abi.name.match(regexIdentifier)) {\n    throw new Error('invalid identifier: \"' + left[1] + '\"');\n  }\n\n  splitNesting(left[2]).forEach(function (param) {\n    abi.inputs.push(parseParam(param));\n  });\n  left[3].split(' ').forEach(function (modifier) {\n    switch (modifier) {\n      case 'constant':\n        abi.constant = true;\n        break;\n\n      case 'payable':\n        abi.payable = true;\n        abi.stateMutability = 'payable';\n        break;\n\n      case 'pure':\n        abi.constant = true;\n        abi.stateMutability = 'pure';\n        break;\n\n      case 'view':\n        abi.constant = true;\n        abi.stateMutability = 'view';\n        break;\n\n      case 'external':\n      case 'public':\n      case '':\n        break;\n\n      default:\n        crypto_1.info('unknown modifier: ' + modifier);\n    }\n  }); // We have outputs\n\n  if (comps.length > 1) {\n    var right = comps[1].match(regexParen);\n\n    if (right === null || right[1].trim() !== '' || right[3].trim() !== '') {\n      throw new Error('unexpected tokens');\n    }\n\n    splitNesting(right[2]).forEach(function (param) {\n      abi.outputs.push(parseParam(param));\n    });\n  }\n\n  if (abi.name === 'constructor') {\n    abi.type = 'constructor';\n\n    if (abi.outputs.length) {\n      throw new Error('constructor may not have outputs');\n    }\n\n    delete abi.name;\n    delete abi.outputs;\n  }\n\n  return abi;\n} // @TODO: Allow a second boolean to expose names and modifiers\n\n/** @hidden */\n\n\nfunction formatSignature(fragment) {\n  return fragment.name + '(' + fragment.inputs.map(function (i) {\n    return formatParamType(i);\n  }).join(',') + ')';\n}\n\nexports.formatSignature = formatSignature;\n/** @hidden */\n\nfunction parseSignature(fragment) {\n  if (typeof fragment === 'string') {\n    // Make sure the \"returns\" is surrounded by a space and all whitespace is exactly one space\n    fragment = fragment.replace(/\\s/g, ' ');\n    fragment = fragment.replace(/\\(/g, ' (').replace(/\\)/g, ') ').replace(/\\s+/g, ' ');\n    fragment = fragment.trim();\n\n    if (fragment.substring(0, 6) === 'event ') {\n      return parseSignatureEvent(fragment.substring(6).trim());\n    } else {\n      if (fragment.substring(0, 9) === 'function ') {\n        fragment = fragment.substring(9);\n      }\n\n      return parseSignatureFunction(fragment.trim());\n    }\n  }\n\n  throw new Error('unknown signature');\n}\n\nexports.parseSignature = parseSignature;\n/** @hidden */\n\nvar Coder = function () {\n  function Coder(coerceFunc, name, type, localName, dynamic) {\n    this.coerceFunc = coerceFunc;\n    this.name = name;\n    this.type = type;\n    this.localName = localName;\n    this.dynamic = dynamic;\n  }\n\n  return Coder;\n}(); // Clones the functionality of an existing Coder, but without a localName\n// tslint:disable-next-line: max-classes-per-file\n\n/** @hidden */\n\n\nvar CoderAnonymous = function (_super) {\n  tslib_1.__extends(CoderAnonymous, _super);\n\n  function CoderAnonymous(coder) {\n    var _this = _super.call(this, coder.coerceFunc, coder.name, coder.type, undefined, coder.dynamic) || this;\n\n    _this.coder = coder;\n    return _this;\n  }\n\n  CoderAnonymous.prototype.encode = function (value) {\n    return this.coder.encode(value);\n  };\n\n  CoderAnonymous.prototype.decode = function (data, offset) {\n    return this.coder.decode(data, offset);\n  };\n\n  return CoderAnonymous;\n}(Coder); // tslint:disable-next-line: max-classes-per-file\n\n/** @hidden */\n\n\nvar CoderNull = function (_super) {\n  tslib_1.__extends(CoderNull, _super);\n\n  function CoderNull(coerceFunc, localName) {\n    return _super.call(this, coerceFunc, 'null', '', localName, false) || this;\n  }\n\n  CoderNull.prototype.encode = function (value) {\n    var result = crypto_1.arrayify([]) || new Uint8Array();\n    return result;\n  };\n\n  CoderNull.prototype.decode = function (data, offset) {\n    if (offset > data.length) {\n      throw new Error('invalid null');\n    }\n\n    return {\n      consumed: 0,\n      value: this.coerceFunc('null', undefined)\n    };\n  };\n\n  return CoderNull;\n}(Coder); // tslint:disable-next-line: max-classes-per-file\n\n/** @hidden */\n\n\nvar CoderNumber = function (_super) {\n  tslib_1.__extends(CoderNumber, _super);\n\n  function CoderNumber(coerceFunc, size, signed, localName) {\n    var _this = this;\n\n    var name = (signed ? 'int' : 'uint') + size * 8;\n    _this = _super.call(this, coerceFunc, name, name, localName, false) || this;\n    _this.size = size;\n    _this.signed = signed;\n    return _this;\n  }\n\n  CoderNumber.prototype.encode = function (value) {\n    var result;\n\n    try {\n      var v = void 0;\n\n      if (typeof value == 'string' && value.startsWith('0x')) {\n        v = new crypto_1.BN(value.slice(2), 'hex');\n      } else {\n        v = new crypto_1.BN(value);\n      }\n\n      if (this.signed) {\n        var bounds = MaxUint256.maskn(this.size * 8 - 1);\n\n        if (v.gt(bounds)) {\n          throw new Error('out-of-bounds');\n        }\n\n        bounds = bounds.add(One).mul(NegativeOne);\n\n        if (v.lt(bounds)) {\n          throw new Error('out-of-bounds');\n        }\n      } else if (v.lt(Zero) || v.gt(MaxUint256.maskn(this.size * 8))) {\n        throw new Error('out-of-bounds');\n      }\n\n      v = v.toTwos(this.size * 8).maskn(this.size * 8);\n\n      if (this.signed) {\n        v = v.fromTwos(this.size * 8).toTwos(256);\n      }\n\n      var vString = v.toString('hex');\n      result = crypto_1.padZeros(crypto_1.arrayify(\"0x\" + vString) || new Uint8Array(), 32);\n    } catch (error) {\n      crypto_1.throwError('invalid number value', crypto_1.INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: this.name,\n        value: value\n      });\n    }\n\n    return result || crypto_1.padZeros(new Uint8Array(), 32);\n  };\n\n  CoderNumber.prototype.decode = function (data, offset) {\n    if (data.length < offset + 32) {\n      crypto_1.throwError('insufficient data for ' + this.name + ' type', crypto_1.INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: this.name,\n        value: crypto_1.hexlify(data.slice(offset, offset + 32))\n      });\n    }\n\n    var junkLength = 32 - this.size;\n    var dataValue = crypto_1.hexlify(data.slice(offset + junkLength, offset + 32));\n    var value = utils_1.hexToBN(dataValue); // tslint:disable-next-line: prefer-conditional-expression\n\n    if (this.signed) {\n      value = value.fromTwos(this.size * 8);\n    } else {\n      value = value.maskn(this.size * 8);\n    }\n\n    return {\n      consumed: 32,\n      value: this.coerceFunc(this.name, value)\n    };\n  };\n\n  return CoderNumber;\n}(Coder);\n/** @hidden */\n\n\nvar uint256Coder = new CoderNumber(function (type, value) {\n  return value;\n}, 32, false, 'none'); // tslint:disable-next-line: max-classes-per-file\n\n/** @hidden */\n\nvar CoderBoolean = function (_super) {\n  tslib_1.__extends(CoderBoolean, _super);\n\n  function CoderBoolean(coerceFunc, localName) {\n    return _super.call(this, coerceFunc, 'bool', 'bool', localName, false) || this;\n  }\n\n  CoderBoolean.prototype.encode = function (value) {\n    return uint256Coder.encode(!!value ? new crypto_1.BN(1) : new crypto_1.BN(0));\n  };\n\n  CoderBoolean.prototype.decode = function (data, offset) {\n    var result;\n\n    try {\n      result = uint256Coder.decode(data, offset);\n    } catch (error) {\n      if (error.reason === 'insufficient data for uint256 type') {\n        crypto_1.throwError('insufficient data for boolean type', crypto_1.INVALID_ARGUMENT, {\n          arg: this.localName,\n          coderType: 'boolean',\n          value: error.value\n        });\n      }\n\n      throw error;\n    }\n\n    return {\n      consumed: result.consumed,\n      value: this.coerceFunc('bool', !result.value.isZero())\n    };\n  };\n\n  return CoderBoolean;\n}(Coder); // tslint:disable-next-line: max-classes-per-file\n\n/** @hidden */\n\n\nvar CoderFixedBytes = function (_super) {\n  tslib_1.__extends(CoderFixedBytes, _super);\n\n  function CoderFixedBytes(coerceFunc, length, localName) {\n    var _this = this;\n\n    var name = 'bytes' + length;\n    _this = _super.call(this, coerceFunc, name, name, localName, false) || this;\n    _this.length = length;\n    return _this;\n  }\n\n  CoderFixedBytes.prototype.encode = function (value) {\n    var result = new Uint8Array(this.length);\n\n    try {\n      var arrayied = crypto_1.arrayify(value);\n      var data = null;\n\n      if (arrayied !== null) {\n        var valueToByte = crypto_1.hexlify(arrayied);\n        data = crypto_1.arrayify(crypto_1.bytesPadRight(valueToByte, this.length));\n      } else {\n        throw new Error('cannot arraify data');\n      }\n\n      if (data === null || data.length !== this.length) {\n        throw new Error('incorrect data length');\n      }\n\n      result.set(data);\n    } catch (error) {\n      crypto_1.throwError('invalid ' + this.name + ' value', crypto_1.INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: this.name,\n        value: error.value || value\n      });\n    }\n\n    return result;\n  };\n\n  CoderFixedBytes.prototype.decode = function (data, offset) {\n    if (data.length < offset + 32) {\n      crypto_1.throwError('insufficient data for ' + name + ' type', crypto_1.INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: this.name,\n        value: crypto_1.hexlify(data.slice(offset, offset + 32))\n      });\n    }\n\n    return {\n      consumed: 32,\n      value: this.coerceFunc(this.name, crypto_1.hexlify(data.slice(offset, offset + this.length)))\n    };\n  };\n\n  return CoderFixedBytes;\n}(Coder); // tslint:disable-next-line: max-classes-per-file\n\n/** @hidden */\n\n\nvar CoderAddress = function (_super) {\n  tslib_1.__extends(CoderAddress, _super);\n\n  function CoderAddress(coerceFunc, localName) {\n    return _super.call(this, coerceFunc, 'address', 'address', localName, false) || this;\n  }\n\n  CoderAddress.prototype.encode = function (value) {\n    var result = new Uint8Array(32);\n\n    try {\n      var addr = crypto_1.arrayify(crypto_1.toChecksumAddress(value)) || new Uint8Array();\n      result.set(addr, 12);\n    } catch (error) {\n      crypto_1.throwError('invalid address', crypto_1.INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: 'address',\n        value: value\n      });\n    }\n\n    return result;\n  };\n\n  CoderAddress.prototype.decode = function (data, offset) {\n    if (data.length < offset + 32) {\n      crypto_1.throwError('insufficuent data for address type', crypto_1.INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: 'address',\n        value: crypto_1.hexlify(data.slice(offset, offset + 32))\n      });\n    }\n\n    return {\n      consumed: 32,\n      value: this.coerceFunc('address', crypto_1.toChecksumAddress(crypto_1.hexlify(data.slice(offset + 12, offset + 32))))\n    };\n  };\n\n  return CoderAddress;\n}(Coder);\n/** @hidden */\n\n\nfunction _encodeDynamicBytes(value) {\n  var dataLength = 32 * Math.ceil(value.length / 32);\n  var padding = new Uint8Array(dataLength - value.length);\n  return crypto_1.concat([uint256Coder.encode(new crypto_1.BN(value.length)), value, padding]);\n}\n/** @hidden */\n\n\nfunction _decodeDynamicBytes(data, offset, localName) {\n  if (data.length < offset + 32) {\n    crypto_1.throwError('insufficient data for dynamicBytes length', crypto_1.INVALID_ARGUMENT, {\n      arg: localName,\n      coderType: 'dynamicBytes',\n      value: crypto_1.hexlify(data.slice(offset, offset + 32))\n    });\n  }\n\n  var length = uint256Coder.decode(data, offset).value;\n\n  try {\n    length = length.toNumber();\n  } catch (error) {\n    crypto_1.throwError('dynamic bytes count too large', crypto_1.INVALID_ARGUMENT, {\n      arg: localName,\n      coderType: 'dynamicBytes',\n      value: length.toString()\n    });\n  }\n\n  if (data.length < offset + 32 + length) {\n    crypto_1.throwError('insufficient data for dynamicBytes type', crypto_1.INVALID_ARGUMENT, {\n      arg: localName,\n      coderType: 'dynamicBytes',\n      value: crypto_1.hexlify(data.slice(offset, offset + 32 + length))\n    });\n  }\n\n  return {\n    consumed: 32 + 32 * Math.ceil(length / 32),\n    value: data.slice(offset + 32, offset + 32 + length)\n  };\n} // tslint:disable-next-line: max-classes-per-file\n\n/** @hidden */\n\n\nvar CoderDynamicBytes = function (_super) {\n  tslib_1.__extends(CoderDynamicBytes, _super);\n\n  function CoderDynamicBytes(coerceFunc, localName) {\n    return _super.call(this, coerceFunc, 'bytes', 'bytes', localName, true) || this;\n  }\n\n  CoderDynamicBytes.prototype.encode = function (value) {\n    var result = new Uint8Array();\n\n    try {\n      result = _encodeDynamicBytes(crypto_1.arrayify(value) || new Uint8Array());\n    } catch (error) {\n      crypto_1.throwError('invalid bytes value', crypto_1.INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: 'bytes',\n        value: error.value\n      });\n    }\n\n    return result;\n  };\n\n  CoderDynamicBytes.prototype.decode = function (data, offset) {\n    var result = _decodeDynamicBytes(data, offset, this.localName || '');\n\n    result.value = this.coerceFunc('bytes', crypto_1.hexlify(result.value));\n    return result;\n  };\n\n  return CoderDynamicBytes;\n}(Coder); // tslint:disable-next-line: max-classes-per-file\n\n/** @hidden */\n\n\nvar CoderString = function (_super) {\n  tslib_1.__extends(CoderString, _super);\n\n  function CoderString(coerceFunc, localName) {\n    return _super.call(this, coerceFunc, 'string', 'string', localName, true) || this;\n  }\n\n  CoderString.prototype.encode = function (value) {\n    if (typeof value !== 'string') {\n      crypto_1.throwError('invalid string value', crypto_1.INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: 'string',\n        value: value\n      });\n    }\n\n    return _encodeDynamicBytes(toUtf8Bytes(value));\n  };\n\n  CoderString.prototype.decode = function (data, offset) {\n    var result = _decodeDynamicBytes(data, offset, this.localName || '');\n\n    result.value = this.coerceFunc('string', toUtf8String(result.value));\n    return result;\n  };\n\n  return CoderString;\n}(Coder);\n/** @hidden */\n\n\nfunction alignSize(size) {\n  return 32 * Math.ceil(size / 32);\n}\n/** @hidden */\n\n\nfunction pack(coders, values) {\n  if (Array.isArray(values)) {// do nothing\n  } else if (values && typeof values === 'object') {\n    var arrayValues_1 = [];\n    coders.forEach(function (coder) {\n      arrayValues_1.push(values[coder.localName || '']);\n    });\n    values = arrayValues_1;\n  } else {\n    crypto_1.throwError('invalid tuple value', crypto_1.INVALID_ARGUMENT, {\n      coderType: 'tuple',\n      value: values\n    });\n  }\n\n  if (coders.length !== values.length) {\n    crypto_1.throwError('types/value length mismatch', crypto_1.INVALID_ARGUMENT, {\n      coderType: 'tuple',\n      value: values\n    });\n  }\n\n  var parts = [];\n  coders.forEach(function (coder, index) {\n    parts.push({\n      dynamic: coder.dynamic,\n      value: coder.encode(values[index])\n    });\n  });\n  var staticSize = 0;\n  var dynamicSize = 0;\n  parts.forEach(function (part) {\n    if (part.dynamic) {\n      staticSize += 32;\n      dynamicSize += alignSize(part.value.length);\n    } else {\n      staticSize += alignSize(part.value.length); // todo : is it to be static size not alignSize?\n    }\n  });\n  var offset = 0;\n  var dynamicOffset = staticSize;\n  var data = new Uint8Array(staticSize + dynamicSize);\n  parts.forEach(function (part) {\n    if (part.dynamic) {\n      // uint256Coder.encode(dynamicOffset).copy(data, offset);\n      data.set(uint256Coder.encode(new crypto_1.BN(dynamicOffset)), offset);\n      offset += 32; // part.value.copy(data, dynamicOffset);  @TODO\n\n      data.set(part.value, dynamicOffset);\n      dynamicOffset += alignSize(part.value.length);\n    } else {\n      // part.value.copy(data, offset);  @TODO\n      data.set(part.value, offset);\n      offset += alignSize(part.value.length);\n    }\n  });\n  return data;\n}\n/** @hidden */\n\n\nfunction unpack(coders, data, offset) {\n  var baseOffset = offset;\n  var consumed = 0;\n  var value = [];\n  coders.forEach(function (coder) {\n    var result;\n\n    if (coder.dynamic) {\n      var dynamicOffset = uint256Coder.decode(data, offset);\n      result = coder.decode(data, baseOffset + dynamicOffset.value.toNumber()); // The dynamic part is leap-frogged somewhere else; doesn't count towards size\n\n      result.consumed = dynamicOffset.consumed;\n    } else {\n      result = coder.decode(data, offset);\n    }\n\n    if (result.value !== undefined) {\n      value.push(result.value);\n    }\n\n    offset += result.consumed;\n    consumed += result.consumed;\n  });\n  coders.forEach(function (coder, index) {\n    var name = coder.localName;\n\n    if (!name) {\n      return;\n    }\n\n    if (name === 'length') {\n      name = '_length';\n    }\n\n    if (value[name] != null) {\n      return;\n    }\n\n    value[name] = value[index];\n  });\n  return {\n    value: value,\n    consumed: consumed\n  };\n} // tslint:disable-next-line: max-classes-per-file\n\n/** @hidden */\n\n\nvar CoderArray = function (_super) {\n  tslib_1.__extends(CoderArray, _super);\n\n  function CoderArray(coerceFunc, coder, length, localName) {\n    var _this = this;\n\n    var type = coder.type + '[' + (length >= 0 ? length : '') + ']';\n    var dynamic = length === -1 || coder.dynamic;\n    _this = _super.call(this, coerceFunc, 'array', type, localName, dynamic) || this;\n    _this.coder = coder;\n    _this.length = length;\n    return _this;\n  }\n\n  CoderArray.prototype.encode = function (value) {\n    if (!Array.isArray(value)) {\n      crypto_1.throwError('expected array value', crypto_1.INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: 'array',\n        value: value\n      });\n    }\n\n    var count = this.length;\n    var result = new Uint8Array(0);\n\n    if (count === -1) {\n      count = value.length;\n      result = uint256Coder.encode(new crypto_1.BN(count));\n    }\n\n    crypto_1.checkArgumentCount(count, value.length, ' in coder array' + (this.localName ? ' ' + this.localName : ''));\n    var coders = []; // tslint:disable-next-line: prefer-for-of\n\n    for (var i = 0; i < value.length; i++) {\n      coders.push(this.coder);\n    }\n\n    return crypto_1.concat([result, pack(coders, value)]);\n  };\n\n  CoderArray.prototype.decode = function (data, offset) {\n    // @TODO:\n    // if (data.length < offset + length * 32) { throw new Error('invalid array'); }\n    var consumed = 0;\n    var count = this.length;\n    var decodedLength = {\n      consumed: 0,\n      value: undefined\n    };\n\n    if (count === -1) {\n      try {\n        decodedLength = uint256Coder.decode(data, offset);\n      } catch (error) {\n        crypto_1.throwError('insufficient data for dynamic array length', crypto_1.INVALID_ARGUMENT, {\n          arg: this.localName,\n          coderType: 'array',\n          value: error.value\n        });\n      }\n\n      try {\n        count = decodedLength.value.toNumber();\n      } catch (error) {\n        crypto_1.throwError('array count too large', crypto_1.INVALID_ARGUMENT, {\n          arg: this.localName,\n          coderType: 'array',\n          value: decodedLength.value.toString()\n        });\n      }\n\n      consumed += decodedLength.consumed;\n      offset += decodedLength.consumed;\n    }\n\n    var coders = [];\n\n    for (var i = 0; i < count; i++) {\n      coders.push(new CoderAnonymous(this.coder));\n    }\n\n    var result = unpack(coders, data, offset);\n    result.consumed += consumed;\n    result.value = this.coerceFunc(this.type, result.value);\n    return result;\n  };\n\n  return CoderArray;\n}(Coder); // tslint:disable-next-line: max-classes-per-file\n\n/** @hidden */\n\n\nvar CoderTuple = function (_super) {\n  tslib_1.__extends(CoderTuple, _super);\n\n  function CoderTuple(coerceFunc, coders, localName) {\n    var _this = this;\n\n    var dynamic = false;\n    var types = [];\n    coders.forEach(function (coder) {\n      if (coder.dynamic) {\n        dynamic = true;\n      }\n\n      types.push(coder.type);\n    });\n    var type = 'tuple(' + types.join(',') + ')';\n    _this = _super.call(this, coerceFunc, 'tuple', type, localName, dynamic) || this;\n    _this.coders = coders;\n    return _this;\n  }\n\n  CoderTuple.prototype.encode = function (value) {\n    return pack(this.coders, value);\n  };\n\n  CoderTuple.prototype.decode = function (data, offset) {\n    var result = unpack(this.coders, data, offset);\n    result.value = this.coerceFunc(this.type, result.value);\n    return result;\n  };\n\n  return CoderTuple;\n}(Coder);\n/** @hidden */\n\n\nfunction splitNesting(value) {\n  value = value.trim();\n  var result = [];\n  var accum = '';\n  var depth = 0; // tslint:disable-next-line: prefer-for-of\n\n  for (var offset = 0; offset < value.length; offset++) {\n    var c = value[offset];\n\n    if (c === ',' && depth === 0) {\n      result.push(accum);\n      accum = '';\n    } else {\n      accum += c;\n\n      if (c === '(') {\n        depth++;\n      } else if (c === ')') {\n        depth--;\n\n        if (depth === -1) {\n          throw new Error('unbalanced parenthsis');\n        }\n      }\n    }\n  }\n\n  if (accum) {\n    result.push(accum);\n  }\n\n  return result;\n} // @TODO: Is there a way to return \"class\"?\n\n/** @hidden */\n\n\nvar paramTypeSimple = {\n  address: CoderAddress,\n  bool: CoderBoolean,\n  string: CoderString,\n  bytes: CoderDynamicBytes\n};\n/** @hidden */\n\nfunction getTupleParamCoder(coerceFunc, components, localName) {\n  if (!components) {\n    components = [];\n  }\n\n  var coders = [];\n  components.forEach(function (component) {\n    coders.push(getParamCoder(coerceFunc, component));\n  });\n  return new CoderTuple(coerceFunc, coders, localName);\n}\n/** @hidden */\n\n\nfunction getParamCoder(coerceFunc, param) {\n  var coder = paramTypeSimple[param.type];\n\n  if (coder) {\n    return new coder(coerceFunc, param.name);\n  }\n\n  var matcher = param.type.match(paramTypeNumber);\n\n  if (matcher) {\n    var size = parseInt(matcher[2] || '256', 10);\n\n    if (size === 0 || size > 256 || size % 8 !== 0) {\n      crypto_1.throwError('invalid ' + matcher[1] + ' bit length', crypto_1.INVALID_ARGUMENT, {\n        arg: 'param',\n        value: param\n      });\n    }\n\n    return new CoderNumber(coerceFunc, size / 8, matcher[1] === 'int', param.name || '');\n  }\n\n  var matcher2 = param.type.match(paramTypeBytes);\n\n  if (matcher2) {\n    var size = parseInt(matcher2[1], 10);\n\n    if (size === 0 || size > 32) {\n      crypto_1.throwError('invalid bytes length', crypto_1.INVALID_ARGUMENT, {\n        arg: 'param',\n        value: param\n      });\n    }\n\n    return new CoderFixedBytes(coerceFunc, size, param.name || '');\n  }\n\n  var matcher3 = param.type.match(paramTypeArray);\n\n  if (matcher3) {\n    var size = parseInt(matcher3[2] || '-1', 10);\n    param = shallowCopy(param);\n    param.type = matcher3[1];\n    param = deepCopy(param);\n    return new CoderArray(coerceFunc, getParamCoder(coerceFunc, param), size, param.name || '');\n  }\n\n  if (param.type.substring(0, 5) === 'tuple') {\n    return getTupleParamCoder(coerceFunc, param.components || [], param.name || '');\n  }\n\n  if (param.type === '') {\n    return new CoderNull(coerceFunc, param.name || '');\n  }\n\n  crypto_1.throwError('invalid type', crypto_1.INVALID_ARGUMENT, {\n    arg: 'type',\n    value: param.type\n  });\n}\n/** @hidden */\n\n\nvar UnicodeNormalizationForm;\n\n(function (UnicodeNormalizationForm) {\n  UnicodeNormalizationForm[\"current\"] = \"\";\n  UnicodeNormalizationForm[\"NFC\"] = \"NFC\";\n  UnicodeNormalizationForm[\"NFD\"] = \"NFD\";\n  UnicodeNormalizationForm[\"NFKC\"] = \"NFKC\";\n  UnicodeNormalizationForm[\"NFKD\"] = \"NFKD\";\n})(UnicodeNormalizationForm = exports.UnicodeNormalizationForm || (exports.UnicodeNormalizationForm = {}));\n/** @hidden */\n\n\nfunction toUtf8Bytes(str, form) {\n  if (form === void 0) {\n    form = UnicodeNormalizationForm.current;\n  }\n\n  if (form !== UnicodeNormalizationForm.current) {\n    crypto_1.checkNormalize();\n    str = str.normalize(form);\n  }\n\n  var result = [];\n\n  for (var i = 0; i < str.length; i++) {\n    var c = str.charCodeAt(i);\n\n    if (c < 0x80) {\n      result.push(c);\n    } else if (c < 0x800) {\n      result.push(c >> 6 | 0xc0);\n      result.push(c & 0x3f | 0x80);\n    } else if ((c & 0xfc00) === 0xd800) {\n      i++;\n      var c2 = str.charCodeAt(i);\n\n      if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {\n        throw new Error('invalid utf-8 string');\n      } // Surrogate Pair\n\n\n      c = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n      result.push(c >> 18 | 0xf0);\n      result.push(c >> 12 & 0x3f | 0x80);\n      result.push(c >> 6 & 0x3f | 0x80);\n      result.push(c & 0x3f | 0x80);\n    } else {\n      result.push(c >> 12 | 0xe0);\n      result.push(c >> 6 & 0x3f | 0x80);\n      result.push(c & 0x3f | 0x80);\n    }\n  }\n\n  return crypto_1.arrayify(result) || new Uint8Array();\n}\n\nexports.toUtf8Bytes = toUtf8Bytes; // http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\n\n/** @hidden */\n\nfunction toUtf8String(bytes, ignoreErrors) {\n  bytes = crypto_1.arrayify(bytes) || new Uint8Array();\n  var result = '';\n  var i = 0; // Invalid bytes are ignored\n\n  while (i < bytes.length) {\n    var c = bytes[i++]; // 0xxx xxxx\n\n    if (c >> 7 === 0) {\n      result += String.fromCharCode(c);\n      continue;\n    } // Multibyte; how many bytes left for this character?\n\n\n    var extraLength = null;\n    var overlongMask = null; // 110x xxxx 10xx xxxx\n\n    if ((c & 0xe0) === 0xc0) {\n      extraLength = 1;\n      overlongMask = 0x7f; // 1110 xxxx 10xx xxxx 10xx xxxx\n    } else if ((c & 0xf0) === 0xe0) {\n      extraLength = 2;\n      overlongMask = 0x7ff; // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n    } else if ((c & 0xf8) === 0xf0) {\n      extraLength = 3;\n      overlongMask = 0xffff;\n    } else {\n      if (!ignoreErrors) {\n        if ((c & 0xc0) === 0x80) {\n          throw new Error('invalid utf8 byte sequence; unexpected continuation byte');\n        }\n\n        throw new Error('invalid utf8 byte sequence; invalid prefix');\n      }\n\n      continue;\n    } // Do we have enough bytes in our data?\n\n\n    if (i + extraLength > bytes.length) {\n      if (!ignoreErrors) {\n        throw new Error('invalid utf8 byte sequence; too short');\n      } // If there is an invalid unprocessed byte, skip continuation bytes\n\n\n      for (; i < bytes.length; i++) {\n        if (bytes[i] >> 6 !== 0x02) {\n          break;\n        }\n      }\n\n      continue;\n    } // Remove the length prefix from the char\n\n\n    var res = c & (1 << 8 - extraLength - 1) - 1;\n\n    for (var j = 0; j < extraLength; j++) {\n      var nextChar = bytes[i]; // Invalid continuation byte\n\n      if ((nextChar & 0xc0) !== 0x80) {\n        res = null;\n        break;\n      }\n\n      res = res << 6 | nextChar & 0x3f;\n      i++;\n    }\n\n    if (res === null) {\n      if (!ignoreErrors) {\n        throw new Error('invalid utf8 byte sequence; invalid continuation byte');\n      }\n\n      continue;\n    } // Check for overlong seuences (more bytes than needed)\n\n\n    if (res <= overlongMask) {\n      if (!ignoreErrors) {\n        throw new Error('invalid utf8 byte sequence; overlong');\n      }\n\n      continue;\n    } // Maximum code point\n\n\n    if (res > 0x10ffff) {\n      if (!ignoreErrors) {\n        throw new Error('invalid utf8 byte sequence; out-of-range');\n      }\n\n      continue;\n    } // Reserved for UTF-16 surrogate halves\n\n\n    if (res >= 0xd800 && res <= 0xdfff) {\n      if (!ignoreErrors) {\n        throw new Error('invalid utf8 byte sequence; utf-16 surrogate');\n      }\n\n      continue;\n    }\n\n    if (res <= 0xffff) {\n      result += String.fromCharCode(res);\n      continue;\n    }\n\n    res -= 0x10000;\n    result += String.fromCharCode((res >> 10 & 0x3ff) + 0xd800, (res & 0x3ff) + 0xdc00);\n  }\n\n  return result;\n}\n\nexports.toUtf8String = toUtf8String;\n/** @hidden */\n\nfunction formatBytes32String(text) {\n  // Get the bytes\n  var bytes = toUtf8Bytes(text); // Check we have room for null-termination\n\n  if (bytes.length > 31) {\n    throw new Error('bytes32 string must be less than 32 bytes');\n  } // Zero-pad (implicitly null-terminates)\n\n\n  return crypto_1.hexlify(crypto_1.concat([bytes, HashZero]).slice(0, 32));\n}\n\nexports.formatBytes32String = formatBytes32String;\n/** @hidden */\n\nfunction parseBytes32String(bytes) {\n  var data = crypto_1.arrayify(bytes) || new Uint8Array(); // Must be 32 bytes with a null-termination\n\n  if (data.length !== 32) {\n    throw new Error('invalid bytes32 - not 32 bytes long');\n  }\n\n  if (data[31] !== 0) {\n    throw new Error('invalid bytes32 sdtring - no null terminator');\n  } // Find the null termination\n\n\n  var length = 31;\n\n  while (data[length - 1] === 0) {\n    length--;\n  } // Determine the string value\n\n\n  return toUtf8String(data.slice(0, length));\n}\n\nexports.parseBytes32String = parseBytes32String;\n/** @hidden */\n\nfunction isType(object, type) {\n  return object && object._ethersType === type;\n}\n\nexports.isType = isType;\n/** @hidden */\n\nfunction shallowCopy(object) {\n  var result = {}; // tslint:disable-next-line: forin\n\n  for (var key in object) {\n    result[key] = object[key];\n  }\n\n  return result;\n}\n\nexports.shallowCopy = shallowCopy;\n/** @hidden */\n\nvar opaque = {\n  boolean: true,\n  number: true,\n  string: true\n};\n/** @hidden */\n\nfunction deepCopy(object, frozen) {\n  // Opaque objects are not mutable, so safe to copy by assignment\n  if (object === undefined || object === null || opaque[typeof object]) {\n    return object;\n  } // Arrays are mutable, so we need to create a copy\n\n\n  if (Array.isArray(object)) {\n    var result = object.map(function (item) {\n      return deepCopy(item, frozen);\n    });\n\n    if (frozen) {\n      Object.freeze(result);\n    }\n\n    return result;\n  }\n\n  if (typeof object === 'object') {\n    // Some internal objects, which are already immutable\n    if (isType(object, 'BigNumber')) {\n      return object;\n    }\n\n    if (isType(object, 'Description')) {\n      return object;\n    }\n\n    if (isType(object, 'Indexed')) {\n      return object;\n    }\n\n    var result = {}; // tslint:disable-next-line: forin\n\n    for (var key in object) {\n      var value = object[key];\n\n      if (value === undefined) {\n        continue;\n      }\n\n      utils_1.defineReadOnly(result, key, deepCopy(value, frozen));\n    }\n\n    if (frozen) {\n      Object.freeze(result);\n    }\n\n    return result;\n  } // The function type is also immutable, so safe to copy by assignment\n\n\n  if (typeof object === 'function') {\n    return object;\n  }\n\n  throw new Error('Cannot deepCopy ' + typeof object);\n}\n\nexports.deepCopy = deepCopy; // tslint:disable-next-line: max-classes-per-file\n\n/** @hidden */\n\nvar AbiCoder = function () {\n  function AbiCoder(coerceFunc) {\n    crypto_1.checkNew(this, AbiCoder);\n\n    if (!coerceFunc) {\n      coerceFunc = exports.defaultCoerceFunc;\n    }\n\n    this.coerceFunc = coerceFunc;\n  }\n\n  AbiCoder.prototype.encode = function (types, values) {\n    var _this = this;\n\n    if (types.length !== values.length) {\n      crypto_1.throwError('types/values length mismatch', crypto_1.INVALID_ARGUMENT, {\n        count: {\n          types: types.length,\n          values: values.length\n        },\n        value: {\n          types: types,\n          values: values\n        }\n      });\n    }\n\n    var coders = [];\n    types.forEach(function (type) {\n      // Convert types to type objects\n      //   - \"uint foo\" => { type: \"uint\", name: \"foo\" }\n      //   - \"tuple(uint, uint)\" => { type: \"tuple\", components: [ { type: \"uint\" }, { type: \"uint\" }, ] }\n      var typeObject = null; // tslint:disable-next-line: prefer-conditional-expression\n\n      if (typeof type === 'string') {\n        typeObject = parseParam(type);\n      } else {\n        typeObject = type;\n      }\n\n      coders.push(getParamCoder(_this.coerceFunc, typeObject));\n    }, this);\n    var encodedArray = new CoderTuple(this.coerceFunc, coders, '_').encode(values);\n    return crypto_1.hexlify(encodedArray);\n  };\n\n  AbiCoder.prototype.decode = function (types, data) {\n    var _this = this;\n\n    var coders = [];\n    types.forEach(function (type) {\n      // See encode for details\n      var typeObject = null; // tslint:disable-next-line: prefer-conditional-expression\n\n      if (typeof type === 'string') {\n        typeObject = parseParam(type);\n      } else {\n        typeObject = deepCopy(type);\n      }\n\n      coders.push(getParamCoder(_this.coerceFunc, typeObject));\n    }, this);\n    var result = new CoderTuple(this.coerceFunc, coders, '_').decode(crypto_1.arrayify(data) || new Uint8Array(), 0).value;\n    return result;\n  };\n\n  return AbiCoder;\n}();\n\nexports.AbiCoder = AbiCoder;\n/** @hidden */\n\nexports.defaultAbiCoder = new AbiCoder();","map":{"version":3,"sources":["../../src/abi/abiCoder.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n # @harmony-js/contract\n\nThis package provides a collection of apis to create, deploy, and interact with smart contracts. In Harmony, smart contracts all fully EVM compatible and the formats and terminologies match 1-to-1 with EVM smart contracts.\n\n## Installation\n\n```\nnpm install @harmony-js/contract\n```\n\n## Usage\n\nDeploying a contract using `contractConstructor`\n```javascript\nconst { ContractFactory } = require('@harmony-js/contract');\nconst { Wallet } = require('@harmony-js/account');\nconst { Messenger, HttpProvider } = require('@harmony-js/network');\nconst { ChainID, ChainType, hexToNumber } = require('@harmony-js/utils');\n\n* const wallet = new Wallet(\n*   new Messenger(\n*     new HttpProvider('https://api.s0.b.hmny.io'),\n*     ChainType.Harmony,\n*     ChainID.HmyTestnet,\n*   ),\n* );\n* const factory = new ContractFactory(wallet);\n\n* const contractJson = require(\"./Counter.json\");\n* const contract = factory.createContract(contractJson.abi);\n\n* const options1 = { gasPrice: '0x3B9ACA00' }; // gas price in hex corresponds to 1 Gwei or 1000000000\n* let options2 = { gasPrice: 1000000000, gasLimit: 21000 }; // setting the default gas limit, but changing later based on estimate gas\n\n* const options3 = { data: contractJson.bytecode }; // contractConstructor needs contract bytecode to deploy\n\n* contract.wallet.addByPrivateKey('1f054c21a0f57ebc402c00e14bd1707ddf45542d4ed9989933dbefc4ea96ca68');\n\n* contract.methods.contractConstructor(options3).estimateGas(options1).then(gas => {\n*   options2 = {...options2, gasLimit: hexToNumber(gas)};\n*   contract.methods.contractConstructor(options3).send(options2).then(response => {\n*     console.log('contract deployed at ' + response.transaction.receipt.contractAddress);\n*   });\n* });\n```\nInstead of `contract.methods.contractConstructor`, `contract.deploy` could be used and it will work.\n\nLoading a contract object using the contract json and contract address for interacting with it\n```javascript\n* const { Harmony } = require(\"@harmony-js/core\");\n* const { ChainID, ChainType } = require(\"@harmony-js/utils\");\n* const hmy = new Harmony(\"https://api.s0.b.hmny.io\", {\n*   chainType: ChainType.Harmony,\n*   chainId: ChainID.HmyTestnet,\n* });\n\nconst contractJson = require(\"./Counter.json\");\nconst contractAddr = \"0x19f64050e6b2d376e52AC426E366c49EEb0724B1\";\n\nconst contract = hmy.contracts.createContract(contractJson.abi, contractAddr);\nconsole.log(contract.methods);\n```\n\nDirectly loading contract using `ContractFactory`\n```javascript\nconst { ContractFactory } = require('@harmony-js/contract');\nconst { Wallet } = require('@harmony-js/account');\nconst { Messenger, HttpProvider } = require('@harmony-js/network');\nconst { ChainID, ChainType, hexToNumber } = require('@harmony-js/utils');\n\n* const wallet = new Wallet(new Messenger(\n*   new HttpProvider('https://api.s0.b.hmny.io'),\n*   ChainType.Harmony,\n*   ChainID.HmyTestnet,\n* ));\nconst factory = new ContractFactory(wallet);\nconst contract = factory.createContract(contractJson.abi, contractAddr);\n```\n\nEstimate gas for contract methods\n```javascript\n* const options1 = { gasPrice: '0x3B9ACA00' }; // gas price in hex corresponds to 1 Gwei or 1000000000\n\n* contract.methods.getCount().estimateGas(options1).then(gas => {\n*   console.log('gas required for getCount is ' + hexToNumber(gas));\n* });\n```\n\nCall contract read-only methods. Harmony uses 1 Gwei gas price and gas limit of 21000 by default. Use the estimate gas api to correctly set the gas limit.\n```javascript\n* const options1 = { gasPrice: '0x3B9ACA00' }; // gas price in hex corresponds to 1 Gwei or 1000000000\n* let options2 = { gasPrice: 1000000000, gasLimit: 21000 }; // setting the default gas limit, but changing later based on estimate gas\n\n* contract.methods.getCount().estimateGas(options1).then(gas => {\n*   options2 = {...options2, gasLimit: hexToNumber(gas)};\n*   contract.methods.getCount().call(options2).then(count => {\n*     console.log('counter value: ' + count);\n*   });\n* });\n```\n\nInvoking contract modification methods using `send` api. Need to add a signing account to the contract wallet, otherwise `send` api will not work.\n```javascript\n* const options1 = { gasPrice: '0x3B9ACA00' }; // gas price in hex corresponds to 1 Gwei or 1000000000\n* let options2 = { gasPrice: 1000000000, gasLimit: 21000 }; // setting the default gas limit, but changing later based on estimate gas\n\n* contract.wallet.addByPrivateKey('1f054c21a0f57ebc402c00e14bd1707ddf45542d4ed9989933dbefc4ea96ca68');\n\n* contract.methods.incrementCounter().estimateGas(options1).then(gas => {\n*   options2 = {...options2, gasLimit: hexToNumber(gas)};\n*   contract.methods.incrementCounter().send(options2).then(response => {\n*     console.log(response.transaction.receipt);\n*   });\n* });\n```\n\nAll the above apis can also be asynchronously executed using `async` and `await`.\n\nSubscribing to the contract events requires web socket based messenger.\n```javascript\n* const { ContractFactory } = require('@harmony-js/contract');\n* const { Wallet } = require('@harmony-js/account');\n* const { Messenger, WSProvider } = require('@harmony-js/network');\n* const { ChainID, ChainType, hexToNumber } = require('@harmony-js/utils');\n* const ws = new WSProvider('wss://ws.s0.b.hmny.io');\n\n* const wallet = new Wallet(\n*   new Messenger(\n*     ws,\n*     ChainType.Harmony,\n*     ChainID.HmyTestnet,\n*   ),\n* );\n* const factory = new ContractFactory(wallet);\n\n* const contractJson = require(\"./Counter.json\");\n* const contractAddr = '0x8ada52172abda19b9838eb00498a40952be6a019';\n\n* const contract = factory.createContract(contractJson.abi, contractAddr);\n\n* contract.events\n*   .IncrementedBy()\n*   .on('data', (event) => {\n*     console.log(event);\n*   })\n*   .on('error', console.error);\n```\n *\n * @packageDocumentation\n * @module harmony-contract\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.defaultAbiCoder = exports.AbiCoder = exports.deepCopy = exports.shallowCopy = exports.isType = exports.parseBytes32String = exports.formatBytes32String = exports.toUtf8String = exports.toUtf8Bytes = exports.UnicodeNormalizationForm = exports.parseSignature = exports.formatSignature = exports.formatParamType = exports.parseParamType = exports.defaultCoerceFunc = void 0;\nvar tslib_1 = require(\"tslib\");\n// this file is mainly ported from `ethers.js`, but done some fixes\n// 1. added bytesPadRight support\n// 2. ts-lint\n// 3. use BN as default Bignumber instance\nvar crypto_1 = require(\"@harmony-js/crypto\");\nvar utils_1 = require(\"@harmony-js/utils\");\n/** @hidden */\nvar NegativeOne = new crypto_1.BN(-1);\n/** @hidden */\nvar One = new crypto_1.BN(1);\n/** @hidden */\nvar Zero = new crypto_1.BN(0);\n/** @hidden */\nvar HashZero = '0x0000000000000000000000000000000000000000000000000000000000000000';\n/** @hidden */\nvar MaxUint256 = utils_1.hexToBN('0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');\n///////////////////////////////\n/** @hidden */\nvar paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\n/** @hidden */\nvar paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\n/** @hidden */\nvar paramTypeArray = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\n/** @hidden */\nexports.defaultCoerceFunc = function (type, value) {\n    var match = type.match(paramTypeNumber);\n    if (match && parseInt(match[2], 10) <= 48) {\n        // return value.toNumber();\n        return value.toString('hex');\n    }\n    return value;\n};\n///////////////////////////////////\n// Parsing for Solidity Signatures\n///////////////////////////////////\n// Parsing for Solidity Signatures\n/** @hidden */\nvar regexParen = new RegExp('^([^)(]*)\\\\((.*)\\\\)([^)(]*)$');\n/** @hidden */\nvar regexIdentifier = new RegExp('^[A-Za-z_][A-Za-z0-9_]*$');\n/** @hidden */\nfunction verifyType(type) {\n    // These need to be transformed to their full description\n    if (type.match(/^uint($|[^1-9])/)) {\n        type = 'uint256' + type.substring(4);\n    }\n    else if (type.match(/^int($|[^1-9])/)) {\n        type = 'int256' + type.substring(3);\n    }\n    return type;\n}\n/** @hidden */\nfunction parseParam(param, allowIndexed) {\n    var originalParam = param;\n    // tslint:disable-next-line: no-shadowed-variable\n    function throwError(i) {\n        throw new Error('unexpected character \"' +\n            originalParam[i] +\n            '\" at position ' +\n            i +\n            ' in \"' +\n            originalParam +\n            '\"');\n    }\n    param = param.replace(/\\s/g, ' ');\n    var parent = { type: '', name: '', state: { allowType: true } };\n    var node = parent;\n    for (var i = 0; i < param.length; i++) {\n        var c = param[i];\n        switch (c) {\n            case '(':\n                if (!node.state || !node.state.allowParams) {\n                    throwError(i);\n                }\n                if (node.state) {\n                    node.state.allowType = false;\n                }\n                if (node.type) {\n                    node.type = verifyType(node.type);\n                }\n                node.components = [{ type: '', name: '', parent: node, state: { allowType: true } }];\n                node = node.components[0];\n                break;\n            case ')':\n                delete node.state;\n                if (allowIndexed && node.name === 'indexed') {\n                    node.indexed = true;\n                    node.name = '';\n                }\n                if (node.type) {\n                    node.type = verifyType(node.type);\n                }\n                var child = node;\n                node = node.parent;\n                if (!node) {\n                    throwError(i);\n                }\n                delete child.parent;\n                if (node.state) {\n                    node.state.allowParams = false;\n                    node.state.allowName = true;\n                    node.state.allowArray = true;\n                }\n                break;\n            case ',':\n                delete node.state;\n                if (allowIndexed && node.name === 'indexed') {\n                    node.indexed = true;\n                    node.name = '';\n                }\n                if (node.type) {\n                    node.type = verifyType(node.type);\n                }\n                var sibling = {\n                    type: '',\n                    name: '',\n                    parent: node.parent,\n                    state: { allowType: true },\n                };\n                node.parent.components.push(sibling);\n                delete node.parent;\n                node = sibling;\n                break;\n            // Hit a space...\n            case ' ':\n                // If reading type, the type is done and may read a param or name\n                if (node.state) {\n                    if (node.state.allowType) {\n                        if (node.type !== '' && node.type) {\n                            node.type = verifyType(node.type);\n                            delete node.state.allowType;\n                            node.state.allowName = true;\n                            node.state.allowParams = true;\n                        }\n                    }\n                    // If reading name, the name is done\n                    if (node.state.allowName) {\n                        if (node.name !== '') {\n                            if (allowIndexed && node.name === 'indexed') {\n                                node.indexed = true;\n                                node.name = '';\n                            }\n                            else {\n                                node.state.allowName = false;\n                            }\n                        }\n                    }\n                }\n                break;\n            case '[':\n                if (!node.state || !node.state.allowArray) {\n                    throwError(i);\n                }\n                if (node.state) {\n                    node.type += c;\n                    node.state.allowArray = false;\n                    node.state.allowName = false;\n                    node.state.readArray = true;\n                }\n                break;\n            case ']':\n                if (!node.state || !node.state.readArray) {\n                    throwError(i);\n                }\n                if (node.state) {\n                    node.type += c;\n                    node.state.readArray = false;\n                    node.state.allowArray = true;\n                    node.state.allowName = true;\n                }\n                break;\n            default:\n                if (node.state) {\n                    if (node.state.allowType) {\n                        node.type += c;\n                        node.state.allowParams = true;\n                        node.state.allowArray = true;\n                    }\n                    else if (node.state.allowName) {\n                        node.name += c;\n                        delete node.state.allowArray;\n                    }\n                    else if (node.state.readArray) {\n                        node.type += c;\n                    }\n                    else {\n                        throwError(i);\n                    }\n                }\n        }\n    }\n    if (node.parent) {\n        throw new Error('unexpected eof');\n    }\n    delete parent.state;\n    if (allowIndexed && node.name === 'indexed') {\n        node.indexed = true;\n        node.name = '';\n    }\n    if (parent.type) {\n        parent.type = verifyType(parent.type);\n    }\n    return parent;\n}\n// @TODO: Better return type\n/** @hidden */\nfunction parseSignatureEvent(fragment) {\n    var abi = {\n        anonymous: false,\n        inputs: [],\n        name: '',\n        type: 'event',\n    };\n    var match = fragment.match(regexParen);\n    if (!match) {\n        throw new Error('invalid event: ' + fragment);\n    }\n    abi.name = match[1].trim();\n    splitNesting(match[2]).forEach(function (param) {\n        param = parseParam(param, true);\n        param.indexed = !!param.indexed;\n        abi.inputs.push(param);\n    });\n    match[3].split(' ').forEach(function (modifier) {\n        switch (modifier) {\n            case 'anonymous':\n                abi.anonymous = true;\n                break;\n            case '':\n                break;\n            default:\n                crypto_1.info('unknown modifier: ' + modifier);\n        }\n    });\n    if (abi.name && !abi.name.match(regexIdentifier)) {\n        throw new Error('invalid identifier: \"' + abi.name + '\"');\n    }\n    return abi;\n}\n/** @hidden */\nfunction parseParamType(type) {\n    return parseParam(type, true);\n}\nexports.parseParamType = parseParamType;\n// @TODO: Allow a second boolean to expose names\n/** @hidden */\nfunction formatParamType(paramType) {\n    return getParamCoder(exports.defaultCoerceFunc, paramType).type;\n}\nexports.formatParamType = formatParamType;\n/** @hidden */\nfunction parseSignatureFunction(fragment) {\n    var abi = {\n        constant: false,\n        gas: null,\n        inputs: [],\n        name: '',\n        outputs: [],\n        payable: false,\n        stateMutability: null,\n        type: 'function',\n    };\n    var comps = fragment.split('@');\n    if (comps.length !== 1) {\n        if (comps.length > 2) {\n            throw new Error('invalid signature');\n        }\n        if (!comps[1].match(/^[0-9]+$/)) {\n            throw new Error('invalid signature gas');\n        }\n        abi.gas = new crypto_1.BN(comps[1]);\n        fragment = comps[0];\n    }\n    comps = fragment.split(' returns ');\n    var left = comps[0].match(regexParen);\n    if (!left) {\n        throw new Error('invalid signature');\n    }\n    abi.name = left[1].trim();\n    if (!abi.name.match(regexIdentifier)) {\n        throw new Error('invalid identifier: \"' + left[1] + '\"');\n    }\n    splitNesting(left[2]).forEach(function (param) {\n        abi.inputs.push(parseParam(param));\n    });\n    left[3].split(' ').forEach(function (modifier) {\n        switch (modifier) {\n            case 'constant':\n                abi.constant = true;\n                break;\n            case 'payable':\n                abi.payable = true;\n                abi.stateMutability = 'payable';\n                break;\n            case 'pure':\n                abi.constant = true;\n                abi.stateMutability = 'pure';\n                break;\n            case 'view':\n                abi.constant = true;\n                abi.stateMutability = 'view';\n                break;\n            case 'external':\n            case 'public':\n            case '':\n                break;\n            default:\n                crypto_1.info('unknown modifier: ' + modifier);\n        }\n    });\n    // We have outputs\n    if (comps.length > 1) {\n        var right = comps[1].match(regexParen);\n        if (right === null || right[1].trim() !== '' || right[3].trim() !== '') {\n            throw new Error('unexpected tokens');\n        }\n        splitNesting(right[2]).forEach(function (param) {\n            abi.outputs.push(parseParam(param));\n        });\n    }\n    if (abi.name === 'constructor') {\n        abi.type = 'constructor';\n        if (abi.outputs.length) {\n            throw new Error('constructor may not have outputs');\n        }\n        delete abi.name;\n        delete abi.outputs;\n    }\n    return abi;\n}\n// @TODO: Allow a second boolean to expose names and modifiers\n/** @hidden */\nfunction formatSignature(fragment) {\n    return fragment.name + '(' + fragment.inputs.map(function (i) { return formatParamType(i); }).join(',') + ')';\n}\nexports.formatSignature = formatSignature;\n/** @hidden */\nfunction parseSignature(fragment) {\n    if (typeof fragment === 'string') {\n        // Make sure the \"returns\" is surrounded by a space and all whitespace is exactly one space\n        fragment = fragment.replace(/\\s/g, ' ');\n        fragment = fragment\n            .replace(/\\(/g, ' (')\n            .replace(/\\)/g, ') ')\n            .replace(/\\s+/g, ' ');\n        fragment = fragment.trim();\n        if (fragment.substring(0, 6) === 'event ') {\n            return parseSignatureEvent(fragment.substring(6).trim());\n        }\n        else {\n            if (fragment.substring(0, 9) === 'function ') {\n                fragment = fragment.substring(9);\n            }\n            return parseSignatureFunction(fragment.trim());\n        }\n    }\n    throw new Error('unknown signature');\n}\nexports.parseSignature = parseSignature;\n/** @hidden */\nvar Coder = /** @class */ (function () {\n    function Coder(coerceFunc, name, type, localName, dynamic) {\n        this.coerceFunc = coerceFunc;\n        this.name = name;\n        this.type = type;\n        this.localName = localName;\n        this.dynamic = dynamic;\n    }\n    return Coder;\n}());\n// Clones the functionality of an existing Coder, but without a localName\n// tslint:disable-next-line: max-classes-per-file\n/** @hidden */\nvar CoderAnonymous = /** @class */ (function (_super) {\n    tslib_1.__extends(CoderAnonymous, _super);\n    function CoderAnonymous(coder) {\n        var _this = _super.call(this, coder.coerceFunc, coder.name, coder.type, undefined, coder.dynamic) || this;\n        _this.coder = coder;\n        return _this;\n    }\n    CoderAnonymous.prototype.encode = function (value) {\n        return this.coder.encode(value);\n    };\n    CoderAnonymous.prototype.decode = function (data, offset) {\n        return this.coder.decode(data, offset);\n    };\n    return CoderAnonymous;\n}(Coder));\n// tslint:disable-next-line: max-classes-per-file\n/** @hidden */\nvar CoderNull = /** @class */ (function (_super) {\n    tslib_1.__extends(CoderNull, _super);\n    function CoderNull(coerceFunc, localName) {\n        return _super.call(this, coerceFunc, 'null', '', localName, false) || this;\n    }\n    CoderNull.prototype.encode = function (value) {\n        var result = crypto_1.arrayify([]) || new Uint8Array();\n        return result;\n    };\n    CoderNull.prototype.decode = function (data, offset) {\n        if (offset > data.length) {\n            throw new Error('invalid null');\n        }\n        return {\n            consumed: 0,\n            value: this.coerceFunc('null', undefined),\n        };\n    };\n    return CoderNull;\n}(Coder));\n// tslint:disable-next-line: max-classes-per-file\n/** @hidden */\nvar CoderNumber = /** @class */ (function (_super) {\n    tslib_1.__extends(CoderNumber, _super);\n    function CoderNumber(coerceFunc, size, signed, localName) {\n        var _this = this;\n        var name = (signed ? 'int' : 'uint') + size * 8;\n        _this = _super.call(this, coerceFunc, name, name, localName, false) || this;\n        _this.size = size;\n        _this.signed = signed;\n        return _this;\n    }\n    CoderNumber.prototype.encode = function (value) {\n        var result;\n        try {\n            var v = void 0;\n            if (typeof value == 'string' && value.startsWith('0x')) {\n                v = new crypto_1.BN(value.slice(2), 'hex');\n            }\n            else {\n                v = new crypto_1.BN(value);\n            }\n            if (this.signed) {\n                var bounds = MaxUint256.maskn(this.size * 8 - 1);\n                if (v.gt(bounds)) {\n                    throw new Error('out-of-bounds');\n                }\n                bounds = bounds.add(One).mul(NegativeOne);\n                if (v.lt(bounds)) {\n                    throw new Error('out-of-bounds');\n                }\n            }\n            else if (v.lt(Zero) || v.gt(MaxUint256.maskn(this.size * 8))) {\n                throw new Error('out-of-bounds');\n            }\n            v = v.toTwos(this.size * 8).maskn(this.size * 8);\n            if (this.signed) {\n                v = v.fromTwos(this.size * 8).toTwos(256);\n            }\n            var vString = v.toString('hex');\n            result = crypto_1.padZeros(crypto_1.arrayify(\"0x\" + vString) || new Uint8Array(), 32);\n        }\n        catch (error) {\n            crypto_1.throwError('invalid number value', crypto_1.INVALID_ARGUMENT, {\n                arg: this.localName,\n                coderType: this.name,\n                value: value,\n            });\n        }\n        return result || crypto_1.padZeros(new Uint8Array(), 32);\n    };\n    CoderNumber.prototype.decode = function (data, offset) {\n        if (data.length < offset + 32) {\n            crypto_1.throwError('insufficient data for ' + this.name + ' type', crypto_1.INVALID_ARGUMENT, {\n                arg: this.localName,\n                coderType: this.name,\n                value: crypto_1.hexlify(data.slice(offset, offset + 32)),\n            });\n        }\n        var junkLength = 32 - this.size;\n        var dataValue = crypto_1.hexlify(data.slice(offset + junkLength, offset + 32));\n        var value = utils_1.hexToBN(dataValue);\n        // tslint:disable-next-line: prefer-conditional-expression\n        if (this.signed) {\n            value = value.fromTwos(this.size * 8);\n        }\n        else {\n            value = value.maskn(this.size * 8);\n        }\n        return {\n            consumed: 32,\n            value: this.coerceFunc(this.name, value),\n        };\n    };\n    return CoderNumber;\n}(Coder));\n/** @hidden */\nvar uint256Coder = new CoderNumber(function (type, value) {\n    return value;\n}, 32, false, 'none');\n// tslint:disable-next-line: max-classes-per-file\n/** @hidden */\nvar CoderBoolean = /** @class */ (function (_super) {\n    tslib_1.__extends(CoderBoolean, _super);\n    function CoderBoolean(coerceFunc, localName) {\n        return _super.call(this, coerceFunc, 'bool', 'bool', localName, false) || this;\n    }\n    CoderBoolean.prototype.encode = function (value) {\n        return uint256Coder.encode(!!value ? new crypto_1.BN(1) : new crypto_1.BN(0));\n    };\n    CoderBoolean.prototype.decode = function (data, offset) {\n        var result;\n        try {\n            result = uint256Coder.decode(data, offset);\n        }\n        catch (error) {\n            if (error.reason === 'insufficient data for uint256 type') {\n                crypto_1.throwError('insufficient data for boolean type', crypto_1.INVALID_ARGUMENT, {\n                    arg: this.localName,\n                    coderType: 'boolean',\n                    value: error.value,\n                });\n            }\n            throw error;\n        }\n        return {\n            consumed: result.consumed,\n            value: this.coerceFunc('bool', !result.value.isZero()),\n        };\n    };\n    return CoderBoolean;\n}(Coder));\n// tslint:disable-next-line: max-classes-per-file\n/** @hidden */\nvar CoderFixedBytes = /** @class */ (function (_super) {\n    tslib_1.__extends(CoderFixedBytes, _super);\n    function CoderFixedBytes(coerceFunc, length, localName) {\n        var _this = this;\n        var name = 'bytes' + length;\n        _this = _super.call(this, coerceFunc, name, name, localName, false) || this;\n        _this.length = length;\n        return _this;\n    }\n    CoderFixedBytes.prototype.encode = function (value) {\n        var result = new Uint8Array(this.length);\n        try {\n            var arrayied = crypto_1.arrayify(value);\n            var data = null;\n            if (arrayied !== null) {\n                var valueToByte = crypto_1.hexlify(arrayied);\n                data = crypto_1.arrayify(crypto_1.bytesPadRight(valueToByte, this.length));\n            }\n            else {\n                throw new Error('cannot arraify data');\n            }\n            if (data === null || data.length !== this.length) {\n                throw new Error('incorrect data length');\n            }\n            result.set(data);\n        }\n        catch (error) {\n            crypto_1.throwError('invalid ' + this.name + ' value', crypto_1.INVALID_ARGUMENT, {\n                arg: this.localName,\n                coderType: this.name,\n                value: error.value || value,\n            });\n        }\n        return result;\n    };\n    CoderFixedBytes.prototype.decode = function (data, offset) {\n        if (data.length < offset + 32) {\n            crypto_1.throwError('insufficient data for ' + name + ' type', crypto_1.INVALID_ARGUMENT, {\n                arg: this.localName,\n                coderType: this.name,\n                value: crypto_1.hexlify(data.slice(offset, offset + 32)),\n            });\n        }\n        return {\n            consumed: 32,\n            value: this.coerceFunc(this.name, crypto_1.hexlify(data.slice(offset, offset + this.length))),\n        };\n    };\n    return CoderFixedBytes;\n}(Coder));\n// tslint:disable-next-line: max-classes-per-file\n/** @hidden */\nvar CoderAddress = /** @class */ (function (_super) {\n    tslib_1.__extends(CoderAddress, _super);\n    function CoderAddress(coerceFunc, localName) {\n        return _super.call(this, coerceFunc, 'address', 'address', localName, false) || this;\n    }\n    CoderAddress.prototype.encode = function (value) {\n        var result = new Uint8Array(32);\n        try {\n            var addr = crypto_1.arrayify(crypto_1.toChecksumAddress(value)) || new Uint8Array();\n            result.set(addr, 12);\n        }\n        catch (error) {\n            crypto_1.throwError('invalid address', crypto_1.INVALID_ARGUMENT, {\n                arg: this.localName,\n                coderType: 'address',\n                value: value,\n            });\n        }\n        return result;\n    };\n    CoderAddress.prototype.decode = function (data, offset) {\n        if (data.length < offset + 32) {\n            crypto_1.throwError('insufficuent data for address type', crypto_1.INVALID_ARGUMENT, {\n                arg: this.localName,\n                coderType: 'address',\n                value: crypto_1.hexlify(data.slice(offset, offset + 32)),\n            });\n        }\n        return {\n            consumed: 32,\n            value: this.coerceFunc('address', crypto_1.toChecksumAddress(crypto_1.hexlify(data.slice(offset + 12, offset + 32)))),\n        };\n    };\n    return CoderAddress;\n}(Coder));\n/** @hidden */\nfunction _encodeDynamicBytes(value) {\n    var dataLength = 32 * Math.ceil(value.length / 32);\n    var padding = new Uint8Array(dataLength - value.length);\n    return crypto_1.concat([uint256Coder.encode(new crypto_1.BN(value.length)), value, padding]);\n}\n/** @hidden */\nfunction _decodeDynamicBytes(data, offset, localName) {\n    if (data.length < offset + 32) {\n        crypto_1.throwError('insufficient data for dynamicBytes length', crypto_1.INVALID_ARGUMENT, {\n            arg: localName,\n            coderType: 'dynamicBytes',\n            value: crypto_1.hexlify(data.slice(offset, offset + 32)),\n        });\n    }\n    var length = uint256Coder.decode(data, offset).value;\n    try {\n        length = length.toNumber();\n    }\n    catch (error) {\n        crypto_1.throwError('dynamic bytes count too large', crypto_1.INVALID_ARGUMENT, {\n            arg: localName,\n            coderType: 'dynamicBytes',\n            value: length.toString(),\n        });\n    }\n    if (data.length < offset + 32 + length) {\n        crypto_1.throwError('insufficient data for dynamicBytes type', crypto_1.INVALID_ARGUMENT, {\n            arg: localName,\n            coderType: 'dynamicBytes',\n            value: crypto_1.hexlify(data.slice(offset, offset + 32 + length)),\n        });\n    }\n    return {\n        consumed: 32 + 32 * Math.ceil(length / 32),\n        value: data.slice(offset + 32, offset + 32 + length),\n    };\n}\n// tslint:disable-next-line: max-classes-per-file\n/** @hidden */\nvar CoderDynamicBytes = /** @class */ (function (_super) {\n    tslib_1.__extends(CoderDynamicBytes, _super);\n    function CoderDynamicBytes(coerceFunc, localName) {\n        return _super.call(this, coerceFunc, 'bytes', 'bytes', localName, true) || this;\n    }\n    CoderDynamicBytes.prototype.encode = function (value) {\n        var result = new Uint8Array();\n        try {\n            result = _encodeDynamicBytes(crypto_1.arrayify(value) || new Uint8Array());\n        }\n        catch (error) {\n            crypto_1.throwError('invalid bytes value', crypto_1.INVALID_ARGUMENT, {\n                arg: this.localName,\n                coderType: 'bytes',\n                value: error.value,\n            });\n        }\n        return result;\n    };\n    CoderDynamicBytes.prototype.decode = function (data, offset) {\n        var result = _decodeDynamicBytes(data, offset, this.localName || '');\n        result.value = this.coerceFunc('bytes', crypto_1.hexlify(result.value));\n        return result;\n    };\n    return CoderDynamicBytes;\n}(Coder));\n// tslint:disable-next-line: max-classes-per-file\n/** @hidden */\nvar CoderString = /** @class */ (function (_super) {\n    tslib_1.__extends(CoderString, _super);\n    function CoderString(coerceFunc, localName) {\n        return _super.call(this, coerceFunc, 'string', 'string', localName, true) || this;\n    }\n    CoderString.prototype.encode = function (value) {\n        if (typeof value !== 'string') {\n            crypto_1.throwError('invalid string value', crypto_1.INVALID_ARGUMENT, {\n                arg: this.localName,\n                coderType: 'string',\n                value: value,\n            });\n        }\n        return _encodeDynamicBytes(toUtf8Bytes(value));\n    };\n    CoderString.prototype.decode = function (data, offset) {\n        var result = _decodeDynamicBytes(data, offset, this.localName || '');\n        result.value = this.coerceFunc('string', toUtf8String(result.value));\n        return result;\n    };\n    return CoderString;\n}(Coder));\n/** @hidden */\nfunction alignSize(size) {\n    return 32 * Math.ceil(size / 32);\n}\n/** @hidden */\nfunction pack(coders, values) {\n    if (Array.isArray(values)) {\n        // do nothing\n    }\n    else if (values && typeof values === 'object') {\n        var arrayValues_1 = [];\n        coders.forEach(function (coder) {\n            arrayValues_1.push(values[coder.localName || '']);\n        });\n        values = arrayValues_1;\n    }\n    else {\n        crypto_1.throwError('invalid tuple value', crypto_1.INVALID_ARGUMENT, {\n            coderType: 'tuple',\n            value: values,\n        });\n    }\n    if (coders.length !== values.length) {\n        crypto_1.throwError('types/value length mismatch', crypto_1.INVALID_ARGUMENT, {\n            coderType: 'tuple',\n            value: values,\n        });\n    }\n    var parts = [];\n    coders.forEach(function (coder, index) {\n        parts.push({ dynamic: coder.dynamic, value: coder.encode(values[index]) });\n    });\n    var staticSize = 0;\n    var dynamicSize = 0;\n    parts.forEach(function (part) {\n        if (part.dynamic) {\n            staticSize += 32;\n            dynamicSize += alignSize(part.value.length);\n        }\n        else {\n            staticSize += alignSize(part.value.length);\n            // todo : is it to be static size not alignSize?\n        }\n    });\n    var offset = 0;\n    var dynamicOffset = staticSize;\n    var data = new Uint8Array(staticSize + dynamicSize);\n    parts.forEach(function (part) {\n        if (part.dynamic) {\n            // uint256Coder.encode(dynamicOffset).copy(data, offset);\n            data.set(uint256Coder.encode(new crypto_1.BN(dynamicOffset)), offset);\n            offset += 32;\n            // part.value.copy(data, dynamicOffset);  @TODO\n            data.set(part.value, dynamicOffset);\n            dynamicOffset += alignSize(part.value.length);\n        }\n        else {\n            // part.value.copy(data, offset);  @TODO\n            data.set(part.value, offset);\n            offset += alignSize(part.value.length);\n        }\n    });\n    return data;\n}\n/** @hidden */\nfunction unpack(coders, data, offset) {\n    var baseOffset = offset;\n    var consumed = 0;\n    var value = [];\n    coders.forEach(function (coder) {\n        var result;\n        if (coder.dynamic) {\n            var dynamicOffset = uint256Coder.decode(data, offset);\n            result = coder.decode(data, baseOffset + dynamicOffset.value.toNumber());\n            // The dynamic part is leap-frogged somewhere else; doesn't count towards size\n            result.consumed = dynamicOffset.consumed;\n        }\n        else {\n            result = coder.decode(data, offset);\n        }\n        if (result.value !== undefined) {\n            value.push(result.value);\n        }\n        offset += result.consumed;\n        consumed += result.consumed;\n    });\n    coders.forEach(function (coder, index) {\n        var name = coder.localName;\n        if (!name) {\n            return;\n        }\n        if (name === 'length') {\n            name = '_length';\n        }\n        if (value[name] != null) {\n            return;\n        }\n        value[name] = value[index];\n    });\n    return {\n        value: value,\n        consumed: consumed,\n    };\n}\n// tslint:disable-next-line: max-classes-per-file\n/** @hidden */\nvar CoderArray = /** @class */ (function (_super) {\n    tslib_1.__extends(CoderArray, _super);\n    function CoderArray(coerceFunc, coder, length, localName) {\n        var _this = this;\n        var type = coder.type + '[' + (length >= 0 ? length : '') + ']';\n        var dynamic = length === -1 || coder.dynamic;\n        _this = _super.call(this, coerceFunc, 'array', type, localName, dynamic) || this;\n        _this.coder = coder;\n        _this.length = length;\n        return _this;\n    }\n    CoderArray.prototype.encode = function (value) {\n        if (!Array.isArray(value)) {\n            crypto_1.throwError('expected array value', crypto_1.INVALID_ARGUMENT, {\n                arg: this.localName,\n                coderType: 'array',\n                value: value,\n            });\n        }\n        var count = this.length;\n        var result = new Uint8Array(0);\n        if (count === -1) {\n            count = value.length;\n            result = uint256Coder.encode(new crypto_1.BN(count));\n        }\n        crypto_1.checkArgumentCount(count, value.length, ' in coder array' + (this.localName ? ' ' + this.localName : ''));\n        var coders = [];\n        // tslint:disable-next-line: prefer-for-of\n        for (var i = 0; i < value.length; i++) {\n            coders.push(this.coder);\n        }\n        return crypto_1.concat([result, pack(coders, value)]);\n    };\n    CoderArray.prototype.decode = function (data, offset) {\n        // @TODO:\n        // if (data.length < offset + length * 32) { throw new Error('invalid array'); }\n        var consumed = 0;\n        var count = this.length;\n        var decodedLength = { consumed: 0, value: undefined };\n        if (count === -1) {\n            try {\n                decodedLength = uint256Coder.decode(data, offset);\n            }\n            catch (error) {\n                crypto_1.throwError('insufficient data for dynamic array length', crypto_1.INVALID_ARGUMENT, {\n                    arg: this.localName,\n                    coderType: 'array',\n                    value: error.value,\n                });\n            }\n            try {\n                count = decodedLength.value.toNumber();\n            }\n            catch (error) {\n                crypto_1.throwError('array count too large', crypto_1.INVALID_ARGUMENT, {\n                    arg: this.localName,\n                    coderType: 'array',\n                    value: decodedLength.value.toString(),\n                });\n            }\n            consumed += decodedLength.consumed;\n            offset += decodedLength.consumed;\n        }\n        var coders = [];\n        for (var i = 0; i < count; i++) {\n            coders.push(new CoderAnonymous(this.coder));\n        }\n        var result = unpack(coders, data, offset);\n        result.consumed += consumed;\n        result.value = this.coerceFunc(this.type, result.value);\n        return result;\n    };\n    return CoderArray;\n}(Coder));\n// tslint:disable-next-line: max-classes-per-file\n/** @hidden */\nvar CoderTuple = /** @class */ (function (_super) {\n    tslib_1.__extends(CoderTuple, _super);\n    function CoderTuple(coerceFunc, coders, localName) {\n        var _this = this;\n        var dynamic = false;\n        var types = [];\n        coders.forEach(function (coder) {\n            if (coder.dynamic) {\n                dynamic = true;\n            }\n            types.push(coder.type);\n        });\n        var type = 'tuple(' + types.join(',') + ')';\n        _this = _super.call(this, coerceFunc, 'tuple', type, localName, dynamic) || this;\n        _this.coders = coders;\n        return _this;\n    }\n    CoderTuple.prototype.encode = function (value) {\n        return pack(this.coders, value);\n    };\n    CoderTuple.prototype.decode = function (data, offset) {\n        var result = unpack(this.coders, data, offset);\n        result.value = this.coerceFunc(this.type, result.value);\n        return result;\n    };\n    return CoderTuple;\n}(Coder));\n/** @hidden */\nfunction splitNesting(value) {\n    value = value.trim();\n    var result = [];\n    var accum = '';\n    var depth = 0;\n    // tslint:disable-next-line: prefer-for-of\n    for (var offset = 0; offset < value.length; offset++) {\n        var c = value[offset];\n        if (c === ',' && depth === 0) {\n            result.push(accum);\n            accum = '';\n        }\n        else {\n            accum += c;\n            if (c === '(') {\n                depth++;\n            }\n            else if (c === ')') {\n                depth--;\n                if (depth === -1) {\n                    throw new Error('unbalanced parenthsis');\n                }\n            }\n        }\n    }\n    if (accum) {\n        result.push(accum);\n    }\n    return result;\n}\n// @TODO: Is there a way to return \"class\"?\n/** @hidden */\nvar paramTypeSimple = {\n    address: CoderAddress,\n    bool: CoderBoolean,\n    string: CoderString,\n    bytes: CoderDynamicBytes,\n};\n/** @hidden */\nfunction getTupleParamCoder(coerceFunc, components, localName) {\n    if (!components) {\n        components = [];\n    }\n    var coders = [];\n    components.forEach(function (component) {\n        coders.push(getParamCoder(coerceFunc, component));\n    });\n    return new CoderTuple(coerceFunc, coders, localName);\n}\n/** @hidden */\nfunction getParamCoder(coerceFunc, param) {\n    var coder = paramTypeSimple[param.type];\n    if (coder) {\n        return new coder(coerceFunc, param.name);\n    }\n    var matcher = param.type.match(paramTypeNumber);\n    if (matcher) {\n        var size = parseInt(matcher[2] || '256', 10);\n        if (size === 0 || size > 256 || size % 8 !== 0) {\n            crypto_1.throwError('invalid ' + matcher[1] + ' bit length', crypto_1.INVALID_ARGUMENT, {\n                arg: 'param',\n                value: param,\n            });\n        }\n        return new CoderNumber(coerceFunc, size / 8, matcher[1] === 'int', param.name || '');\n    }\n    var matcher2 = param.type.match(paramTypeBytes);\n    if (matcher2) {\n        var size = parseInt(matcher2[1], 10);\n        if (size === 0 || size > 32) {\n            crypto_1.throwError('invalid bytes length', crypto_1.INVALID_ARGUMENT, {\n                arg: 'param',\n                value: param,\n            });\n        }\n        return new CoderFixedBytes(coerceFunc, size, param.name || '');\n    }\n    var matcher3 = param.type.match(paramTypeArray);\n    if (matcher3) {\n        var size = parseInt(matcher3[2] || '-1', 10);\n        param = shallowCopy(param);\n        param.type = matcher3[1];\n        param = deepCopy(param);\n        return new CoderArray(coerceFunc, getParamCoder(coerceFunc, param), size, param.name || '');\n    }\n    if (param.type.substring(0, 5) === 'tuple') {\n        return getTupleParamCoder(coerceFunc, param.components || [], param.name || '');\n    }\n    if (param.type === '') {\n        return new CoderNull(coerceFunc, param.name || '');\n    }\n    crypto_1.throwError('invalid type', crypto_1.INVALID_ARGUMENT, {\n        arg: 'type',\n        value: param.type,\n    });\n}\n/** @hidden */\nvar UnicodeNormalizationForm;\n(function (UnicodeNormalizationForm) {\n    UnicodeNormalizationForm[\"current\"] = \"\";\n    UnicodeNormalizationForm[\"NFC\"] = \"NFC\";\n    UnicodeNormalizationForm[\"NFD\"] = \"NFD\";\n    UnicodeNormalizationForm[\"NFKC\"] = \"NFKC\";\n    UnicodeNormalizationForm[\"NFKD\"] = \"NFKD\";\n})(UnicodeNormalizationForm = exports.UnicodeNormalizationForm || (exports.UnicodeNormalizationForm = {}));\n/** @hidden */\nfunction toUtf8Bytes(str, form) {\n    if (form === void 0) { form = UnicodeNormalizationForm.current; }\n    if (form !== UnicodeNormalizationForm.current) {\n        crypto_1.checkNormalize();\n        str = str.normalize(form);\n    }\n    var result = [];\n    for (var i = 0; i < str.length; i++) {\n        var c = str.charCodeAt(i);\n        if (c < 0x80) {\n            result.push(c);\n        }\n        else if (c < 0x800) {\n            result.push((c >> 6) | 0xc0);\n            result.push((c & 0x3f) | 0x80);\n        }\n        else if ((c & 0xfc00) === 0xd800) {\n            i++;\n            var c2 = str.charCodeAt(i);\n            if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {\n                throw new Error('invalid utf-8 string');\n            }\n            // Surrogate Pair\n            c = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n            result.push((c >> 18) | 0xf0);\n            result.push(((c >> 12) & 0x3f) | 0x80);\n            result.push(((c >> 6) & 0x3f) | 0x80);\n            result.push((c & 0x3f) | 0x80);\n        }\n        else {\n            result.push((c >> 12) | 0xe0);\n            result.push(((c >> 6) & 0x3f) | 0x80);\n            result.push((c & 0x3f) | 0x80);\n        }\n    }\n    return crypto_1.arrayify(result) || new Uint8Array();\n}\nexports.toUtf8Bytes = toUtf8Bytes;\n// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\n/** @hidden */\nfunction toUtf8String(bytes, ignoreErrors) {\n    bytes = crypto_1.arrayify(bytes) || new Uint8Array();\n    var result = '';\n    var i = 0;\n    // Invalid bytes are ignored\n    while (i < bytes.length) {\n        var c = bytes[i++];\n        // 0xxx xxxx\n        if (c >> 7 === 0) {\n            result += String.fromCharCode(c);\n            continue;\n        }\n        // Multibyte; how many bytes left for this character?\n        var extraLength = null;\n        var overlongMask = null;\n        // 110x xxxx 10xx xxxx\n        if ((c & 0xe0) === 0xc0) {\n            extraLength = 1;\n            overlongMask = 0x7f;\n            // 1110 xxxx 10xx xxxx 10xx xxxx\n        }\n        else if ((c & 0xf0) === 0xe0) {\n            extraLength = 2;\n            overlongMask = 0x7ff;\n            // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n        }\n        else if ((c & 0xf8) === 0xf0) {\n            extraLength = 3;\n            overlongMask = 0xffff;\n        }\n        else {\n            if (!ignoreErrors) {\n                if ((c & 0xc0) === 0x80) {\n                    throw new Error('invalid utf8 byte sequence; unexpected continuation byte');\n                }\n                throw new Error('invalid utf8 byte sequence; invalid prefix');\n            }\n            continue;\n        }\n        // Do we have enough bytes in our data?\n        if (i + extraLength > bytes.length) {\n            if (!ignoreErrors) {\n                throw new Error('invalid utf8 byte sequence; too short');\n            }\n            // If there is an invalid unprocessed byte, skip continuation bytes\n            for (; i < bytes.length; i++) {\n                if (bytes[i] >> 6 !== 0x02) {\n                    break;\n                }\n            }\n            continue;\n        }\n        // Remove the length prefix from the char\n        var res = c & ((1 << (8 - extraLength - 1)) - 1);\n        for (var j = 0; j < extraLength; j++) {\n            var nextChar = bytes[i];\n            // Invalid continuation byte\n            if ((nextChar & 0xc0) !== 0x80) {\n                res = null;\n                break;\n            }\n            res = (res << 6) | (nextChar & 0x3f);\n            i++;\n        }\n        if (res === null) {\n            if (!ignoreErrors) {\n                throw new Error('invalid utf8 byte sequence; invalid continuation byte');\n            }\n            continue;\n        }\n        // Check for overlong seuences (more bytes than needed)\n        if (res <= overlongMask) {\n            if (!ignoreErrors) {\n                throw new Error('invalid utf8 byte sequence; overlong');\n            }\n            continue;\n        }\n        // Maximum code point\n        if (res > 0x10ffff) {\n            if (!ignoreErrors) {\n                throw new Error('invalid utf8 byte sequence; out-of-range');\n            }\n            continue;\n        }\n        // Reserved for UTF-16 surrogate halves\n        if (res >= 0xd800 && res <= 0xdfff) {\n            if (!ignoreErrors) {\n                throw new Error('invalid utf8 byte sequence; utf-16 surrogate');\n            }\n            continue;\n        }\n        if (res <= 0xffff) {\n            result += String.fromCharCode(res);\n            continue;\n        }\n        res -= 0x10000;\n        result += String.fromCharCode(((res >> 10) & 0x3ff) + 0xd800, (res & 0x3ff) + 0xdc00);\n    }\n    return result;\n}\nexports.toUtf8String = toUtf8String;\n/** @hidden */\nfunction formatBytes32String(text) {\n    // Get the bytes\n    var bytes = toUtf8Bytes(text);\n    // Check we have room for null-termination\n    if (bytes.length > 31) {\n        throw new Error('bytes32 string must be less than 32 bytes');\n    }\n    // Zero-pad (implicitly null-terminates)\n    return crypto_1.hexlify(crypto_1.concat([bytes, HashZero]).slice(0, 32));\n}\nexports.formatBytes32String = formatBytes32String;\n/** @hidden */\nfunction parseBytes32String(bytes) {\n    var data = crypto_1.arrayify(bytes) || new Uint8Array();\n    // Must be 32 bytes with a null-termination\n    if (data.length !== 32) {\n        throw new Error('invalid bytes32 - not 32 bytes long');\n    }\n    if (data[31] !== 0) {\n        throw new Error('invalid bytes32 sdtring - no null terminator');\n    }\n    // Find the null termination\n    var length = 31;\n    while (data[length - 1] === 0) {\n        length--;\n    }\n    // Determine the string value\n    return toUtf8String(data.slice(0, length));\n}\nexports.parseBytes32String = parseBytes32String;\n/** @hidden */\nfunction isType(object, type) {\n    return object && object._ethersType === type;\n}\nexports.isType = isType;\n/** @hidden */\nfunction shallowCopy(object) {\n    var result = {};\n    // tslint:disable-next-line: forin\n    for (var key in object) {\n        result[key] = object[key];\n    }\n    return result;\n}\nexports.shallowCopy = shallowCopy;\n/** @hidden */\nvar opaque = {\n    boolean: true,\n    number: true,\n    string: true,\n};\n/** @hidden */\nfunction deepCopy(object, frozen) {\n    // Opaque objects are not mutable, so safe to copy by assignment\n    if (object === undefined || object === null || opaque[typeof object]) {\n        return object;\n    }\n    // Arrays are mutable, so we need to create a copy\n    if (Array.isArray(object)) {\n        var result = object.map(function (item) { return deepCopy(item, frozen); });\n        if (frozen) {\n            Object.freeze(result);\n        }\n        return result;\n    }\n    if (typeof object === 'object') {\n        // Some internal objects, which are already immutable\n        if (isType(object, 'BigNumber')) {\n            return object;\n        }\n        if (isType(object, 'Description')) {\n            return object;\n        }\n        if (isType(object, 'Indexed')) {\n            return object;\n        }\n        var result = {};\n        // tslint:disable-next-line: forin\n        for (var key in object) {\n            var value = object[key];\n            if (value === undefined) {\n                continue;\n            }\n            utils_1.defineReadOnly(result, key, deepCopy(value, frozen));\n        }\n        if (frozen) {\n            Object.freeze(result);\n        }\n        return result;\n    }\n    // The function type is also immutable, so safe to copy by assignment\n    if (typeof object === 'function') {\n        return object;\n    }\n    throw new Error('Cannot deepCopy ' + typeof object);\n}\nexports.deepCopy = deepCopy;\n// tslint:disable-next-line: max-classes-per-file\n/** @hidden */\nvar AbiCoder = /** @class */ (function () {\n    function AbiCoder(coerceFunc) {\n        crypto_1.checkNew(this, AbiCoder);\n        if (!coerceFunc) {\n            coerceFunc = exports.defaultCoerceFunc;\n        }\n        this.coerceFunc = coerceFunc;\n    }\n    AbiCoder.prototype.encode = function (types, values) {\n        var _this = this;\n        if (types.length !== values.length) {\n            crypto_1.throwError('types/values length mismatch', crypto_1.INVALID_ARGUMENT, {\n                count: { types: types.length, values: values.length },\n                value: { types: types, values: values },\n            });\n        }\n        var coders = [];\n        types.forEach(function (type) {\n            // Convert types to type objects\n            //   - \"uint foo\" => { type: \"uint\", name: \"foo\" }\n            //   - \"tuple(uint, uint)\" => { type: \"tuple\", components: [ { type: \"uint\" }, { type: \"uint\" }, ] }\n            var typeObject = null;\n            // tslint:disable-next-line: prefer-conditional-expression\n            if (typeof type === 'string') {\n                typeObject = parseParam(type);\n            }\n            else {\n                typeObject = type;\n            }\n            coders.push(getParamCoder(_this.coerceFunc, typeObject));\n        }, this);\n        var encodedArray = new CoderTuple(this.coerceFunc, coders, '_').encode(values);\n        return crypto_1.hexlify(encodedArray);\n    };\n    AbiCoder.prototype.decode = function (types, data) {\n        var _this = this;\n        var coders = [];\n        types.forEach(function (type) {\n            // See encode for details\n            var typeObject = null;\n            // tslint:disable-next-line: prefer-conditional-expression\n            if (typeof type === 'string') {\n                typeObject = parseParam(type);\n            }\n            else {\n                typeObject = deepCopy(type);\n            }\n            coders.push(getParamCoder(_this.coerceFunc, typeObject));\n        }, this);\n        var result = new CoderTuple(this.coerceFunc, coders, '_').decode(crypto_1.arrayify(data) || new Uint8Array(), 0).value;\n        return result;\n    };\n    return AbiCoder;\n}());\nexports.AbiCoder = AbiCoder;\n/** @hidden */\nexports.defaultAbiCoder = new AbiCoder();\n//# sourceMappingURL=abiCoder.js.map"]},"metadata":{},"sourceType":"script"}