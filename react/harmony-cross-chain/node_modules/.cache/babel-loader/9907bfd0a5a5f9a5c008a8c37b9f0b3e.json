{"ast":null,"code":"\"use strict\";\n/**\n * @packageDocumentation\n * @module harmony-contract\n * @hidden\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toTopic = exports.inputAddressFormatter = exports.isPredefinedBlockNumber = exports.inputBlockNumberFormatter = exports.outputLogFormatter = exports.inputLogFormatter = void 0;\n\nvar crypto_1 = require(\"@harmony-js/crypto\");\n\nvar utils_1 = require(\"@harmony-js/utils\");\n\nvar abiCoder_1 = require(\"../abi/abiCoder\");\n\nexports.inputLogFormatter = function (options) {\n  if (options.fromBlock) {\n    options.fromBlock = exports.inputBlockNumberFormatter(options.fromBlock);\n  }\n\n  if (options.toBlock) {\n    options.toBlock = exports.inputBlockNumberFormatter(options.toBlock);\n  } // make sure topics, get converted to hex\n\n\n  options.topics = options.topics || [];\n  options.topics = options.topics.map(function (topic) {\n    return utils_1.isArray(topic) ? topic.map(exports.toTopic) : exports.toTopic(topic);\n  });\n\n  if (options.address) {\n    if (utils_1.isArray(options.address)) {\n      options.address = options.address.map(function (addr) {\n        return exports.inputAddressFormatter(addr);\n      });\n    } else {\n      options.address = exports.inputAddressFormatter(options.address);\n    }\n  }\n\n  return options;\n};\n/**\n * Formats the output of a log\n *\n * @method outputLogFormatter\n *\n * @param {Object} log object\n *\n * @returns {Object} log\n */\n\n\nexports.outputLogFormatter = function (log) {\n  // generate a custom log id\n  if (typeof log.blockHash === 'string' && typeof log.transactionHash === 'string' && typeof log.logIndex === 'string') {\n    var shaId = crypto_1.keccak256('0x' + log.blockHash.replace('0x', '') + log.transactionHash.replace('0x', '') + log.logIndex.replace('0x', ''));\n    shaId.replace('0x', '').substr(0, 8);\n    log.id = \"log_\" + shaId;\n  } else if (!log.id) {\n    log.id = null;\n  }\n\n  if (log.blockNumber !== null) {\n    log.blockNumber = utils_1.hexToBN(log.blockNumber).toNumber();\n  }\n\n  if (log.transactionIndex !== null) {\n    log.transactionIndex = utils_1.hexToBN(log.transactionIndex).toNumber();\n  }\n\n  if (log.logIndex !== null) {\n    log.logIndex = utils_1.hexToBN(log.logIndex).toNumber();\n  }\n\n  if (log.address) {\n    log.address = crypto_1.toChecksumAddress(log.address);\n  }\n\n  return log;\n};\n\nexports.inputBlockNumberFormatter = function (blockNumber) {\n  if (blockNumber === undefined || blockNumber === null || exports.isPredefinedBlockNumber(blockNumber)) {\n    return blockNumber;\n  }\n\n  if (crypto_1.isHexString(blockNumber)) {\n    if (utils_1.isString(blockNumber)) {\n      return blockNumber.toLowerCase();\n    }\n\n    return blockNumber;\n  }\n\n  return utils_1.numberToHex(blockNumber);\n};\n\nexports.isPredefinedBlockNumber = function (blockNumber) {\n  return blockNumber === 'latest' || blockNumber === 'pending' || blockNumber === 'earliest';\n};\n\nexports.inputAddressFormatter = function (address) {\n  if (utils_1.isAddress(address)) {\n    return \"0x\" + address.toLowerCase().replace('0x', '');\n  }\n\n  throw new Error(\"Provided address \\\"\" + address + \"\\\" is invalid, the capitalization checksum test failed, or its an indrect IBAN address which can't be converted.\");\n};\n\nexports.toTopic = function (value) {\n  if (value === null || typeof value === 'undefined') {\n    return null;\n  }\n\n  value = String(value);\n\n  if (value.indexOf('0x') === 0) {\n    return value;\n  }\n\n  return crypto_1.hexlify(abiCoder_1.toUtf8Bytes(value));\n};","map":{"version":3,"sources":["../../src/utils/formatter.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n * @packageDocumentation\n * @module harmony-contract\n * @hidden\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toTopic = exports.inputAddressFormatter = exports.isPredefinedBlockNumber = exports.inputBlockNumberFormatter = exports.outputLogFormatter = exports.inputLogFormatter = void 0;\nvar crypto_1 = require(\"@harmony-js/crypto\");\nvar utils_1 = require(\"@harmony-js/utils\");\nvar abiCoder_1 = require(\"../abi/abiCoder\");\nexports.inputLogFormatter = function (options) {\n    if (options.fromBlock) {\n        options.fromBlock = exports.inputBlockNumberFormatter(options.fromBlock);\n    }\n    if (options.toBlock) {\n        options.toBlock = exports.inputBlockNumberFormatter(options.toBlock);\n    }\n    // make sure topics, get converted to hex\n    options.topics = options.topics || [];\n    options.topics = options.topics.map(function (topic) {\n        return utils_1.isArray(topic) ? topic.map(exports.toTopic) : exports.toTopic(topic);\n    });\n    if (options.address) {\n        if (utils_1.isArray(options.address)) {\n            options.address = options.address.map(function (addr) {\n                return exports.inputAddressFormatter(addr);\n            });\n        }\n        else {\n            options.address = exports.inputAddressFormatter(options.address);\n        }\n    }\n    return options;\n};\n/**\n * Formats the output of a log\n *\n * @method outputLogFormatter\n *\n * @param {Object} log object\n *\n * @returns {Object} log\n */\nexports.outputLogFormatter = function (log) {\n    // generate a custom log id\n    if (typeof log.blockHash === 'string' &&\n        typeof log.transactionHash === 'string' &&\n        typeof log.logIndex === 'string') {\n        var shaId = crypto_1.keccak256('0x' +\n            log.blockHash.replace('0x', '') +\n            log.transactionHash.replace('0x', '') +\n            log.logIndex.replace('0x', ''));\n        shaId.replace('0x', '').substr(0, 8);\n        log.id = \"log_\" + shaId;\n    }\n    else if (!log.id) {\n        log.id = null;\n    }\n    if (log.blockNumber !== null) {\n        log.blockNumber = utils_1.hexToBN(log.blockNumber).toNumber();\n    }\n    if (log.transactionIndex !== null) {\n        log.transactionIndex = utils_1.hexToBN(log.transactionIndex).toNumber();\n    }\n    if (log.logIndex !== null) {\n        log.logIndex = utils_1.hexToBN(log.logIndex).toNumber();\n    }\n    if (log.address) {\n        log.address = crypto_1.toChecksumAddress(log.address);\n    }\n    return log;\n};\nexports.inputBlockNumberFormatter = function (blockNumber) {\n    if (blockNumber === undefined || blockNumber === null || exports.isPredefinedBlockNumber(blockNumber)) {\n        return blockNumber;\n    }\n    if (crypto_1.isHexString(blockNumber)) {\n        if (utils_1.isString(blockNumber)) {\n            return blockNumber.toLowerCase();\n        }\n        return blockNumber;\n    }\n    return utils_1.numberToHex(blockNumber);\n};\nexports.isPredefinedBlockNumber = function (blockNumber) {\n    return blockNumber === 'latest' || blockNumber === 'pending' || blockNumber === 'earliest';\n};\nexports.inputAddressFormatter = function (address) {\n    if (utils_1.isAddress(address)) {\n        return \"0x\" + address.toLowerCase().replace('0x', '');\n    }\n    throw new Error(\"Provided address \\\"\" + address + \"\\\" is invalid, the capitalization checksum test failed, or its an indrect IBAN address which can't be converted.\");\n};\nexports.toTopic = function (value) {\n    if (value === null || typeof value === 'undefined') {\n        return null;\n    }\n    value = String(value);\n    if (value.indexOf('0x') === 0) {\n        return value;\n    }\n    return crypto_1.hexlify(abiCoder_1.toUtf8Bytes(value));\n};\n//# sourceMappingURL=formatter.js.map"]},"metadata":{},"sourceType":"script"}