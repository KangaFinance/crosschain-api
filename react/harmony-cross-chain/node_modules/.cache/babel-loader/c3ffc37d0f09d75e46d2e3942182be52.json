{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.HmyMethodsERC20 = void 0;\n\nconst tslib_1 = require(\"tslib\");\n\nconst utils_1 = require(\"../utils\");\n\nconst MyERC20_1 = tslib_1.__importDefault(require(\"../out/MyERC20\"));\n\nconst helpers_1 = require(\"./helpers\");\n\nclass HmyMethodsERC20 {\n  constructor(params) {\n    this.options = {\n      gasPrice: 1000000000,\n      gasLimit: 6721900\n    };\n    this.useOneWallet = false;\n    this.useMathWallet = false;\n\n    this.setUseMetamask = value => value;\n\n    this.setUseOneWallet = value => {\n      if (!window || !window.onewallet) {\n        throw new Error('OneWallet extension is not found');\n      }\n\n      this.useOneWallet = value;\n    };\n\n    this.setUseMathWallet = value => {\n      if (!window || !window.harmony) {\n        throw new Error('Math Wallet extension is not found');\n      }\n\n      this.useMathWallet = value;\n    };\n\n    this.approveHmyManger = (hrc20Address, amount, decimals, sendTxCallback) => {\n      const hmyTokenContract = this.hmy.contracts.createContract(MyERC20_1.default, hrc20Address);\n      return new Promise(async (resolve, reject) => {\n        try {\n          if (this.useOneWallet) {\n            await helpers_1.connectToBrowserWallet(window.onewallet, this.hmy, hmyTokenContract.wallet, null, reject);\n          }\n\n          if (this.useMathWallet) {\n            await helpers_1.connectToBrowserWallet(window.harmony, this.hmy, hmyTokenContract.wallet, null, reject);\n          }\n\n          const res = await hmyTokenContract.methods.approve(this.hmyManagerContract.address, utils_1.withDecimals(amount, decimals)).send(this.options).on('transactionHash', sendTxCallback);\n          resolve(res);\n        } catch (e) {\n          reject(e);\n        }\n      });\n    };\n\n    this.burnToken = async (hrc20Address, userAddr, amount, decimals, sendTxCallback) => {\n      return new Promise(async (resolve, reject) => {\n        try {\n          if (this.useOneWallet) {\n            await helpers_1.connectToBrowserWallet(window.onewallet, this.hmy, this.hmyManagerContract.wallet, null, reject);\n          }\n\n          if (this.useMathWallet) {\n            await helpers_1.connectToBrowserWallet(window.harmony, this.hmy, this.hmyManagerContract.wallet, null, reject);\n          }\n\n          const response = await this.hmyManagerContract.methods.burnToken(hrc20Address, utils_1.withDecimals(amount, decimals), userAddr).send(this.options).on('transactionHash', sendTxCallback);\n          resolve(response);\n        } catch (e) {\n          reject(e);\n        }\n      });\n    };\n\n    this.getMappingFor = async erc20TokenAddr => {\n      const res = await this.hmyManagerContract.methods.mappings(erc20TokenAddr).call(this.options);\n      return res;\n    };\n\n    this.checkHmyBalance = async (hrc20Address, addr) => {\n      const hmyTokenContract = this.hmy.contracts.createContract(MyERC20_1.default, hrc20Address);\n      const addrHex = this.hmy.crypto.getAddress(addr).checksum;\n      return await hmyTokenContract.methods.balanceOf(addrHex).call(this.options);\n    };\n\n    this.totalSupply = async hrc20Address => {\n      const hmyTokenContract = this.hmy.contracts.createContract(MyERC20_1.default, hrc20Address);\n      return await hmyTokenContract.methods.totalSupply().call(this.options);\n    };\n\n    this.setApprovalForAll = (hrc20Address, sendTxCallback) => {\n      const hmyTokenContract = this.hmy.contracts.createContract(MyERC20_1.default, hrc20Address);\n      return new Promise(async (resolve, reject) => {\n        try {\n          let hmyAddrHex;\n\n          if (this.useOneWallet) {\n            await helpers_1.connectToBrowserWallet(window.onewallet, this.hmy, this.hmyManagerContract.wallet, null, reject);\n            const {\n              address\n            } = await window.onewallet.getAccount();\n            hmyAddrHex = this.hmy.crypto.getAddress(address).checksum;\n          }\n\n          if (this.useMathWallet) {\n            await helpers_1.connectToBrowserWallet(window.harmony, this.hmy, this.hmyManagerContract.wallet, null, reject);\n            const {\n              address\n            } = await window.onewallet.getAccount();\n            hmyAddrHex = this.hmy.crypto.getAddress(address).checksum;\n          }\n\n          if (!this.useMathWallet && !this.useOneWallet) {\n            const address = this.hmy.wallet.accounts[0];\n            hmyAddrHex = this.hmy.crypto.getAddress(address).checksum;\n          }\n\n          let res = await hmyTokenContract.methods.isApprovedForAll(hmyAddrHex, this.hmyManagerContract.address).call(this.options);\n\n          if (!res) {\n            res = await hmyTokenContract.methods.setApprovalForAll(this.hmyManagerContract.address, true).send(this.options).on('transactionHash', sendTxCallback);\n            resolve(res);\n          } else {\n            sendTxCallback('skip');\n            resolve(res);\n          }\n        } catch (e) {\n          reject(e);\n        }\n      });\n    };\n\n    this.burnTokens = async (hrc20Address, userAddr, amount, sendTxCallback) => {\n      return new Promise(async (resolve, reject) => {\n        try {\n          if (this.useOneWallet) {\n            await helpers_1.connectToBrowserWallet(window.onewallet, this.hmy, this.hmyManagerContract.wallet, null, reject);\n          }\n\n          if (this.useMathWallet) {\n            await helpers_1.connectToBrowserWallet(window.harmony, this.hmy, this.hmyManagerContract.wallet, null, reject);\n          }\n\n          const userAddrHex = this.hmy.crypto.getAddress(userAddr).checksum;\n          const response = await this.hmyManagerContract.methods.burnTokens(hrc20Address, amount, userAddrHex).send(this.options).on('transactionHash', sendTxCallback);\n          resolve(response);\n        } catch (e) {\n          reject(e);\n        }\n      });\n    };\n\n    this.hmy = params.hmy;\n    this.hmyManagerContract = params.hmyManagerContract;\n\n    if (params.options) {\n      this.options = params.options;\n    }\n  }\n\n}\n\nexports.HmyMethodsERC20 = HmyMethodsERC20;","map":{"version":3,"sources":["/Users/borispolania/Documents/GitHub/crosschain-api/react/harmony-cross-chain/node_modules/bridge-sdk/lib/blockchain/hmy/HmyMethodsERC20.js"],"names":["Object","defineProperty","exports","value","HmyMethodsERC20","tslib_1","require","utils_1","MyERC20_1","__importDefault","helpers_1","constructor","params","options","gasPrice","gasLimit","useOneWallet","useMathWallet","setUseMetamask","setUseOneWallet","window","onewallet","Error","setUseMathWallet","harmony","approveHmyManger","hrc20Address","amount","decimals","sendTxCallback","hmyTokenContract","hmy","contracts","createContract","default","Promise","resolve","reject","connectToBrowserWallet","wallet","res","methods","approve","hmyManagerContract","address","withDecimals","send","on","e","burnToken","userAddr","response","getMappingFor","erc20TokenAddr","mappings","call","checkHmyBalance","addr","addrHex","crypto","getAddress","checksum","balanceOf","totalSupply","setApprovalForAll","hmyAddrHex","getAccount","accounts","isApprovedForAll","burnTokens","userAddrHex"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,eAAR,GAA0B,KAAK,CAA/B;;AACA,MAAMC,OAAO,GAAGC,OAAO,CAAC,OAAD,CAAvB;;AACA,MAAMC,OAAO,GAAGD,OAAO,CAAC,UAAD,CAAvB;;AACA,MAAME,SAAS,GAAGH,OAAO,CAACI,eAAR,CAAwBH,OAAO,CAAC,gBAAD,CAA/B,CAAlB;;AACA,MAAMI,SAAS,GAAGJ,OAAO,CAAC,WAAD,CAAzB;;AACA,MAAMF,eAAN,CAAsB;AAClBO,EAAAA,WAAW,CAACC,MAAD,EAAS;AAChB,SAAKC,OAAL,GAAe;AAAEC,MAAAA,QAAQ,EAAE,UAAZ;AAAwBC,MAAAA,QAAQ,EAAE;AAAlC,KAAf;AACA,SAAKC,YAAL,GAAoB,KAApB;AACA,SAAKC,aAAL,GAAqB,KAArB;;AACA,SAAKC,cAAL,GAAuBf,KAAD,IAAWA,KAAjC;;AACA,SAAKgB,eAAL,GAAwBhB,KAAD,IAAW;AAC9B,UAAI,CAACiB,MAAD,IAAW,CAACA,MAAM,CAACC,SAAvB,EAAkC;AAC9B,cAAM,IAAIC,KAAJ,CAAU,kCAAV,CAAN;AACH;;AACD,WAAKN,YAAL,GAAoBb,KAApB;AACH,KALD;;AAMA,SAAKoB,gBAAL,GAAyBpB,KAAD,IAAW;AAC/B,UAAI,CAACiB,MAAD,IAAW,CAACA,MAAM,CAACI,OAAvB,EAAgC;AAC5B,cAAM,IAAIF,KAAJ,CAAU,oCAAV,CAAN;AACH;;AACD,WAAKL,aAAL,GAAqBd,KAArB;AACH,KALD;;AAMA,SAAKsB,gBAAL,GAAwB,CAACC,YAAD,EAAeC,MAAf,EAAuBC,QAAvB,EAAiCC,cAAjC,KAAoD;AACxE,YAAMC,gBAAgB,GAAG,KAAKC,GAAL,CAASC,SAAT,CAAmBC,cAAnB,CAAkCzB,SAAS,CAAC0B,OAA5C,EAAqDR,YAArD,CAAzB;AACA,aAAO,IAAIS,OAAJ,CAAY,OAAOC,OAAP,EAAgBC,MAAhB,KAA2B;AAC1C,YAAI;AACA,cAAI,KAAKrB,YAAT,EAAuB;AACnB,kBAAMN,SAAS,CAAC4B,sBAAV,CAAiClB,MAAM,CAACC,SAAxC,EAAmD,KAAKU,GAAxD,EAA6DD,gBAAgB,CAACS,MAA9E,EAAsF,IAAtF,EAA4FF,MAA5F,CAAN;AACH;;AACD,cAAI,KAAKpB,aAAT,EAAwB;AACpB,kBAAMP,SAAS,CAAC4B,sBAAV,CAAiClB,MAAM,CAACI,OAAxC,EAAiD,KAAKO,GAAtD,EAA2DD,gBAAgB,CAACS,MAA5E,EAAoF,IAApF,EAA0FF,MAA1F,CAAN;AACH;;AACD,gBAAMG,GAAG,GAAG,MAAMV,gBAAgB,CAACW,OAAjB,CACbC,OADa,CACL,KAAKC,kBAAL,CAAwBC,OADnB,EAC4BrC,OAAO,CAACsC,YAAR,CAAqBlB,MAArB,EAA6BC,QAA7B,CAD5B,EAEbkB,IAFa,CAER,KAAKjC,OAFG,EAGbkC,EAHa,CAGV,iBAHU,EAGSlB,cAHT,CAAlB;AAIAO,UAAAA,OAAO,CAACI,GAAD,CAAP;AACH,SAZD,CAaA,OAAOQ,CAAP,EAAU;AACNX,UAAAA,MAAM,CAACW,CAAD,CAAN;AACH;AACJ,OAjBM,CAAP;AAkBH,KApBD;;AAqBA,SAAKC,SAAL,GAAiB,OAAOvB,YAAP,EAAqBwB,QAArB,EAA+BvB,MAA/B,EAAuCC,QAAvC,EAAiDC,cAAjD,KAAoE;AACjF,aAAO,IAAIM,OAAJ,CAAY,OAAOC,OAAP,EAAgBC,MAAhB,KAA2B;AAC1C,YAAI;AACA,cAAI,KAAKrB,YAAT,EAAuB;AACnB,kBAAMN,SAAS,CAAC4B,sBAAV,CAAiClB,MAAM,CAACC,SAAxC,EAAmD,KAAKU,GAAxD,EAA6D,KAAKY,kBAAL,CAAwBJ,MAArF,EAA6F,IAA7F,EAAmGF,MAAnG,CAAN;AACH;;AACD,cAAI,KAAKpB,aAAT,EAAwB;AACpB,kBAAMP,SAAS,CAAC4B,sBAAV,CAAiClB,MAAM,CAACI,OAAxC,EAAiD,KAAKO,GAAtD,EAA2D,KAAKY,kBAAL,CAAwBJ,MAAnF,EAA2F,IAA3F,EAAiGF,MAAjG,CAAN;AACH;;AACD,gBAAMc,QAAQ,GAAG,MAAM,KAAKR,kBAAL,CAAwBF,OAAxB,CAClBQ,SADkB,CACRvB,YADQ,EACMnB,OAAO,CAACsC,YAAR,CAAqBlB,MAArB,EAA6BC,QAA7B,CADN,EAC8CsB,QAD9C,EAElBJ,IAFkB,CAEb,KAAKjC,OAFQ,EAGlBkC,EAHkB,CAGf,iBAHe,EAGIlB,cAHJ,CAAvB;AAIAO,UAAAA,OAAO,CAACe,QAAD,CAAP;AACH,SAZD,CAaA,OAAOH,CAAP,EAAU;AACNX,UAAAA,MAAM,CAACW,CAAD,CAAN;AACH;AACJ,OAjBM,CAAP;AAkBH,KAnBD;;AAoBA,SAAKI,aAAL,GAAqB,MAAOC,cAAP,IAA0B;AAC3C,YAAMb,GAAG,GAAG,MAAM,KAAKG,kBAAL,CAAwBF,OAAxB,CAAgCa,QAAhC,CAAyCD,cAAzC,EAAyDE,IAAzD,CAA8D,KAAK1C,OAAnE,CAAlB;AACA,aAAO2B,GAAP;AACH,KAHD;;AAIA,SAAKgB,eAAL,GAAuB,OAAO9B,YAAP,EAAqB+B,IAArB,KAA8B;AACjD,YAAM3B,gBAAgB,GAAG,KAAKC,GAAL,CAASC,SAAT,CAAmBC,cAAnB,CAAkCzB,SAAS,CAAC0B,OAA5C,EAAqDR,YAArD,CAAzB;AACA,YAAMgC,OAAO,GAAG,KAAK3B,GAAL,CAAS4B,MAAT,CAAgBC,UAAhB,CAA2BH,IAA3B,EAAiCI,QAAjD;AACA,aAAO,MAAM/B,gBAAgB,CAACW,OAAjB,CAAyBqB,SAAzB,CAAmCJ,OAAnC,EAA4CH,IAA5C,CAAiD,KAAK1C,OAAtD,CAAb;AACH,KAJD;;AAKA,SAAKkD,WAAL,GAAmB,MAAOrC,YAAP,IAAwB;AACvC,YAAMI,gBAAgB,GAAG,KAAKC,GAAL,CAASC,SAAT,CAAmBC,cAAnB,CAAkCzB,SAAS,CAAC0B,OAA5C,EAAqDR,YAArD,CAAzB;AACA,aAAO,MAAMI,gBAAgB,CAACW,OAAjB,CAAyBsB,WAAzB,GAAuCR,IAAvC,CAA4C,KAAK1C,OAAjD,CAAb;AACH,KAHD;;AAIA,SAAKmD,iBAAL,GAAyB,CAACtC,YAAD,EAAeG,cAAf,KAAkC;AACvD,YAAMC,gBAAgB,GAAG,KAAKC,GAAL,CAASC,SAAT,CAAmBC,cAAnB,CAAkCzB,SAAS,CAAC0B,OAA5C,EAAqDR,YAArD,CAAzB;AACA,aAAO,IAAIS,OAAJ,CAAY,OAAOC,OAAP,EAAgBC,MAAhB,KAA2B;AAC1C,YAAI;AACA,cAAI4B,UAAJ;;AACA,cAAI,KAAKjD,YAAT,EAAuB;AACnB,kBAAMN,SAAS,CAAC4B,sBAAV,CAAiClB,MAAM,CAACC,SAAxC,EAAmD,KAAKU,GAAxD,EAA6D,KAAKY,kBAAL,CAAwBJ,MAArF,EAA6F,IAA7F,EAAmGF,MAAnG,CAAN;AACA,kBAAM;AAAEO,cAAAA;AAAF,gBAAc,MAAMxB,MAAM,CAACC,SAAP,CAAiB6C,UAAjB,EAA1B;AACAD,YAAAA,UAAU,GAAG,KAAKlC,GAAL,CAAS4B,MAAT,CAAgBC,UAAhB,CAA2BhB,OAA3B,EAAoCiB,QAAjD;AACH;;AACD,cAAI,KAAK5C,aAAT,EAAwB;AACpB,kBAAMP,SAAS,CAAC4B,sBAAV,CAAiClB,MAAM,CAACI,OAAxC,EAAiD,KAAKO,GAAtD,EAA2D,KAAKY,kBAAL,CAAwBJ,MAAnF,EAA2F,IAA3F,EAAiGF,MAAjG,CAAN;AACA,kBAAM;AAAEO,cAAAA;AAAF,gBAAc,MAAMxB,MAAM,CAACC,SAAP,CAAiB6C,UAAjB,EAA1B;AACAD,YAAAA,UAAU,GAAG,KAAKlC,GAAL,CAAS4B,MAAT,CAAgBC,UAAhB,CAA2BhB,OAA3B,EAAoCiB,QAAjD;AACH;;AACD,cAAI,CAAC,KAAK5C,aAAN,IAAuB,CAAC,KAAKD,YAAjC,EAA+C;AAC3C,kBAAM4B,OAAO,GAAG,KAAKb,GAAL,CAASQ,MAAT,CAAgB4B,QAAhB,CAAyB,CAAzB,CAAhB;AACAF,YAAAA,UAAU,GAAG,KAAKlC,GAAL,CAAS4B,MAAT,CAAgBC,UAAhB,CAA2BhB,OAA3B,EAAoCiB,QAAjD;AACH;;AACD,cAAIrB,GAAG,GAAG,MAAMV,gBAAgB,CAACW,OAAjB,CACX2B,gBADW,CACMH,UADN,EACkB,KAAKtB,kBAAL,CAAwBC,OAD1C,EAEXW,IAFW,CAEN,KAAK1C,OAFC,CAAhB;;AAGA,cAAI,CAAC2B,GAAL,EAAU;AACNA,YAAAA,GAAG,GAAG,MAAMV,gBAAgB,CAACW,OAAjB,CACPuB,iBADO,CACW,KAAKrB,kBAAL,CAAwBC,OADnC,EAC4C,IAD5C,EAEPE,IAFO,CAEF,KAAKjC,OAFH,EAGPkC,EAHO,CAGJ,iBAHI,EAGelB,cAHf,CAAZ;AAIAO,YAAAA,OAAO,CAACI,GAAD,CAAP;AACH,WAND,MAOK;AACDX,YAAAA,cAAc,CAAC,MAAD,CAAd;AACAO,YAAAA,OAAO,CAACI,GAAD,CAAP;AACH;AACJ,SA9BD,CA+BA,OAAOQ,CAAP,EAAU;AACNX,UAAAA,MAAM,CAACW,CAAD,CAAN;AACH;AACJ,OAnCM,CAAP;AAoCH,KAtCD;;AAuCA,SAAKqB,UAAL,GAAkB,OAAO3C,YAAP,EAAqBwB,QAArB,EAA+BvB,MAA/B,EAAuCE,cAAvC,KAA0D;AACxE,aAAO,IAAIM,OAAJ,CAAY,OAAOC,OAAP,EAAgBC,MAAhB,KAA2B;AAC1C,YAAI;AACA,cAAI,KAAKrB,YAAT,EAAuB;AACnB,kBAAMN,SAAS,CAAC4B,sBAAV,CAAiClB,MAAM,CAACC,SAAxC,EAAmD,KAAKU,GAAxD,EAA6D,KAAKY,kBAAL,CAAwBJ,MAArF,EAA6F,IAA7F,EAAmGF,MAAnG,CAAN;AACH;;AACD,cAAI,KAAKpB,aAAT,EAAwB;AACpB,kBAAMP,SAAS,CAAC4B,sBAAV,CAAiClB,MAAM,CAACI,OAAxC,EAAiD,KAAKO,GAAtD,EAA2D,KAAKY,kBAAL,CAAwBJ,MAAnF,EAA2F,IAA3F,EAAiGF,MAAjG,CAAN;AACH;;AACD,gBAAMiC,WAAW,GAAG,KAAKvC,GAAL,CAAS4B,MAAT,CAAgBC,UAAhB,CAA2BV,QAA3B,EAAqCW,QAAzD;AACA,gBAAMV,QAAQ,GAAG,MAAM,KAAKR,kBAAL,CAAwBF,OAAxB,CAClB4B,UADkB,CACP3C,YADO,EACOC,MADP,EACe2C,WADf,EAElBxB,IAFkB,CAEb,KAAKjC,OAFQ,EAGlBkC,EAHkB,CAGf,iBAHe,EAGIlB,cAHJ,CAAvB;AAIAO,UAAAA,OAAO,CAACe,QAAD,CAAP;AACH,SAbD,CAcA,OAAOH,CAAP,EAAU;AACNX,UAAAA,MAAM,CAACW,CAAD,CAAN;AACH;AACJ,OAlBM,CAAP;AAmBH,KApBD;;AAqBA,SAAKjB,GAAL,GAAWnB,MAAM,CAACmB,GAAlB;AACA,SAAKY,kBAAL,GAA0B/B,MAAM,CAAC+B,kBAAjC;;AACA,QAAI/B,MAAM,CAACC,OAAX,EAAoB;AAChB,WAAKA,OAAL,GAAeD,MAAM,CAACC,OAAtB;AACH;AACJ;;AAzIiB;;AA2ItBX,OAAO,CAACE,eAAR,GAA0BA,eAA1B","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HmyMethodsERC20 = void 0;\nconst tslib_1 = require(\"tslib\");\nconst utils_1 = require(\"../utils\");\nconst MyERC20_1 = tslib_1.__importDefault(require(\"../out/MyERC20\"));\nconst helpers_1 = require(\"./helpers\");\nclass HmyMethodsERC20 {\n    constructor(params) {\n        this.options = { gasPrice: 1000000000, gasLimit: 6721900 };\n        this.useOneWallet = false;\n        this.useMathWallet = false;\n        this.setUseMetamask = (value) => value;\n        this.setUseOneWallet = (value) => {\n            if (!window || !window.onewallet) {\n                throw new Error('OneWallet extension is not found');\n            }\n            this.useOneWallet = value;\n        };\n        this.setUseMathWallet = (value) => {\n            if (!window || !window.harmony) {\n                throw new Error('Math Wallet extension is not found');\n            }\n            this.useMathWallet = value;\n        };\n        this.approveHmyManger = (hrc20Address, amount, decimals, sendTxCallback) => {\n            const hmyTokenContract = this.hmy.contracts.createContract(MyERC20_1.default, hrc20Address);\n            return new Promise(async (resolve, reject) => {\n                try {\n                    if (this.useOneWallet) {\n                        await helpers_1.connectToBrowserWallet(window.onewallet, this.hmy, hmyTokenContract.wallet, null, reject);\n                    }\n                    if (this.useMathWallet) {\n                        await helpers_1.connectToBrowserWallet(window.harmony, this.hmy, hmyTokenContract.wallet, null, reject);\n                    }\n                    const res = await hmyTokenContract.methods\n                        .approve(this.hmyManagerContract.address, utils_1.withDecimals(amount, decimals))\n                        .send(this.options)\n                        .on('transactionHash', sendTxCallback);\n                    resolve(res);\n                }\n                catch (e) {\n                    reject(e);\n                }\n            });\n        };\n        this.burnToken = async (hrc20Address, userAddr, amount, decimals, sendTxCallback) => {\n            return new Promise(async (resolve, reject) => {\n                try {\n                    if (this.useOneWallet) {\n                        await helpers_1.connectToBrowserWallet(window.onewallet, this.hmy, this.hmyManagerContract.wallet, null, reject);\n                    }\n                    if (this.useMathWallet) {\n                        await helpers_1.connectToBrowserWallet(window.harmony, this.hmy, this.hmyManagerContract.wallet, null, reject);\n                    }\n                    const response = await this.hmyManagerContract.methods\n                        .burnToken(hrc20Address, utils_1.withDecimals(amount, decimals), userAddr)\n                        .send(this.options)\n                        .on('transactionHash', sendTxCallback);\n                    resolve(response);\n                }\n                catch (e) {\n                    reject(e);\n                }\n            });\n        };\n        this.getMappingFor = async (erc20TokenAddr) => {\n            const res = await this.hmyManagerContract.methods.mappings(erc20TokenAddr).call(this.options);\n            return res;\n        };\n        this.checkHmyBalance = async (hrc20Address, addr) => {\n            const hmyTokenContract = this.hmy.contracts.createContract(MyERC20_1.default, hrc20Address);\n            const addrHex = this.hmy.crypto.getAddress(addr).checksum;\n            return await hmyTokenContract.methods.balanceOf(addrHex).call(this.options);\n        };\n        this.totalSupply = async (hrc20Address) => {\n            const hmyTokenContract = this.hmy.contracts.createContract(MyERC20_1.default, hrc20Address);\n            return await hmyTokenContract.methods.totalSupply().call(this.options);\n        };\n        this.setApprovalForAll = (hrc20Address, sendTxCallback) => {\n            const hmyTokenContract = this.hmy.contracts.createContract(MyERC20_1.default, hrc20Address);\n            return new Promise(async (resolve, reject) => {\n                try {\n                    let hmyAddrHex;\n                    if (this.useOneWallet) {\n                        await helpers_1.connectToBrowserWallet(window.onewallet, this.hmy, this.hmyManagerContract.wallet, null, reject);\n                        const { address } = await window.onewallet.getAccount();\n                        hmyAddrHex = this.hmy.crypto.getAddress(address).checksum;\n                    }\n                    if (this.useMathWallet) {\n                        await helpers_1.connectToBrowserWallet(window.harmony, this.hmy, this.hmyManagerContract.wallet, null, reject);\n                        const { address } = await window.onewallet.getAccount();\n                        hmyAddrHex = this.hmy.crypto.getAddress(address).checksum;\n                    }\n                    if (!this.useMathWallet && !this.useOneWallet) {\n                        const address = this.hmy.wallet.accounts[0];\n                        hmyAddrHex = this.hmy.crypto.getAddress(address).checksum;\n                    }\n                    let res = await hmyTokenContract.methods\n                        .isApprovedForAll(hmyAddrHex, this.hmyManagerContract.address)\n                        .call(this.options);\n                    if (!res) {\n                        res = await hmyTokenContract.methods\n                            .setApprovalForAll(this.hmyManagerContract.address, true)\n                            .send(this.options)\n                            .on('transactionHash', sendTxCallback);\n                        resolve(res);\n                    }\n                    else {\n                        sendTxCallback('skip');\n                        resolve(res);\n                    }\n                }\n                catch (e) {\n                    reject(e);\n                }\n            });\n        };\n        this.burnTokens = async (hrc20Address, userAddr, amount, sendTxCallback) => {\n            return new Promise(async (resolve, reject) => {\n                try {\n                    if (this.useOneWallet) {\n                        await helpers_1.connectToBrowserWallet(window.onewallet, this.hmy, this.hmyManagerContract.wallet, null, reject);\n                    }\n                    if (this.useMathWallet) {\n                        await helpers_1.connectToBrowserWallet(window.harmony, this.hmy, this.hmyManagerContract.wallet, null, reject);\n                    }\n                    const userAddrHex = this.hmy.crypto.getAddress(userAddr).checksum;\n                    const response = await this.hmyManagerContract.methods\n                        .burnTokens(hrc20Address, amount, userAddrHex)\n                        .send(this.options)\n                        .on('transactionHash', sendTxCallback);\n                    resolve(response);\n                }\n                catch (e) {\n                    reject(e);\n                }\n            });\n        };\n        this.hmy = params.hmy;\n        this.hmyManagerContract = params.hmyManagerContract;\n        if (params.options) {\n            this.options = params.options;\n        }\n    }\n}\nexports.HmyMethodsERC20 = HmyMethodsERC20;\n"]},"metadata":{},"sourceType":"script"}