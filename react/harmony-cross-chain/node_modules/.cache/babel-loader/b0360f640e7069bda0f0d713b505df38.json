{"ast":null,"code":"\"use strict\";\n/**\n * @packageDocumentation\n * @module harmony-account\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Account = void 0;\n\nvar tslib_1 = require(\"tslib\");\n\nvar crypto_1 = require(\"@harmony-js/crypto\");\n\nvar utils_1 = require(\"@harmony-js/utils\");\n\nvar transaction_1 = require(\"@harmony-js/transaction\");\n\nvar network_1 = require(\"@harmony-js/network\");\n\nvar utils_2 = require(\"./utils\");\n\nvar Account = function () {\n  /**\n   * Generate an account object\n   *\n   * @param key import an existing privateKey, or create a random one\n   * @param messenger you can setMessage later, or set message on `new`\n   *\n   * @example\n   * ```javascript\n   * // import the Account class\n   * const { Account } = require('@harmony-js/account');\n   *\n   * // Messenger is optional, by default, we have a defaultMessenger\n   * // If you like to change, you will import related package here.\n   * const { HttpProvider, Messenger } = require('@harmony-js/network');\n   * const { ChainType, ChainID } = require('@harmony-js/utils');\n   *\n   * // create a custom messenger\n   * const customMessenger = new Messenger(\n   *   new HttpProvider('http://localhost:9500'),\n   *   ChainType.Harmony, // if you are connected to Harmony's blockchain\n   *   ChainID.HmyLocal, // check if the chainId is correct\n   * )\n   *\n   * // setMessenger later\n   * const randomAccount = new Account()\n   * randomAccount.setMessenger(customMessenger)\n   *\n   * // or you can set messenger on `new`\n   * const randomAccountWithCustomMessenger = new Account(undefined, customMessenger)\n   *\n   * // NOTED: Key with or without `0x` are accepted, makes no different\n   * // NOTED: DO NOT import `mnemonic phrase` using `Account` class, use `Wallet` instead\n   * const myPrivateKey = '0xe19d05c5452598e24caad4a0d85a49146f7be089515c905ae6a19e8a578a6930'\n   * const myAccountWithMyPrivateKey = new Account(myPrivateKey)\n   * ```\n   */\n  function Account(key, messenger) {\n    if (messenger === void 0) {\n      messenger = utils_2.defaultMessenger;\n    }\n    /**@hidden */\n\n\n    this.balance = '0';\n    /**@hidden */\n\n    this.nonce = 0;\n    /**@hidden */\n\n    this.encrypted = false;\n    this.messenger = messenger;\n\n    if (!key) {\n      this._new();\n    } else {\n      this._import(key);\n    }\n\n    this.shardID = this.messenger.currentShard || 0;\n    this.shards = new Map();\n    this.shards.set(this.shardID, {\n      address: \"\" + this.bech32Address + utils_1.AddressSuffix + \"0\",\n      balance: this.balance || '0',\n      nonce: this.nonce || 0\n    });\n  }\n  /**\n   * static method create account\n   *\n   * @example\n   * ```javascript\n   * const account = new Account();\n   * console.log(account);\n   * ```\n   */\n\n\n  Account.new = function () {\n    var newAcc = new Account()._new();\n\n    return newAcc;\n  };\n  /**\n   * Static Method: add a private key to Account\n   * @param  {string} key - private Key\n   *\n   * @example\n   * ```javascript\n   * const account = new Account.add(key_1);\n   * console.log(account);\n   * ```\n   */\n\n\n  Account.add = function (key) {\n    var newAcc = new Account()._import(key);\n\n    return newAcc;\n  };\n\n  Object.defineProperty(Account.prototype, \"checksumAddress\", {\n    /**\n     * check sum address\n     *\n     * @example\n     * ```javascript\n     * console.log(account.checksumAddress);\n     * ```\n     */\n    get: function () {\n      return this.address ? crypto_1.getAddress(this.address).checksum : '';\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Account.prototype, \"bech32Address\", {\n    /**\n     * Get bech32 Address\n     *\n     * @example\n     * ```javascript\n     * console.log(account.bech32Address);\n     * ```\n     */\n    get: function () {\n      return this.address ? crypto_1.getAddress(this.address).bech32 : '';\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Account.prototype, \"bech32TestNetAddress\", {\n    /**\n     * get Bech32 TestNet Address\n     *\n     * @example\n     * ```javascript\n     * console.log(account.bech32TestNetAddress);\n     * ```\n     */\n    get: function () {\n      return this.address ? crypto_1.getAddress(this.address).bech32TestNet : '';\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Account.prototype, \"getShardsCount\", {\n    /**\n     * get Shards number with this Account\n     *\n     * @example\n     * ```javascript\n     * console.log(account.getShardsCount);\n     * ```\n     */\n    get: function () {\n      return this.shards.size;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  Account.prototype.toFile = function (password, options) {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var file;\n      return tslib_1.__generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!(this.privateKey && utils_1.isPrivateKey(this.privateKey))) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , crypto_1.encrypt(this.privateKey, password, options)];\n\n          case 1:\n            file = _a.sent();\n            this.privateKey = file;\n            this.encrypted = true;\n            return [2\n            /*return*/\n            , file];\n\n          case 2:\n            throw new Error('Encryption failed because PrivateKey is not correct');\n        }\n      });\n    });\n  };\n\n  Account.prototype.fromFile = function (keyStore, password) {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var file, decyptedPrivateKey, error_1;\n      return tslib_1.__generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 2,, 3]);\n\n            if (typeof password !== 'string') {\n              throw new Error('you must provide password');\n            }\n\n            file = JSON.parse(keyStore.toLowerCase());\n            return [4\n            /*yield*/\n            , crypto_1.decrypt(file, password)];\n\n          case 1:\n            decyptedPrivateKey = _a.sent();\n\n            if (utils_1.isPrivateKey(decyptedPrivateKey)) {\n              return [2\n              /*return*/\n              , this._import(decyptedPrivateKey)];\n            } else {\n              throw new Error('decrypted failed');\n            }\n\n            return [3\n            /*break*/\n            , 3];\n\n          case 2:\n            error_1 = _a.sent();\n            throw error_1;\n\n          case 3:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Get the account balance\n   *\n   * @param blockNumber by default, it's `latest`\n   *\n   * @example\n   * ```javascript\n   * account.getBalance().then((value) => {\n   *   console.log(value);\n   * });\n   * ```\n   */\n\n\n  Account.prototype.getBalance = function (blockNumber) {\n    if (blockNumber === void 0) {\n      blockNumber = 'latest';\n    }\n\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var balance, nonce, error_2;\n      return tslib_1.__generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 5,, 6]);\n\n            if (!this.messenger) return [3\n            /*break*/\n            , 3];\n            return [4\n            /*yield*/\n            , this.messenger.send(network_1.RPCMethod.GetBalance, [this.address, blockNumber], this.messenger.chainPrefix, this.messenger.currentShard || 0)];\n\n          case 1:\n            balance = _a.sent();\n            return [4\n            /*yield*/\n            , this.messenger.send(network_1.RPCMethod.GetTransactionCount, [this.address, blockNumber], this.messenger.chainPrefix, this.messenger.currentShard || 0)];\n\n          case 2:\n            nonce = _a.sent();\n\n            if (balance.isError()) {\n              throw balance.error.message;\n            }\n\n            if (nonce.isError()) {\n              throw nonce.error.message;\n            }\n\n            this.balance = utils_1.hexToNumber(balance.result);\n            this.nonce = Number.parseInt(utils_1.hexToNumber(nonce.result), 10);\n            this.shardID = this.messenger.currentShard || 0;\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            throw new Error('No Messenger found');\n\n          case 4:\n            return [2\n            /*return*/\n            , {\n              balance: this.balance,\n              nonce: this.nonce,\n              shardID: this.shardID\n            }];\n\n          case 5:\n            error_2 = _a.sent();\n            throw error_2;\n\n          case 6:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * @function updateShards\n   */\n\n\n  Account.prototype.updateBalances = function (blockNumber) {\n    if (blockNumber === void 0) {\n      blockNumber = 'latest';\n    }\n\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var shardProviders, shardProviders_1, shardProviders_1_1, _a, name_1, val, balanceObject, e_1_1, currentShard;\n\n      var e_1, _b;\n\n      return tslib_1.__generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            shardProviders = this.messenger.shardProviders;\n            if (!(shardProviders.size > 1)) return [3\n            /*break*/\n            , 10];\n            _c.label = 1;\n\n          case 1:\n            _c.trys.push([1, 7, 8, 9]);\n\n            shardProviders_1 = tslib_1.__values(shardProviders), shardProviders_1_1 = shardProviders_1.next();\n            _c.label = 2;\n\n          case 2:\n            if (!!shardProviders_1_1.done) return [3\n            /*break*/\n            , 6];\n            _a = tslib_1.__read(shardProviders_1_1.value, 2), name_1 = _a[0], val = _a[1];\n            return [4\n            /*yield*/\n            , this.getShardBalance(val.shardID, blockNumber)];\n\n          case 3:\n            balanceObject = _c.sent();\n            return [4\n            /*yield*/\n            , this.shards.set(name_1 === val.shardID ? name_1 : val.shardID, balanceObject)];\n\n          case 4:\n            _c.sent();\n\n            _c.label = 5;\n\n          case 5:\n            shardProviders_1_1 = shardProviders_1.next();\n            return [3\n            /*break*/\n            , 2];\n\n          case 6:\n            return [3\n            /*break*/\n            , 9];\n\n          case 7:\n            e_1_1 = _c.sent();\n            e_1 = {\n              error: e_1_1\n            };\n            return [3\n            /*break*/\n            , 9];\n\n          case 8:\n            try {\n              if (shardProviders_1_1 && !shardProviders_1_1.done && (_b = shardProviders_1.return)) _b.call(shardProviders_1);\n            } finally {\n              if (e_1) throw e_1.error;\n            }\n\n            return [7\n            /*endfinally*/\n            ];\n\n          case 9:\n            return [3\n            /*break*/\n            , 12];\n\n          case 10:\n            return [4\n            /*yield*/\n            , this.getShardBalance(this.messenger.currentShard || 0, blockNumber)];\n\n          case 11:\n            currentShard = _c.sent();\n            this.shards.set(this.messenger.currentShard || 0, currentShard);\n            _c.label = 12;\n\n          case 12:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * @function signTransaction\n   */\n\n\n  Account.prototype.signTransaction = function (transaction, updateNonce, encodeMode, blockNumber) {\n    if (updateNonce === void 0) {\n      updateNonce = true;\n    }\n\n    if (encodeMode === void 0) {\n      encodeMode = 'rlp';\n    }\n\n    if (blockNumber === void 0) {\n      blockNumber = 'latest';\n    }\n\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var txShardID, shardNonce, _a, signature_1, rawTransaction_1;\n\n      var _this = this;\n\n      return tslib_1.__generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (!this.privateKey || !utils_1.isPrivateKey(this.privateKey)) {\n              throw new Error(this.privateKey + \" is not found or not correct\");\n            }\n\n            if (!updateNonce) return [3\n            /*break*/\n            , 2];\n            txShardID = transaction.txParams.shardID;\n            return [4\n            /*yield*/\n            , this.getShardNonce(typeof txShardID === 'string' ? Number.parseInt(txShardID, 10) : txShardID, blockNumber)];\n\n          case 1:\n            shardNonce = _b.sent();\n            transaction.setParams(tslib_1.__assign(tslib_1.__assign({}, transaction.txParams), {\n              from: this.messenger.chainPrefix === utils_1.ChainType.Harmony ? this.bech32Address : this.checksumAddress || '0x',\n              nonce: shardNonce\n            }));\n            _b.label = 2;\n\n          case 2:\n            if (encodeMode === 'rlp') {\n              _a = tslib_1.__read(transaction_1.RLPSign(transaction, this.privateKey), 2), signature_1 = _a[0], rawTransaction_1 = _a[1];\n              return [2\n              /*return*/\n              , transaction.map(function (obj) {\n                return tslib_1.__assign(tslib_1.__assign({}, obj), {\n                  signature: signature_1,\n                  rawTransaction: rawTransaction_1,\n                  from: _this.messenger.chainPrefix === utils_1.ChainType.Harmony ? _this.bech32Address : _this.checksumAddress || '0x'\n                });\n              })];\n            } else {\n              // TODO: if we use other encode method, eg. protobuf, we should implement this\n              return [2\n              /*return*/\n              , transaction];\n            }\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * This function is still in development, coming soon!\n   *\n   * @param staking\n   * @param updateNonce\n   * @param encodeMode\n   * @param blockNumber\n   * @param shardID\n   */\n\n\n  Account.prototype.signStaking = function (staking, updateNonce, encodeMode, blockNumber, shardID) {\n    if (updateNonce === void 0) {\n      updateNonce = true;\n    }\n\n    if (encodeMode === void 0) {\n      encodeMode = 'rlp';\n    }\n\n    if (blockNumber === void 0) {\n      blockNumber = 'latest';\n    }\n\n    if (shardID === void 0) {\n      shardID = this.messenger.currentShard;\n    }\n\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var txShardID, shardNonce, _a, signature, rawTransaction;\n\n      return tslib_1.__generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (!this.privateKey || !utils_1.isPrivateKey(this.privateKey)) {\n              throw new Error(this.privateKey + \" is not found or not correct\");\n            }\n\n            if (!updateNonce) return [3\n            /*break*/\n            , 2];\n            txShardID = shardID;\n            return [4\n            /*yield*/\n            , this.getShardNonce(typeof txShardID === 'string' ? Number.parseInt(txShardID, 10) : txShardID, blockNumber)];\n\n          case 1:\n            shardNonce = _b.sent();\n            staking.setFromAddress(this.messenger.chainPrefix === utils_1.ChainType.Harmony ? this.bech32Address : this.checksumAddress || '0x');\n            staking.setNonce(shardNonce);\n            _b.label = 2;\n\n          case 2:\n            if (encodeMode === 'rlp') {\n              _a = tslib_1.__read(staking.rlpSign(this.privateKey), 2), signature = _a[0], rawTransaction = _a[1];\n              staking.setRawTransaction(rawTransaction);\n              staking.setSignature(signature);\n              staking.setFromAddress(this.messenger.chainPrefix === utils_1.ChainType.Harmony ? this.bech32Address : this.checksumAddress || '0x');\n              return [2\n              /*return*/\n              , staking];\n            } else {\n              // TODO: if we use other encode method, eg. protobuf, we should implement this\n              return [2\n              /*return*/\n              , staking];\n            }\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * @param messenger\n   *\n   * @example\n   * ```javascript\n   * // create a custom messenger\n   * const customMessenger = new Messenger(\n   *   new HttpProvider('http://localhost:9500'),\n   *   ChainType.Harmony, // if you are connected to Harmony's blockchain\n   *   ChainID.HmyLocal, // check if the chainId is correct\n   * )\n   *\n   * // to create an Account with random privateKey\n   * // and you can setMessenger later\n   * const randomAccount = new Account()\n   * randomAccount.setMessenger(customMessenger)\n   * ```\n   */\n\n\n  Account.prototype.setMessenger = function (messenger) {\n    this.messenger = messenger;\n  };\n  /**\n   * Get account address from shard ID\n   * @param shardID\n   *\n   * @example\n   * ```javascript\n   * console.log(account.getAddressFromShardID(0));\n   *\n   * > one103q7qe5t2505lypvltkqtddaef5tzfxwsse4z7-0\n   * ```\n   */\n\n\n  Account.prototype.getAddressFromShardID = function (shardID) {\n    var shardObject = this.shards.get(shardID);\n\n    if (shardObject) {\n      return shardObject.address;\n    } else {\n      return undefined;\n    }\n  };\n  /**\n   * Get all shards' addresses from the account\n   *\n   * @example\n   * ```javascript\n   * console.log(account.getAddresses());\n   * ```\n   */\n\n\n  Account.prototype.getAddresses = function () {\n    var e_2, _a;\n\n    var addressArray = [];\n\n    try {\n      for (var _b = tslib_1.__values(this.shards), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var _d = tslib_1.__read(_c.value, 2),\n            name_2 = _d[0],\n            val = _d[1];\n\n        var index = typeof name_2 === 'string' ? Number.parseInt(name_2, 10) : name_2;\n        addressArray[index] = val.address;\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n\n    return addressArray;\n  };\n  /**\n   * Get the specific shard's balance\n   *\n   * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n   * @param blockNumber by default, it's `latest`\n   *\n   * @example\n   * ```\n   * account.getShardBalance().then((value) => {\n   *   console.log(value);\n   * });\n   * ```\n   */\n\n\n  Account.prototype.getShardBalance = function (shardID, blockNumber) {\n    if (blockNumber === void 0) {\n      blockNumber = 'latest';\n    }\n\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var balance, nonce;\n      return tslib_1.__generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.messenger.send(network_1.RPCMethod.GetBalance, [this.address, blockNumber], this.messenger.chainPrefix, shardID)];\n\n          case 1:\n            balance = _a.sent();\n            return [4\n            /*yield*/\n            , this.messenger.send(network_1.RPCMethod.GetTransactionCount, [this.address, blockNumber], this.messenger.chainPrefix, shardID)];\n\n          case 2:\n            nonce = _a.sent();\n\n            if (balance.isError()) {\n              throw balance.error.message;\n            }\n\n            if (nonce.isError()) {\n              throw nonce.error.message;\n            }\n\n            return [2\n            /*return*/\n            , {\n              address: \"\" + this.bech32Address + utils_1.AddressSuffix + shardID,\n              balance: utils_1.hexToNumber(balance.result),\n              nonce: Number.parseInt(utils_1.hexToNumber(nonce.result), 10)\n            }];\n        }\n      });\n    });\n  };\n  /**\n   * Get the specific shard's nonce\n   *\n   * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n   * @param blockNumber by default, it's `latest`\n   *\n   * @example\n   * ```\n   * account.getShardNonce().then((value) => {\n   *   console.log(value);\n   * });\n   * ```\n   */\n\n\n  Account.prototype.getShardNonce = function (shardID, blockNumber) {\n    if (blockNumber === void 0) {\n      blockNumber = 'latest';\n    }\n\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var nonce;\n      return tslib_1.__generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.messenger.send(network_1.RPCMethod.GetAccountNonce, [this.address, blockNumber], this.messenger.chainPrefix, shardID)];\n\n          case 1:\n            nonce = _a.sent();\n\n            if (nonce.isError()) {\n              throw nonce.error.message;\n            }\n\n            return [2\n            /*return*/\n            , nonce.result];\n        }\n      });\n    });\n  };\n  /**\n   * @function _new private method create Account\n   * @return {Account} Account instance\n   * @ignore\n   */\n\n\n  Account.prototype._new = function () {\n    var prv = crypto_1.generatePrivateKey();\n\n    if (!utils_1.isPrivateKey(prv)) {\n      throw new Error('key gen failed');\n    }\n\n    return this._import(prv);\n  };\n  /**\n   * @function _import private method import a private Key\n   * @param  {string} key - private key\n   * @return {Account} Account instance\n   * @ignore\n   */\n\n\n  Account.prototype._import = function (key) {\n    if (!utils_1.isPrivateKey(key)) {\n      throw new Error(key + \" is not PrivateKey\");\n    }\n\n    this.privateKey = utils_1.add0xToString(key);\n    this.publicKey = crypto_1.getPubkeyFromPrivateKey(this.privateKey);\n    this.address = crypto_1.getAddressFromPrivateKey(this.privateKey);\n    this.shardID = this.messenger.currentShard || 0;\n    this.shards = new Map();\n    this.shards.set(this.shardID, {\n      address: \"\" + this.bech32Address + utils_1.AddressSuffix + \"0\",\n      balance: this.balance || '0',\n      nonce: this.nonce || 0\n    });\n    this.encrypted = false;\n    return this;\n  };\n\n  return Account;\n}();\n\nexports.Account = Account;","map":{"version":3,"sources":["../src/account.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n * @packageDocumentation\n * @module harmony-account\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Account = void 0;\nvar tslib_1 = require(\"tslib\");\nvar crypto_1 = require(\"@harmony-js/crypto\");\nvar utils_1 = require(\"@harmony-js/utils\");\nvar transaction_1 = require(\"@harmony-js/transaction\");\nvar network_1 = require(\"@harmony-js/network\");\nvar utils_2 = require(\"./utils\");\nvar Account = /** @class */ (function () {\n    /**\n     * Generate an account object\n     *\n     * @param key import an existing privateKey, or create a random one\n     * @param messenger you can setMessage later, or set message on `new`\n     *\n     * @example\n     * ```javascript\n     * // import the Account class\n     * const { Account } = require('@harmony-js/account');\n     *\n     * // Messenger is optional, by default, we have a defaultMessenger\n     * // If you like to change, you will import related package here.\n     * const { HttpProvider, Messenger } = require('@harmony-js/network');\n     * const { ChainType, ChainID } = require('@harmony-js/utils');\n     *\n     * // create a custom messenger\n     * const customMessenger = new Messenger(\n     *   new HttpProvider('http://localhost:9500'),\n     *   ChainType.Harmony, // if you are connected to Harmony's blockchain\n     *   ChainID.HmyLocal, // check if the chainId is correct\n     * )\n     *\n     * // setMessenger later\n     * const randomAccount = new Account()\n     * randomAccount.setMessenger(customMessenger)\n     *\n     * // or you can set messenger on `new`\n     * const randomAccountWithCustomMessenger = new Account(undefined, customMessenger)\n     *\n     * // NOTED: Key with or without `0x` are accepted, makes no different\n     * // NOTED: DO NOT import `mnemonic phrase` using `Account` class, use `Wallet` instead\n     * const myPrivateKey = '0xe19d05c5452598e24caad4a0d85a49146f7be089515c905ae6a19e8a578a6930'\n     * const myAccountWithMyPrivateKey = new Account(myPrivateKey)\n     * ```\n     */\n    function Account(key, messenger) {\n        if (messenger === void 0) { messenger = utils_2.defaultMessenger; }\n        /**@hidden */\n        this.balance = '0';\n        /**@hidden */\n        this.nonce = 0;\n        /**@hidden */\n        this.encrypted = false;\n        this.messenger = messenger;\n        if (!key) {\n            this._new();\n        }\n        else {\n            this._import(key);\n        }\n        this.shardID = this.messenger.currentShard || 0;\n        this.shards = new Map();\n        this.shards.set(this.shardID, {\n            address: \"\" + this.bech32Address + utils_1.AddressSuffix + \"0\",\n            balance: this.balance || '0',\n            nonce: this.nonce || 0,\n        });\n    }\n    /**\n     * static method create account\n     *\n     * @example\n     * ```javascript\n     * const account = new Account();\n     * console.log(account);\n     * ```\n     */\n    Account.new = function () {\n        var newAcc = new Account()._new();\n        return newAcc;\n    };\n    /**\n     * Static Method: add a private key to Account\n     * @param  {string} key - private Key\n     *\n     * @example\n     * ```javascript\n     * const account = new Account.add(key_1);\n     * console.log(account);\n     * ```\n     */\n    Account.add = function (key) {\n        var newAcc = new Account()._import(key);\n        return newAcc;\n    };\n    Object.defineProperty(Account.prototype, \"checksumAddress\", {\n        /**\n         * check sum address\n         *\n         * @example\n         * ```javascript\n         * console.log(account.checksumAddress);\n         * ```\n         */\n        get: function () {\n            return this.address ? crypto_1.getAddress(this.address).checksum : '';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Account.prototype, \"bech32Address\", {\n        /**\n         * Get bech32 Address\n         *\n         * @example\n         * ```javascript\n         * console.log(account.bech32Address);\n         * ```\n         */\n        get: function () {\n            return this.address ? crypto_1.getAddress(this.address).bech32 : '';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Account.prototype, \"bech32TestNetAddress\", {\n        /**\n         * get Bech32 TestNet Address\n         *\n         * @example\n         * ```javascript\n         * console.log(account.bech32TestNetAddress);\n         * ```\n         */\n        get: function () {\n            return this.address ? crypto_1.getAddress(this.address).bech32TestNet : '';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Account.prototype, \"getShardsCount\", {\n        /**\n         * get Shards number with this Account\n         *\n         * @example\n         * ```javascript\n         * console.log(account.getShardsCount);\n         * ```\n         */\n        get: function () {\n            return this.shards.size;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Account.prototype.toFile = function (password, options) {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var file;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!(this.privateKey && utils_1.isPrivateKey(this.privateKey))) return [3 /*break*/, 2];\n                        return [4 /*yield*/, crypto_1.encrypt(this.privateKey, password, options)];\n                    case 1:\n                        file = _a.sent();\n                        this.privateKey = file;\n                        this.encrypted = true;\n                        return [2 /*return*/, file];\n                    case 2: throw new Error('Encryption failed because PrivateKey is not correct');\n                }\n            });\n        });\n    };\n    Account.prototype.fromFile = function (keyStore, password) {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var file, decyptedPrivateKey, error_1;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 2, , 3]);\n                        if (typeof password !== 'string') {\n                            throw new Error('you must provide password');\n                        }\n                        file = JSON.parse(keyStore.toLowerCase());\n                        return [4 /*yield*/, crypto_1.decrypt(file, password)];\n                    case 1:\n                        decyptedPrivateKey = _a.sent();\n                        if (utils_1.isPrivateKey(decyptedPrivateKey)) {\n                            return [2 /*return*/, this._import(decyptedPrivateKey)];\n                        }\n                        else {\n                            throw new Error('decrypted failed');\n                        }\n                        return [3 /*break*/, 3];\n                    case 2:\n                        error_1 = _a.sent();\n                        throw error_1;\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Get the account balance\n     *\n     * @param blockNumber by default, it's `latest`\n     *\n     * @example\n     * ```javascript\n     * account.getBalance().then((value) => {\n     *   console.log(value);\n     * });\n     * ```\n     */\n    Account.prototype.getBalance = function (blockNumber) {\n        if (blockNumber === void 0) { blockNumber = 'latest'; }\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var balance, nonce, error_2;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 5, , 6]);\n                        if (!this.messenger) return [3 /*break*/, 3];\n                        return [4 /*yield*/, this.messenger.send(network_1.RPCMethod.GetBalance, [this.address, blockNumber], this.messenger.chainPrefix, this.messenger.currentShard || 0)];\n                    case 1:\n                        balance = _a.sent();\n                        return [4 /*yield*/, this.messenger.send(network_1.RPCMethod.GetTransactionCount, [this.address, blockNumber], this.messenger.chainPrefix, this.messenger.currentShard || 0)];\n                    case 2:\n                        nonce = _a.sent();\n                        if (balance.isError()) {\n                            throw balance.error.message;\n                        }\n                        if (nonce.isError()) {\n                            throw nonce.error.message;\n                        }\n                        this.balance = utils_1.hexToNumber(balance.result);\n                        this.nonce = Number.parseInt(utils_1.hexToNumber(nonce.result), 10);\n                        this.shardID = this.messenger.currentShard || 0;\n                        return [3 /*break*/, 4];\n                    case 3: throw new Error('No Messenger found');\n                    case 4: return [2 /*return*/, {\n                            balance: this.balance,\n                            nonce: this.nonce,\n                            shardID: this.shardID,\n                        }];\n                    case 5:\n                        error_2 = _a.sent();\n                        throw error_2;\n                    case 6: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * @function updateShards\n     */\n    Account.prototype.updateBalances = function (blockNumber) {\n        if (blockNumber === void 0) { blockNumber = 'latest'; }\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var shardProviders, shardProviders_1, shardProviders_1_1, _a, name_1, val, balanceObject, e_1_1, currentShard;\n            var e_1, _b;\n            return tslib_1.__generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        shardProviders = this.messenger.shardProviders;\n                        if (!(shardProviders.size > 1)) return [3 /*break*/, 10];\n                        _c.label = 1;\n                    case 1:\n                        _c.trys.push([1, 7, 8, 9]);\n                        shardProviders_1 = tslib_1.__values(shardProviders), shardProviders_1_1 = shardProviders_1.next();\n                        _c.label = 2;\n                    case 2:\n                        if (!!shardProviders_1_1.done) return [3 /*break*/, 6];\n                        _a = tslib_1.__read(shardProviders_1_1.value, 2), name_1 = _a[0], val = _a[1];\n                        return [4 /*yield*/, this.getShardBalance(val.shardID, blockNumber)];\n                    case 3:\n                        balanceObject = _c.sent();\n                        return [4 /*yield*/, this.shards.set(name_1 === val.shardID ? name_1 : val.shardID, balanceObject)];\n                    case 4:\n                        _c.sent();\n                        _c.label = 5;\n                    case 5:\n                        shardProviders_1_1 = shardProviders_1.next();\n                        return [3 /*break*/, 2];\n                    case 6: return [3 /*break*/, 9];\n                    case 7:\n                        e_1_1 = _c.sent();\n                        e_1 = { error: e_1_1 };\n                        return [3 /*break*/, 9];\n                    case 8:\n                        try {\n                            if (shardProviders_1_1 && !shardProviders_1_1.done && (_b = shardProviders_1.return)) _b.call(shardProviders_1);\n                        }\n                        finally { if (e_1) throw e_1.error; }\n                        return [7 /*endfinally*/];\n                    case 9: return [3 /*break*/, 12];\n                    case 10: return [4 /*yield*/, this.getShardBalance(this.messenger.currentShard || 0, blockNumber)];\n                    case 11:\n                        currentShard = _c.sent();\n                        this.shards.set(this.messenger.currentShard || 0, currentShard);\n                        _c.label = 12;\n                    case 12: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * @function signTransaction\n     */\n    Account.prototype.signTransaction = function (transaction, updateNonce, encodeMode, blockNumber) {\n        if (updateNonce === void 0) { updateNonce = true; }\n        if (encodeMode === void 0) { encodeMode = 'rlp'; }\n        if (blockNumber === void 0) { blockNumber = 'latest'; }\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var txShardID, shardNonce, _a, signature_1, rawTransaction_1;\n            var _this = this;\n            return tslib_1.__generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        if (!this.privateKey || !utils_1.isPrivateKey(this.privateKey)) {\n                            throw new Error(this.privateKey + \" is not found or not correct\");\n                        }\n                        if (!updateNonce) return [3 /*break*/, 2];\n                        txShardID = transaction.txParams.shardID;\n                        return [4 /*yield*/, this.getShardNonce(typeof txShardID === 'string' ? Number.parseInt(txShardID, 10) : txShardID, blockNumber)];\n                    case 1:\n                        shardNonce = _b.sent();\n                        transaction.setParams(tslib_1.__assign(tslib_1.__assign({}, transaction.txParams), { from: this.messenger.chainPrefix === utils_1.ChainType.Harmony\n                                ? this.bech32Address\n                                : this.checksumAddress || '0x', nonce: shardNonce }));\n                        _b.label = 2;\n                    case 2:\n                        if (encodeMode === 'rlp') {\n                            _a = tslib_1.__read(transaction_1.RLPSign(transaction, this.privateKey), 2), signature_1 = _a[0], rawTransaction_1 = _a[1];\n                            return [2 /*return*/, transaction.map(function (obj) {\n                                    return tslib_1.__assign(tslib_1.__assign({}, obj), { signature: signature_1,\n                                        rawTransaction: rawTransaction_1, from: _this.messenger.chainPrefix === utils_1.ChainType.Harmony\n                                            ? _this.bech32Address\n                                            : _this.checksumAddress || '0x' });\n                                })];\n                        }\n                        else {\n                            // TODO: if we use other encode method, eg. protobuf, we should implement this\n                            return [2 /*return*/, transaction];\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * This function is still in development, coming soon!\n     *\n     * @param staking\n     * @param updateNonce\n     * @param encodeMode\n     * @param blockNumber\n     * @param shardID\n     */\n    Account.prototype.signStaking = function (staking, updateNonce, encodeMode, blockNumber, shardID) {\n        if (updateNonce === void 0) { updateNonce = true; }\n        if (encodeMode === void 0) { encodeMode = 'rlp'; }\n        if (blockNumber === void 0) { blockNumber = 'latest'; }\n        if (shardID === void 0) { shardID = this.messenger.currentShard; }\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var txShardID, shardNonce, _a, signature, rawTransaction;\n            return tslib_1.__generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        if (!this.privateKey || !utils_1.isPrivateKey(this.privateKey)) {\n                            throw new Error(this.privateKey + \" is not found or not correct\");\n                        }\n                        if (!updateNonce) return [3 /*break*/, 2];\n                        txShardID = shardID;\n                        return [4 /*yield*/, this.getShardNonce(typeof txShardID === 'string' ? Number.parseInt(txShardID, 10) : txShardID, blockNumber)];\n                    case 1:\n                        shardNonce = _b.sent();\n                        staking.setFromAddress(this.messenger.chainPrefix === utils_1.ChainType.Harmony\n                            ? this.bech32Address\n                            : this.checksumAddress || '0x');\n                        staking.setNonce(shardNonce);\n                        _b.label = 2;\n                    case 2:\n                        if (encodeMode === 'rlp') {\n                            _a = tslib_1.__read(staking.rlpSign(this.privateKey), 2), signature = _a[0], rawTransaction = _a[1];\n                            staking.setRawTransaction(rawTransaction);\n                            staking.setSignature(signature);\n                            staking.setFromAddress(this.messenger.chainPrefix === utils_1.ChainType.Harmony\n                                ? this.bech32Address\n                                : this.checksumAddress || '0x');\n                            return [2 /*return*/, staking];\n                        }\n                        else {\n                            // TODO: if we use other encode method, eg. protobuf, we should implement this\n                            return [2 /*return*/, staking];\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * @param messenger\n     *\n     * @example\n     * ```javascript\n     * // create a custom messenger\n     * const customMessenger = new Messenger(\n     *   new HttpProvider('http://localhost:9500'),\n     *   ChainType.Harmony, // if you are connected to Harmony's blockchain\n     *   ChainID.HmyLocal, // check if the chainId is correct\n     * )\n     *\n     * // to create an Account with random privateKey\n     * // and you can setMessenger later\n     * const randomAccount = new Account()\n     * randomAccount.setMessenger(customMessenger)\n     * ```\n     */\n    Account.prototype.setMessenger = function (messenger) {\n        this.messenger = messenger;\n    };\n    /**\n     * Get account address from shard ID\n     * @param shardID\n     *\n     * @example\n     * ```javascript\n     * console.log(account.getAddressFromShardID(0));\n     *\n     * > one103q7qe5t2505lypvltkqtddaef5tzfxwsse4z7-0\n     * ```\n     */\n    Account.prototype.getAddressFromShardID = function (shardID) {\n        var shardObject = this.shards.get(shardID);\n        if (shardObject) {\n            return shardObject.address;\n        }\n        else {\n            return undefined;\n        }\n    };\n    /**\n     * Get all shards' addresses from the account\n     *\n     * @example\n     * ```javascript\n     * console.log(account.getAddresses());\n     * ```\n     */\n    Account.prototype.getAddresses = function () {\n        var e_2, _a;\n        var addressArray = [];\n        try {\n            for (var _b = tslib_1.__values(this.shards), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var _d = tslib_1.__read(_c.value, 2), name_2 = _d[0], val = _d[1];\n                var index = typeof name_2 === 'string' ? Number.parseInt(name_2, 10) : name_2;\n                addressArray[index] = val.address;\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n        return addressArray;\n    };\n    /**\n     * Get the specific shard's balance\n     *\n     * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n     * @param blockNumber by default, it's `latest`\n     *\n     * @example\n     * ```\n     * account.getShardBalance().then((value) => {\n     *   console.log(value);\n     * });\n     * ```\n     */\n    Account.prototype.getShardBalance = function (shardID, blockNumber) {\n        if (blockNumber === void 0) { blockNumber = 'latest'; }\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var balance, nonce;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.messenger.send(network_1.RPCMethod.GetBalance, [this.address, blockNumber], this.messenger.chainPrefix, shardID)];\n                    case 1:\n                        balance = _a.sent();\n                        return [4 /*yield*/, this.messenger.send(network_1.RPCMethod.GetTransactionCount, [this.address, blockNumber], this.messenger.chainPrefix, shardID)];\n                    case 2:\n                        nonce = _a.sent();\n                        if (balance.isError()) {\n                            throw balance.error.message;\n                        }\n                        if (nonce.isError()) {\n                            throw nonce.error.message;\n                        }\n                        return [2 /*return*/, {\n                                address: \"\" + this.bech32Address + utils_1.AddressSuffix + shardID,\n                                balance: utils_1.hexToNumber(balance.result),\n                                nonce: Number.parseInt(utils_1.hexToNumber(nonce.result), 10),\n                            }];\n                }\n            });\n        });\n    };\n    /**\n     * Get the specific shard's nonce\n     *\n     * @param shardID `shardID` is binding with the endpoint, IGNORE it!\n     * @param blockNumber by default, it's `latest`\n     *\n     * @example\n     * ```\n     * account.getShardNonce().then((value) => {\n     *   console.log(value);\n     * });\n     * ```\n     */\n    Account.prototype.getShardNonce = function (shardID, blockNumber) {\n        if (blockNumber === void 0) { blockNumber = 'latest'; }\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var nonce;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.messenger.send(network_1.RPCMethod.GetAccountNonce, [this.address, blockNumber], this.messenger.chainPrefix, shardID)];\n                    case 1:\n                        nonce = _a.sent();\n                        if (nonce.isError()) {\n                            throw nonce.error.message;\n                        }\n                        return [2 /*return*/, nonce.result];\n                }\n            });\n        });\n    };\n    /**\n     * @function _new private method create Account\n     * @return {Account} Account instance\n     * @ignore\n     */\n    Account.prototype._new = function () {\n        var prv = crypto_1.generatePrivateKey();\n        if (!utils_1.isPrivateKey(prv)) {\n            throw new Error('key gen failed');\n        }\n        return this._import(prv);\n    };\n    /**\n     * @function _import private method import a private Key\n     * @param  {string} key - private key\n     * @return {Account} Account instance\n     * @ignore\n     */\n    Account.prototype._import = function (key) {\n        if (!utils_1.isPrivateKey(key)) {\n            throw new Error(key + \" is not PrivateKey\");\n        }\n        this.privateKey = utils_1.add0xToString(key);\n        this.publicKey = crypto_1.getPubkeyFromPrivateKey(this.privateKey);\n        this.address = crypto_1.getAddressFromPrivateKey(this.privateKey);\n        this.shardID = this.messenger.currentShard || 0;\n        this.shards = new Map();\n        this.shards.set(this.shardID, {\n            address: \"\" + this.bech32Address + utils_1.AddressSuffix + \"0\",\n            balance: this.balance || '0',\n            nonce: this.nonce || 0,\n        });\n        this.encrypted = false;\n        return this;\n    };\n    return Account;\n}());\nexports.Account = Account;\n//# sourceMappingURL=account.js.map"]},"metadata":{},"sourceType":"script"}