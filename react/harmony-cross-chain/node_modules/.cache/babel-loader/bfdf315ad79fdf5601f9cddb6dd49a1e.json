{"ast":null,"code":"\"use strict\";\n/**\n * @packageDocumentation\n * @module harmony-crypto\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validatePrivateKey = exports.isValidChecksumAddress = exports.recoverAddress = exports.recoverPublicKey = exports.verifySignature = exports.getContractAddress = exports.sign = exports.toChecksumAddress = exports.getAddressFromPublicKey = exports.getPublic = exports.getAddressFromPrivateKey = exports.getPubkeyFromPrivateKey = exports.generatePrivateKey = void 0;\n\nvar tslib_1 = require(\"tslib\");\n\nvar elliptic_1 = tslib_1.__importDefault(require(\"elliptic\"));\n\nvar bytes = tslib_1.__importStar(require(\"./bytes\"));\n\nvar errors = tslib_1.__importStar(require(\"./errors\"));\n\nvar keccak256_1 = require(\"./keccak256\");\n\nvar random_1 = require(\"./random\");\n\nvar utils_1 = require(\"@harmony-js/utils\");\n\nvar bech32_1 = require(\"./bech32\");\n\nvar rlp_1 = require(\"./rlp\");\n\nvar secp256k1 = elliptic_1.default.ec('secp256k1');\n/**\n * @function generatePrivateKey\n * @description generatePrivate key using `eth-lib` settings\n * @return {string}\n */\n\nexports.generatePrivateKey = function () {\n  var entropy = '0x' + random_1.randomBytes(16);\n  var innerHex = keccak256_1.keccak256(bytes.concat(['0x' + random_1.randomBytes(32), entropy || '0x' + random_1.randomBytes(32)]));\n  var middleHex = bytes.concat([bytes.concat(['0x' + random_1.randomBytes(32), innerHex]), '0x' + random_1.randomBytes(32)]);\n  var outerHex = keccak256_1.keccak256(middleHex);\n  return outerHex;\n};\n/**\n * @function getPubkeyFromPrivateKey\n * @param  {string} privateKey - private key String\n * @return {string}\n */\n\n\nexports.getPubkeyFromPrivateKey = function (privateKey) {\n  return '0x' + exports.getPublic(privateKey, true);\n};\n/**\n * @function getAddressFromPrivateKey\n * @param  {string} privateKey - private key string\n * @return {string} address with `length = 40`\n */\n\n\nexports.getAddressFromPrivateKey = function (privateKey) {\n  var publicHash = '0x' + exports.getPublic(privateKey).slice(2);\n  var publicKey = keccak256_1.keccak256(publicHash);\n  var address = '0x' + publicKey.slice(-40);\n  return address;\n};\n\nexports.getPublic = function (privateKey, compress) {\n  if (!utils_1.isPrivateKey(privateKey) || !exports.validatePrivateKey(privateKey)) {\n    throw new Error(privateKey + \" is not PrivateKey\");\n  }\n\n  var ecKey = secp256k1.keyFromPrivate(utils_1.strip0x(privateKey), 'hex');\n  return ecKey.getPublic(compress || false, 'hex');\n};\n/**\n * @function getAddressFromPublicKey\n * @param  {string} publicKey - public key string\n * @return {string} address with `length = 40`\n */\n\n\nexports.getAddressFromPublicKey = function (publicKey) {\n  var ecKey = secp256k1.keyFromPublic(publicKey.slice(2), 'hex');\n  var publicHash = ecKey.getPublic(false, 'hex');\n  var address = '0x' + keccak256_1.keccak256('0x' + publicHash.slice(2)).slice(-40);\n  return address;\n};\n/**\n * @function toChecksumAddress\n * @param  {string} address - raw address\n * @return {string} checksumed address\n */\n\n\nexports.toChecksumAddress = function (address) {\n  if (typeof address === 'string' && utils_1.isBech32Address(address)) {\n    address = bech32_1.fromBech32(address);\n  }\n\n  if (typeof address !== 'string' || !address.match(/^0x[0-9A-Fa-f]{40}$/)) {\n    errors.throwError('invalid address', errors.INVALID_ARGUMENT, {\n      arg: 'address',\n      value: address\n    });\n  }\n\n  address = address.toLowerCase();\n  var chars = address.substring(2).split('');\n  var hashed = new Uint8Array(40);\n\n  for (var i = 0; i < 40; i++) {\n    hashed[i] = chars[i].charCodeAt(0);\n  }\n\n  hashed = bytes.arrayify(keccak256_1.keccak256(hashed)) || hashed;\n\n  for (var i = 0; i < 40; i += 2) {\n    if (hashed[i >> 1] >> 4 >= 8) {\n      chars[i] = chars[i].toUpperCase();\n    }\n\n    if ((hashed[i >> 1] & 0x0f) >= 8) {\n      chars[i + 1] = chars[i + 1].toUpperCase();\n    }\n  }\n\n  return '0x' + chars.join('');\n};\n\nexports.sign = function (digest, privateKey) {\n  if (!utils_1.isPrivateKey(privateKey)) {\n    throw new Error(privateKey + \" is not PrivateKey\");\n  }\n\n  var keyPair = secp256k1.keyFromPrivate(utils_1.strip0x(privateKey), 'hex');\n  var signature = keyPair.sign(bytes.arrayify(digest), {\n    canonical: true\n  });\n  var publicKey = '0x' + keyPair.getPublic(true, 'hex');\n  var result = {\n    recoveryParam: signature.recoveryParam,\n    r: bytes.hexZeroPad('0x' + signature.r.toString(16), 32),\n    s: bytes.hexZeroPad('0x' + signature.s.toString(16), 32),\n    v: 27 + signature.recoveryParam\n  };\n\n  if (verifySignature(digest, result, publicKey)) {\n    return result;\n  } else {\n    throw new Error('signing process failed');\n  }\n};\n\nfunction getContractAddress(from, nonce) {\n  if (!from) {\n    throw new Error('missing from address');\n  }\n\n  var addr = keccak256_1.keccak256(rlp_1.encode([from, bytes.stripZeros(bytes.hexlify(nonce))]));\n  return '0x' + addr.substring(26);\n}\n\nexports.getContractAddress = getContractAddress;\n\nfunction verifySignature(digest, signature, publicKey) {\n  return recoverPublicKey(digest, signature) === publicKey;\n}\n\nexports.verifySignature = verifySignature;\n\nfunction recoverPublicKey(digest, signature) {\n  var sig = bytes.splitSignature(signature);\n  var rs = {\n    r: bytes.arrayify(sig.r),\n    s: bytes.arrayify(sig.s)\n  }; ////\n\n  var recovered = secp256k1.recoverPubKey(bytes.arrayify(digest), rs, sig.recoveryParam);\n  var key = recovered.encode('hex', false);\n  var ecKey = secp256k1.keyFromPublic(key, 'hex');\n  var publicKey = '0x' + ecKey.getPublic(true, 'hex'); ///\n\n  return publicKey;\n}\n\nexports.recoverPublicKey = recoverPublicKey;\n\nfunction recoverAddress(digest, signature) {\n  return exports.getAddressFromPublicKey(recoverPublicKey(bytes.arrayify(digest) || new Uint8Array(), signature));\n}\n\nexports.recoverAddress = recoverAddress;\n/**\n * isValidChecksumAddress\n *\n * takes hex-encoded string and returns boolean if address is checksumed\n *\n * @param {string} address\n * @returns {boolean}\n */\n\nexports.isValidChecksumAddress = function (address) {\n  return utils_1.isAddress(address.replace('0x', '')) && exports.toChecksumAddress(address) === address;\n};\n\nexports.validatePrivateKey = function (privateKey) {\n  var ecKey = secp256k1.keyFromPrivate(utils_1.strip0x(privateKey), 'hex');\n  var result = ecKey.validate().result;\n  return result;\n};","map":{"version":3,"sources":["../src/keyTool.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n * @packageDocumentation\n * @module harmony-crypto\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validatePrivateKey = exports.isValidChecksumAddress = exports.recoverAddress = exports.recoverPublicKey = exports.verifySignature = exports.getContractAddress = exports.sign = exports.toChecksumAddress = exports.getAddressFromPublicKey = exports.getPublic = exports.getAddressFromPrivateKey = exports.getPubkeyFromPrivateKey = exports.generatePrivateKey = void 0;\nvar tslib_1 = require(\"tslib\");\nvar elliptic_1 = tslib_1.__importDefault(require(\"elliptic\"));\nvar bytes = tslib_1.__importStar(require(\"./bytes\"));\nvar errors = tslib_1.__importStar(require(\"./errors\"));\nvar keccak256_1 = require(\"./keccak256\");\nvar random_1 = require(\"./random\");\nvar utils_1 = require(\"@harmony-js/utils\");\nvar bech32_1 = require(\"./bech32\");\nvar rlp_1 = require(\"./rlp\");\nvar secp256k1 = elliptic_1.default.ec('secp256k1');\n/**\n * @function generatePrivateKey\n * @description generatePrivate key using `eth-lib` settings\n * @return {string}\n */\nexports.generatePrivateKey = function () {\n    var entropy = '0x' + random_1.randomBytes(16);\n    var innerHex = keccak256_1.keccak256(bytes.concat(['0x' + random_1.randomBytes(32), entropy || '0x' + random_1.randomBytes(32)]));\n    var middleHex = bytes.concat([\n        bytes.concat(['0x' + random_1.randomBytes(32), innerHex]),\n        '0x' + random_1.randomBytes(32),\n    ]);\n    var outerHex = keccak256_1.keccak256(middleHex);\n    return outerHex;\n};\n/**\n * @function getPubkeyFromPrivateKey\n * @param  {string} privateKey - private key String\n * @return {string}\n */\nexports.getPubkeyFromPrivateKey = function (privateKey) {\n    return '0x' + exports.getPublic(privateKey, true);\n};\n/**\n * @function getAddressFromPrivateKey\n * @param  {string} privateKey - private key string\n * @return {string} address with `length = 40`\n */\nexports.getAddressFromPrivateKey = function (privateKey) {\n    var publicHash = '0x' + exports.getPublic(privateKey).slice(2);\n    var publicKey = keccak256_1.keccak256(publicHash);\n    var address = '0x' + publicKey.slice(-40);\n    return address;\n};\nexports.getPublic = function (privateKey, compress) {\n    if (!utils_1.isPrivateKey(privateKey) || !exports.validatePrivateKey(privateKey)) {\n        throw new Error(privateKey + \" is not PrivateKey\");\n    }\n    var ecKey = secp256k1.keyFromPrivate(utils_1.strip0x(privateKey), 'hex');\n    return ecKey.getPublic(compress || false, 'hex');\n};\n/**\n * @function getAddressFromPublicKey\n * @param  {string} publicKey - public key string\n * @return {string} address with `length = 40`\n */\nexports.getAddressFromPublicKey = function (publicKey) {\n    var ecKey = secp256k1.keyFromPublic(publicKey.slice(2), 'hex');\n    var publicHash = ecKey.getPublic(false, 'hex');\n    var address = '0x' + keccak256_1.keccak256('0x' + publicHash.slice(2)).slice(-40);\n    return address;\n};\n/**\n * @function toChecksumAddress\n * @param  {string} address - raw address\n * @return {string} checksumed address\n */\nexports.toChecksumAddress = function (address) {\n    if (typeof address === 'string' && utils_1.isBech32Address(address)) {\n        address = bech32_1.fromBech32(address);\n    }\n    if (typeof address !== 'string' || !address.match(/^0x[0-9A-Fa-f]{40}$/)) {\n        errors.throwError('invalid address', errors.INVALID_ARGUMENT, {\n            arg: 'address',\n            value: address,\n        });\n    }\n    address = address.toLowerCase();\n    var chars = address.substring(2).split('');\n    var hashed = new Uint8Array(40);\n    for (var i = 0; i < 40; i++) {\n        hashed[i] = chars[i].charCodeAt(0);\n    }\n    hashed = bytes.arrayify(keccak256_1.keccak256(hashed)) || hashed;\n    for (var i = 0; i < 40; i += 2) {\n        if (hashed[i >> 1] >> 4 >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 0x0f) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n    return '0x' + chars.join('');\n};\nexports.sign = function (digest, privateKey) {\n    if (!utils_1.isPrivateKey(privateKey)) {\n        throw new Error(privateKey + \" is not PrivateKey\");\n    }\n    var keyPair = secp256k1.keyFromPrivate(utils_1.strip0x(privateKey), 'hex');\n    var signature = keyPair.sign(bytes.arrayify(digest), { canonical: true });\n    var publicKey = '0x' + keyPair.getPublic(true, 'hex');\n    var result = {\n        recoveryParam: signature.recoveryParam,\n        r: bytes.hexZeroPad('0x' + signature.r.toString(16), 32),\n        s: bytes.hexZeroPad('0x' + signature.s.toString(16), 32),\n        v: 27 + signature.recoveryParam,\n    };\n    if (verifySignature(digest, result, publicKey)) {\n        return result;\n    }\n    else {\n        throw new Error('signing process failed');\n    }\n};\nfunction getContractAddress(from, nonce) {\n    if (!from) {\n        throw new Error('missing from address');\n    }\n    var addr = keccak256_1.keccak256(rlp_1.encode([from, bytes.stripZeros(bytes.hexlify(nonce))]));\n    return '0x' + addr.substring(26);\n}\nexports.getContractAddress = getContractAddress;\nfunction verifySignature(digest, signature, publicKey) {\n    return recoverPublicKey(digest, signature) === publicKey;\n}\nexports.verifySignature = verifySignature;\nfunction recoverPublicKey(digest, signature) {\n    var sig = bytes.splitSignature(signature);\n    var rs = { r: bytes.arrayify(sig.r), s: bytes.arrayify(sig.s) };\n    ////\n    var recovered = secp256k1.recoverPubKey(bytes.arrayify(digest), rs, sig.recoveryParam);\n    var key = recovered.encode('hex', false);\n    var ecKey = secp256k1.keyFromPublic(key, 'hex');\n    var publicKey = '0x' + ecKey.getPublic(true, 'hex');\n    ///\n    return publicKey;\n}\nexports.recoverPublicKey = recoverPublicKey;\nfunction recoverAddress(digest, signature) {\n    return exports.getAddressFromPublicKey(recoverPublicKey(bytes.arrayify(digest) || new Uint8Array(), signature));\n}\nexports.recoverAddress = recoverAddress;\n/**\n * isValidChecksumAddress\n *\n * takes hex-encoded string and returns boolean if address is checksumed\n *\n * @param {string} address\n * @returns {boolean}\n */\nexports.isValidChecksumAddress = function (address) {\n    return utils_1.isAddress(address.replace('0x', '')) && exports.toChecksumAddress(address) === address;\n};\nexports.validatePrivateKey = function (privateKey) {\n    var ecKey = secp256k1.keyFromPrivate(utils_1.strip0x(privateKey), 'hex');\n    var result = ecKey.validate().result;\n    return result;\n};\n//# sourceMappingURL=keyTool.js.map"]},"metadata":{},"sourceType":"script"}