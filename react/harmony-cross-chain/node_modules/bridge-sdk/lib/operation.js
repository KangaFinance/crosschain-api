"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.operation = void 0;
const logs_1 = require("./utils/logs");
const interfaces_1 = require("./interfaces");
const operation_helpers_1 = require("./operation-helpers");
const ethToOne_1 = require("./operations/ethToOne");
const oneToEth_1 = require("./operations/oneToEth");
const oneToEthErc20_1 = require("./operations/oneToEthErc20");
const ethToOneErc20_1 = require("./operations/ethToOneErc20");
const oneDeposit_1 = require("./operations/oneDeposit");
const ethToOneErc721_1 = require("./operations/ethToOneErc721");
const oneToEthErc721_1 = require("./operations/oneToEthErc721");
exports.operation = async (params, callback) => {
    const { api, oneAddress, ethAddress, web3Client, hmyClient, token, type, amount, erc20Address, maxWaitingTime, } = params;
    const prefix = `[${token.toUpperCase()}: ${type.toUpperCase()}]`;
    try {
        logs_1.logger.start({ prefix, message: `test ${token.toUpperCase()}: ${type.toUpperCase()}` });
        const ethBalanceBefore = await operation_helpers_1.getEthBalance(web3Client, token, ethAddress, erc20Address);
        const oneBalanceBefore = await operation_helpers_1.getOneBalance(hmyClient, web3Client, token, oneAddress, erc20Address);
        const operationParams = {
            oneAddress,
            ethAddress,
            amount,
            type,
            token,
            erc20Address,
            network: params.network,
        };
        logs_1.logger.info({ prefix, message: 'ONE balance before: ' + oneBalanceBefore });
        logs_1.logger.info({ prefix, message: 'ETH balance before: ' + ethBalanceBefore });
        logs_1.logger.pending({ prefix, message: 'create operation' });
        let operation;
        operation = await api.createOperation(operationParams);
        if (operation && callback) {
            callback(operation.id);
        }
        operation_helpers_1.logOperationParams(operation, prefix);
        logs_1.logger.success({ prefix, message: 'create operation' });
        logs_1.logger.info({ prefix, message: 'operation ID: ' + operation.id });
        let ethMethods, hmyMethods;
        if (type === interfaces_1.EXCHANGE_MODE.ONE_TO_ETH) {
            await oneDeposit_1.depositOne(api, operation, ethMethods, hmyClient.hmyMethodsDeposit, prefix);
        }
        switch (token) {
            case interfaces_1.TOKEN.BUSD:
                hmyMethods = hmyClient.hmyMethodsBUSD;
                ethMethods = web3Client.ethMethodsBUSD;
                break;
            case interfaces_1.TOKEN.LINK:
                hmyMethods = hmyClient.hmyMethodsLINK;
                ethMethods = web3Client.ethMethodsLINK;
                break;
        }
        let res = false;
        if (token === interfaces_1.TOKEN.ERC20) {
            if (type === interfaces_1.EXCHANGE_MODE.ETH_TO_ONE) {
                res = await ethToOneErc20_1.ethToOneErc20(api, operation, web3Client.ethMethodsERC20, hmyClient.hmyMethodsERC20, prefix, maxWaitingTime);
            }
            if (type === interfaces_1.EXCHANGE_MODE.ONE_TO_ETH) {
                res = await oneToEthErc20_1.oneToEthErc20(api, operation, web3Client.ethMethodsERC20, hmyClient.hmyMethodsERC20, prefix, maxWaitingTime);
            }
        }
        if (token === interfaces_1.TOKEN.ERC721) {
            if (type === interfaces_1.EXCHANGE_MODE.ETH_TO_ONE) {
                res = await ethToOneErc721_1.ethToOneErc721(api, operation, web3Client.ethMethodsERС721, hmyClient.hmyMethodsERC20, prefix, maxWaitingTime);
            }
            if (type === interfaces_1.EXCHANGE_MODE.ONE_TO_ETH) {
                res = await oneToEthErc721_1.oneToEthErc721(api, operation, web3Client.ethMethodsERС721, hmyClient.hmyMethodsERC721, prefix, maxWaitingTime);
            }
        }
        if ([interfaces_1.TOKEN.BUSD, interfaces_1.TOKEN.LINK].includes(token)) {
            if (type === interfaces_1.EXCHANGE_MODE.ETH_TO_ONE) {
                res = await ethToOne_1.ethToOne(api, operation, ethMethods, prefix, maxWaitingTime);
            }
            if (type === interfaces_1.EXCHANGE_MODE.ONE_TO_ETH) {
                res = await oneToEth_1.oneToEth(api, operation, ethMethods, hmyMethods, prefix, maxWaitingTime);
            }
        }
        if (!res) {
            return false;
        }
        operation = await api.getOperation(operation.id);
        if (!operation_helpers_1.checkStatus(operation, prefix, 'operation')) {
            return false;
        }
        logs_1.logger.success({ prefix, message: 'operation OK' });
        return true;
    }
    catch (e) {
        console.log(e);
        let error;
        if (e && e.status && e.response.body) {
            error = e.response.body.message;
        }
        else {
            error = e ? e.message : 'unknown';
        }
        logs_1.logger.error({ prefix, message: error });
        throw new Error(error);
        return false;
    }
};
