"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.operation = void 0;
const logs_1 = require("./utils/logs");
const interfaces_1 = require("./interfaces");
const operation_helpers_1 = require("./operation-helpers");
const ethToOne_1 = require("./operations/ethToOne");
const oneToEth_1 = require("./operations/oneToEth");
const oneToEthErc20_1 = require("./operations/oneToEthErc20");
const ethToOneErc20_1 = require("./operations/ethToOneErc20");
const bignumber_js_1 = require("bignumber.js");
exports.operation = async (params) => {
    const { api, oneAddress, ethAddress, web3Client, hmyClient, token, type, amount, erc20Address, maxWaitingTime, } = params;
    const prefix = `[${token.toUpperCase()}: ${type.toUpperCase()}]`;
    try {
        logs_1.logger.start({ prefix, message: `test ${token.toUpperCase()}: ${type.toUpperCase()}` });
        const ethBalanceBefore = await operation_helpers_1.getEthBalance(web3Client, token, erc20Address);
        const oneBalanceBefore = await operation_helpers_1.getOneBalance(hmyClient, web3Client, token, erc20Address);
        const operationParams = {
            oneAddress,
            ethAddress,
            amount,
            type,
            token,
            erc20Address,
        };
        logs_1.logger.info({ prefix, message: 'ONE balance before: ' + oneBalanceBefore });
        logs_1.logger.info({ prefix, message: 'ETH balance before: ' + ethBalanceBefore });
        logs_1.logger.pending({ prefix, message: 'create operation' });
        let operation;
        operation = await api.createOperation(operationParams);
        operation_helpers_1.logOperationParams(operation, prefix);
        logs_1.logger.success({ prefix, message: 'create operation' });
        logs_1.logger.info({ prefix, message: 'operation ID: ' + operation.id });
        let ethMethods, hmyMethods;
        switch (token) {
            case interfaces_1.TOKEN.BUSD:
                hmyMethods = hmyClient.hmyMethodsBUSD;
                ethMethods = web3Client.ethMethodsBUSD;
                break;
            case interfaces_1.TOKEN.LINK:
                hmyMethods = hmyClient.hmyMethodsLINK;
                ethMethods = web3Client.ethMethodsLINK;
                break;
        }
        let res = false;
        if (token === interfaces_1.TOKEN.ERC20) {
            if (type === interfaces_1.EXCHANGE_MODE.ETH_TO_ONE) {
                res = await ethToOneErc20_1.ethToOneErc20(api, operation, web3Client.ethMethodsERC20, hmyClient.hmyMethodsERC20, prefix, maxWaitingTime);
            }
            if (type === interfaces_1.EXCHANGE_MODE.ONE_TO_ETH) {
                res = await oneToEthErc20_1.oneToEthErc20(api, operation, web3Client.ethMethodsERC20, hmyClient.hmyMethodsERC20, prefix, maxWaitingTime);
            }
        }
        else {
            if (type === interfaces_1.EXCHANGE_MODE.ETH_TO_ONE) {
                res = await ethToOne_1.ethToOne(api, operation, ethMethods, prefix, maxWaitingTime);
            }
            if (type === interfaces_1.EXCHANGE_MODE.ONE_TO_ETH) {
                res = await oneToEth_1.oneToEth(api, operation, ethMethods, hmyMethods, prefix, maxWaitingTime);
            }
        }
        if (!res) {
            return false;
        }
        operation = await api.getOperation(operation.id);
        if (!operation_helpers_1.checkStatus(operation, prefix, 'operation')) {
            return false;
        }
        const ethBalanceAfter = await operation_helpers_1.getEthBalance(web3Client, token, erc20Address);
        logs_1.logger.info({ prefix, message: 'ETH balance before: ' + ethBalanceBefore });
        logs_1.logger.info({ prefix, message: 'ETH balance after: ' + ethBalanceAfter });
        const ethBalanceWrong = type === interfaces_1.EXCHANGE_MODE.ETH_TO_ONE
            ? !new bignumber_js_1.BigNumber(ethBalanceBefore).minus(operationParams.amount).isEqualTo(ethBalanceAfter)
            : !new bignumber_js_1.BigNumber(ethBalanceBefore).plus(operationParams.amount).isEqualTo(ethBalanceAfter);
        if (ethBalanceWrong) {
            logs_1.logger.error({ prefix, message: 'Wrong ETH balance after' });
            return false;
        }
        else {
            logs_1.logger.success({ prefix, message: 'ETH balance after OK' });
        }
        const oneBalanceAfter = await operation_helpers_1.getOneBalance(hmyClient, web3Client, token, erc20Address);
        logs_1.logger.info({ prefix, message: 'ONE balance before: ' + oneBalanceBefore });
        logs_1.logger.info({ prefix, message: 'ONE balance after: ' + oneBalanceAfter });
        const oneBalanceWrong = type === interfaces_1.EXCHANGE_MODE.ETH_TO_ONE
            ? !new bignumber_js_1.BigNumber(oneBalanceBefore).plus(operationParams.amount).isEqualTo(oneBalanceAfter)
            : !new bignumber_js_1.BigNumber(oneBalanceBefore).minus(operationParams.amount).isEqualTo(oneBalanceAfter);
        if (oneBalanceWrong) {
            logs_1.logger.error({ prefix, message: 'Wrong ONE balance after' });
            return false;
        }
        else {
            logs_1.logger.success({ prefix, message: 'ONE balance after OK' });
        }
        logs_1.logger.success({ prefix, message: 'operation OK' });
        return true;
    }
    catch (e) {
        console.log(e);
        let error;
        if (e && e.status && e.response.body) {
            error = e.response.body.message;
        }
        else {
            error = e ? e.message : 'unknown';
        }
        logs_1.logger.error({ prefix, message: error });
        return false;
    }
};
