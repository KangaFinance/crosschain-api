"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.confirmCallback = exports.getActionByType = exports.logOperationParams = exports.getOneBalance = exports.getEthBalance = exports.checkStatus = exports.waitAction = void 0;
const interfaces_1 = require("./interfaces");
const logs_1 = require("./utils/logs");
const utils_1 = require("./utils");
const utils_2 = require("./blockchain/utils");
const SLEEP_TIMEOUT_MS = 3000;
exports.waitAction = async (api, operationId, actionType, maxTimeoutSec = 300, prefix) => {
    logs_1.logger.wait({ prefix, message: `${actionType} (${maxTimeoutSec} sec)` });
    let operation = await api.getOperation(operationId);
    const getActionByType = (type) => operation.actions.find(a => a.type === type);
    let action = getActionByType(actionType);
    let maxTimeoutMs = maxTimeoutSec * 1000;
    while (maxTimeoutMs > 0 &&
        (action.status === interfaces_1.STATUS.IN_PROGRESS || action.status === interfaces_1.STATUS.WAITING)) {
        logs_1.logger.info({ prefix, message: `waiting ${actionType}` });
        operation = await api.getOperation(operation.id);
        action = getActionByType(actionType);
        await utils_1.sleep(SLEEP_TIMEOUT_MS);
        maxTimeoutMs = maxTimeoutMs - SLEEP_TIMEOUT_MS;
    }
    if (maxTimeoutMs <= 0) {
        throw new Error(`${actionType} time is out (${maxTimeoutSec} sec)`);
    }
    return action;
};
exports.checkStatus = (operation, prefix, actionName) => {
    if (operation.status === interfaces_1.STATUS.SUCCESS) {
        logs_1.logger.success({ prefix, message: `${actionName} ${operation.status}` });
        return true;
    }
    if (operation.status === interfaces_1.STATUS.ERROR) {
        logs_1.logger.error({ prefix, message: `${actionName} ${operation.status}` });
        return false;
    }
    return false;
};
exports.getEthBalance = async (web3Client, token, address, erc20) => {
    let res = 0;
    let balance = 0;
    switch (token) {
        case interfaces_1.TOKEN.BUSD:
            res = await web3Client.ethMethodsBUSD.checkEthBalance(address);
            return utils_2.divDecimals(res, 18);
        case interfaces_1.TOKEN.LINK:
            res = await web3Client.ethMethodsLINK.checkEthBalance(address);
            return utils_2.divDecimals(res, 18);
        case interfaces_1.TOKEN.ERC20:
            const erc20TokenDetails = await web3Client.ethMethodsERC20.tokenDetails(erc20);
            if (!erc20TokenDetails) {
                return 0;
            }
            balance = await web3Client.ethMethodsERC20.checkEthBalance(erc20, address);
            return utils_2.divDecimals(balance, erc20TokenDetails.decimals);
        case interfaces_1.TOKEN.ERC721:
            balance = await web3Client.ethMethodsERÐ¡721.checkEthBalance(erc20, address);
            return balance;
    }
};
exports.getOneBalance = async (hmyClient, web3Client, token, address, erc20) => {
    let res = 0;
    switch (token) {
        case interfaces_1.TOKEN.BUSD:
            res = await hmyClient.hmyMethodsBUSD.checkHmyBalance(address);
            return utils_2.divDecimals(res, 18);
        case interfaces_1.TOKEN.LINK:
            res = await hmyClient.hmyMethodsLINK.checkHmyBalance(address);
        case interfaces_1.TOKEN.ERC721:
            res = await hmyClient.hmyMethodsLINK.checkHmyBalance(address);
            return utils_2.divDecimals(res, 18);
        case interfaces_1.TOKEN.ERC20:
            const hrc20Address = await hmyClient.hmyMethodsERC20.getMappingFor(erc20);
            const erc20TokenDetails = await web3Client.ethMethodsERC20.tokenDetails(erc20);
            if (!Number(hrc20Address) || !erc20TokenDetails) {
                return 0;
            }
            const balance = await hmyClient.hmyMethodsERC20.checkHmyBalance(hrc20Address, address);
            return utils_2.divDecimals(balance, erc20TokenDetails.decimals);
    }
};
exports.logOperationParams = (operationParams, prefix) => {
    logs_1.logger.info({ prefix, message: 'Operation: ' + operationParams.type });
    logs_1.logger.info({ prefix, message: 'Token: ' + operationParams.token });
    if (operationParams.erc20Address) {
        logs_1.logger.info({ prefix, message: 'ERC20 address: ' + operationParams.erc20Address });
    }
    logs_1.logger.info({ prefix, message: 'Amount: ' + operationParams.amount });
    logs_1.logger.info({ prefix, message: 'ONE address: ' + operationParams.oneAddress });
    logs_1.logger.info({ prefix, message: 'ETH address: ' + operationParams.ethAddress });
};
exports.getActionByType = (operation, type) => operation.actions.find(a => a.type === type);
exports.confirmCallback = async (api, transactionHash, actionType, operationId) => {
    await api.confirmAction({
        operationId,
        transactionHash,
        actionType,
    });
};
