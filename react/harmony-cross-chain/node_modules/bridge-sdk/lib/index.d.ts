import { OperationClass } from './OperationClass';
export * from './interfaces';
export * from './configs';
import { IAPIParams, ICreateOperationParams, ValidatorsAPI } from './api';
import { IWeb3Client, IHmyClient } from './blockchain';
import { EXCHANGE_MODE, NETWORK_TYPE, TOKEN } from './interfaces';
import * as configs from './configs';
interface IBridgeSDKInitParams {
    api: IAPIParams;
    ethClient: typeof configs.mainnet.ethClient;
    binanceClient: typeof configs.mainnet.binanceClient;
    hmyClient: typeof configs.mainnet.hmyClient;
    sdk?: 'harmony' | 'web3';
}
interface IBridgeSDKOptions {
    logLevel?: number;
}
export declare class BridgeSDK {
    api: ValidatorsAPI;
    ethClient: IWeb3Client;
    bscClient: IWeb3Client;
    hmyClient: IHmyClient;
    constructor(params?: IBridgeSDKOptions);
    init: (params: IBridgeSDKInitParams) => Promise<void>;
    addOneWallet: (privateKey: string) => Promise<void>;
    addEthWallet: (privateKey: string) => Promise<void>;
    setUseMetamask: (value: boolean) => void;
    setUseOneWallet: (value: boolean) => void;
    setUseMathWallet: (value: boolean) => void;
    sendToken: (params: {
        type: EXCHANGE_MODE;
        token: TOKEN;
        amount: number;
        network?: NETWORK_TYPE;
        oneAddress: string;
        ethAddress: string;
        erc20Address?: string;
        maxWaitingTime?: number;
    }, callback?: (id: string) => void) => Promise<boolean>;
    createOperation: (params: ICreateOperationParams) => Promise<OperationClass>;
    restoreOperationById: (id: string) => Promise<OperationClass>;
}
