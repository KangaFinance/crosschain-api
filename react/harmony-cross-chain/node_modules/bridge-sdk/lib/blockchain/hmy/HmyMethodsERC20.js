"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HmyMethodsERC20 = void 0;
const tslib_1 = require("tslib");
const utils_1 = require("../utils");
const MyERC20_1 = tslib_1.__importDefault(require("../out/MyERC20"));
const helpers_1 = require("./helpers");
class HmyMethodsERC20 {
    constructor(params) {
        this.options = { gasPrice: 1000000000, gasLimit: 6721900 };
        this.useOneWallet = false;
        this.useMathWallet = false;
        this.setUseMetamask = (value) => value;
        this.setUseOneWallet = (value) => {
            if (!window || !window.onewallet) {
                throw new Error('OneWallet extension is not found');
            }
            this.useOneWallet = value;
        };
        this.setUseMathWallet = (value) => {
            if (!window || !window.harmony) {
                throw new Error('Math Wallet extension is not found');
            }
            this.useMathWallet = value;
        };
        this.approveHmyManger = (hrc20Address, amount, decimals, sendTxCallback) => {
            const hmyTokenContract = this.hmy.contracts.createContract(MyERC20_1.default, hrc20Address);
            return new Promise(async (resolve, reject) => {
                try {
                    if (this.useOneWallet) {
                        await helpers_1.connectToBrowserWallet(window.onewallet, this.hmy, hmyTokenContract.wallet, null, reject);
                    }
                    if (this.useMathWallet) {
                        await helpers_1.connectToBrowserWallet(window.harmony, this.hmy, hmyTokenContract.wallet, null, reject);
                    }
                    const res = await hmyTokenContract.methods
                        .approve(this.hmyManagerContract.address, utils_1.withDecimals(amount, decimals))
                        .send(this.options)
                        .on('transactionHash', sendTxCallback);
                    resolve(res);
                }
                catch (e) {
                    reject(e);
                }
            });
        };
        this.burnToken = async (hrc20Address, userAddr, amount, decimals, sendTxCallback) => {
            return new Promise(async (resolve, reject) => {
                try {
                    if (this.useOneWallet) {
                        await helpers_1.connectToBrowserWallet(window.onewallet, this.hmy, this.hmyManagerContract.wallet, null, reject);
                    }
                    if (this.useMathWallet) {
                        await helpers_1.connectToBrowserWallet(window.harmony, this.hmy, this.hmyManagerContract.wallet, null, reject);
                    }
                    const response = await this.hmyManagerContract.methods
                        .burnToken(hrc20Address, utils_1.withDecimals(amount, decimals), userAddr)
                        .send(this.options)
                        .on('transactionHash', sendTxCallback);
                    resolve(response);
                }
                catch (e) {
                    reject(e);
                }
            });
        };
        this.getMappingFor = async (erc20TokenAddr) => {
            const res = await this.hmyManagerContract.methods.mappings(erc20TokenAddr).call(this.options);
            return res;
        };
        this.checkHmyBalance = async (hrc20Address, addr) => {
            const hmyTokenContract = this.hmy.contracts.createContract(MyERC20_1.default, hrc20Address);
            const addrHex = this.hmy.crypto.getAddress(addr).checksum;
            return await hmyTokenContract.methods.balanceOf(addrHex).call(this.options);
        };
        this.totalSupply = async (hrc20Address) => {
            const hmyTokenContract = this.hmy.contracts.createContract(MyERC20_1.default, hrc20Address);
            return await hmyTokenContract.methods.totalSupply().call(this.options);
        };
        this.setApprovalForAll = (hrc20Address, sendTxCallback) => {
            const hmyTokenContract = this.hmy.contracts.createContract(MyERC20_1.default, hrc20Address);
            return new Promise(async (resolve, reject) => {
                try {
                    let hmyAddrHex;
                    if (this.useOneWallet) {
                        await helpers_1.connectToBrowserWallet(window.onewallet, this.hmy, this.hmyManagerContract.wallet, null, reject);
                        const { address } = await window.onewallet.getAccount();
                        hmyAddrHex = this.hmy.crypto.getAddress(address).checksum;
                    }
                    if (this.useMathWallet) {
                        await helpers_1.connectToBrowserWallet(window.harmony, this.hmy, this.hmyManagerContract.wallet, null, reject);
                        const { address } = await window.onewallet.getAccount();
                        hmyAddrHex = this.hmy.crypto.getAddress(address).checksum;
                    }
                    if (!this.useMathWallet && !this.useOneWallet) {
                        const address = this.hmy.wallet.accounts[0];
                        hmyAddrHex = this.hmy.crypto.getAddress(address).checksum;
                    }
                    let res = await hmyTokenContract.methods
                        .isApprovedForAll(hmyAddrHex, this.hmyManagerContract.address)
                        .call(this.options);
                    if (!res) {
                        res = await hmyTokenContract.methods
                            .setApprovalForAll(this.hmyManagerContract.address, true)
                            .send(this.options)
                            .on('transactionHash', sendTxCallback);
                        resolve(res);
                    }
                    else {
                        sendTxCallback('skip');
                        resolve(res);
                    }
                }
                catch (e) {
                    reject(e);
                }
            });
        };
        this.burnTokens = async (hrc20Address, userAddr, amount, sendTxCallback) => {
            return new Promise(async (resolve, reject) => {
                try {
                    if (this.useOneWallet) {
                        await helpers_1.connectToBrowserWallet(window.onewallet, this.hmy, this.hmyManagerContract.wallet, null, reject);
                    }
                    if (this.useMathWallet) {
                        await helpers_1.connectToBrowserWallet(window.harmony, this.hmy, this.hmyManagerContract.wallet, null, reject);
                    }
                    const userAddrHex = this.hmy.crypto.getAddress(userAddr).checksum;
                    const response = await this.hmyManagerContract.methods
                        .burnTokens(hrc20Address, amount, userAddrHex)
                        .send(this.options)
                        .on('transactionHash', sendTxCallback);
                    resolve(response);
                }
                catch (e) {
                    reject(e);
                }
            });
        };
        this.hmy = params.hmy;
        this.hmyManagerContract = params.hmyManagerContract;
        if (params.options) {
            this.options = params.options;
        }
    }
}
exports.HmyMethodsERC20 = HmyMethodsERC20;
