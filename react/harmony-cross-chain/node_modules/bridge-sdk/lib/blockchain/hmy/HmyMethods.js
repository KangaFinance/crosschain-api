"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HmyMethods = void 0;
const utils_1 = require("../utils");
const helpers_1 = require("./helpers");
class HmyMethods {
    constructor(params) {
        this.options = { gasPrice: 1000000000, gasLimit: 6721900 };
        this.useOneWallet = false;
        this.useMathWallet = false;
        this.setUseMetamask = (value) => value;
        this.setUseOneWallet = (value) => {
            if (!window || !window.onewallet) {
                throw new Error('OneWallet extension is not found');
            }
            this.useOneWallet = value;
        };
        this.setUseMathWallet = (value) => {
            if (!window || !window.harmony) {
                throw new Error('Math Wallet extension is not found');
            }
            this.useMathWallet = value;
        };
        this.approveHmyManger = (amount, sendTxCallback) => {
            return new Promise(async (resolve, reject) => {
                try {
                    if (this.useOneWallet) {
                        await helpers_1.connectToBrowserWallet(window.onewallet, this.hmy, this.hmyTokenContract.wallet, null, reject);
                    }
                    if (this.useMathWallet) {
                        await helpers_1.connectToBrowserWallet(window.harmony, this.hmy, this.hmyTokenContract.wallet, null, reject);
                    }
                    const res = await this.hmyTokenContract.methods
                        .approve(this.hmyManagerContract.address, utils_1.withDecimals(amount, 18))
                        .send(this.options)
                        .on('transactionHash', sendTxCallback);
                    resolve(res);
                }
                catch (e) {
                    reject(e);
                }
            });
        };
        this.burnToken = async (userAddr, amount, sendTxCallback) => {
            return new Promise(async (resolve, reject) => {
                try {
                    if (this.useOneWallet) {
                        await helpers_1.connectToBrowserWallet(window.onewallet, this.hmy, this.hmyManagerContract.wallet, null, reject);
                    }
                    if (this.useMathWallet) {
                        await helpers_1.connectToBrowserWallet(window.harmony, this.hmy, this.hmyManagerContract.wallet, null, reject);
                    }
                    const response = await this.hmyManagerContract.methods
                        .burnToken(utils_1.withDecimals(amount, 18), userAddr)
                        .send(this.options)
                        .on('transactionHash', sendTxCallback);
                    resolve(response);
                }
                catch (e) {
                    reject(e);
                }
            });
        };
        this.checkHmyBalance = async (addr) => {
            const addrHex = this.hmy.crypto.getAddress(addr).checksum;
            return await this.hmyTokenContract.methods.balanceOf(addrHex).call(this.options);
        };
        this.totalSupply = async () => {
            return await this.hmyTokenContract.methods.totalSupply().call(this.options);
        };
        this.hmy = params.hmy;
        this.hmyTokenContract = params.hmyTokenContract;
        this.hmyManagerContract = params.hmyManagerContract;
        if (params.options) {
            this.options = params.options;
        }
    }
}
exports.HmyMethods = HmyMethods;
