"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ethToOne = void 0;
const interfaces_1 = require("../interfaces");
const logs_1 = require("../utils/logs");
const operation_helpers_1 = require("../operation-helpers");
exports.ethToOne = async (api, operationParams, ethMethods, prefix, maxWaitingTime) => {
    let operation = await api.getOperation(operationParams.id);
    const approveEthManger = operation_helpers_1.getActionByType(operation, interfaces_1.ACTION_TYPE.approveEthManger);
    if (approveEthManger && approveEthManger.status === interfaces_1.STATUS.WAITING) {
        logs_1.logger.pending({ prefix, message: 'approveEthManger' });
        const res = await ethMethods.approveEthManger(operationParams.amount, (hash) => operation_helpers_1.confirmCallback(api, hash, approveEthManger.type, operation.id));
        logs_1.logger.info({ prefix, message: 'Status: ' + res.status });
        logs_1.logger.success({ prefix, message: 'approveEthManger' });
    }
    operation = await api.getOperation(operationParams.id);
    const lockToken = operation_helpers_1.getActionByType(operation, interfaces_1.ACTION_TYPE.lockToken);
    if (lockToken && lockToken.status === interfaces_1.STATUS.WAITING) {
        logs_1.logger.pending({ prefix, message: 'lockToken' });
        const res = await ethMethods.lockToken(operationParams.oneAddress, operationParams.amount, (hash) => operation_helpers_1.confirmCallback(api, hash, lockToken.type, operation.id));
        logs_1.logger.info({ prefix, message: 'Status: ' + res.status });
        logs_1.logger.success({ prefix, message: 'lockToken' });
    }
    const lockTokenAction = await operation_helpers_1.waitAction(api, operationParams.id, interfaces_1.ACTION_TYPE.lockToken, maxWaitingTime, prefix);
    if (!operation_helpers_1.checkStatus(lockTokenAction, prefix, interfaces_1.ACTION_TYPE.lockToken)) {
        return false;
    }
    const waitingBlockNumber = await operation_helpers_1.waitAction(api, operationParams.id, interfaces_1.ACTION_TYPE.waitingBlockNumber, maxWaitingTime, prefix);
    if (!operation_helpers_1.checkStatus(waitingBlockNumber, prefix, interfaces_1.ACTION_TYPE.waitingBlockNumber)) {
        return false;
    }
    const mintToken = await operation_helpers_1.waitAction(api, operationParams.id, interfaces_1.ACTION_TYPE.mintToken, maxWaitingTime, prefix);
    if (!operation_helpers_1.checkStatus(mintToken, prefix, interfaces_1.ACTION_TYPE.mintToken)) {
        return false;
    }
    return true;
};
