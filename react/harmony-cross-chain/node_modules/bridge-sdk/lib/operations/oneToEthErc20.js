"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.oneToEthErc20 = void 0;
const interfaces_1 = require("../interfaces");
const logs_1 = require("../utils/logs");
const operation_helpers_1 = require("../operation-helpers");
const utils_1 = require("../utils");
exports.oneToEthErc20 = async (api, operationParams, ethMethods, hmyMethods, prefix, maxWaitingTime) => {
    let operation = await api.getOperation(operationParams.id);
    let getHRC20Action = operation_helpers_1.getActionByType(operation, interfaces_1.ACTION_TYPE.getHRC20Address);
    if (getHRC20Action) {
        logs_1.logger.wait({ prefix, message: 'getHRC20Address' });
    }
    while (getHRC20Action && [interfaces_1.STATUS.IN_PROGRESS, interfaces_1.STATUS.WAITING].includes(getHRC20Action.status)) {
        await utils_1.sleep(3000);
        operation = await api.getOperation(operationParams.id);
        getHRC20Action = operation_helpers_1.getActionByType(operation, interfaces_1.ACTION_TYPE.getHRC20Address);
    }
    const erc20TokenDetails = await ethMethods.tokenDetails(operationParams.erc20Address);
    const hrc20Address = await hmyMethods.getMappingFor(operationParams.erc20Address);
    if (!hrc20Address) {
        throw new Error('hrc20Address not found');
    }
    const approveHmyManger = operation_helpers_1.getActionByType(operation, interfaces_1.ACTION_TYPE.approveHmyManger);
    if (approveHmyManger && approveHmyManger.status === interfaces_1.STATUS.WAITING) {
        logs_1.logger.pending({ prefix, message: 'approveHmyManger' });
        const res = await hmyMethods.approveHmyManger(hrc20Address, operationParams.amount, erc20TokenDetails.decimals, (hash) => operation_helpers_1.confirmCallback(api, hash, approveHmyManger.type, operationParams.id));
        logs_1.logger.info({ prefix, message: 'Status: ' + res.status });
        logs_1.logger.success({ prefix, message: 'approveHmyManger' });
    }
    operation = await api.getOperation(operationParams.id);
    const burnToken = operation_helpers_1.getActionByType(operation, interfaces_1.ACTION_TYPE.burnToken);
    if (burnToken && burnToken.status === interfaces_1.STATUS.WAITING) {
        logs_1.logger.pending({ prefix, message: 'burnToken' });
        const res = await hmyMethods.burnToken(hrc20Address, operationParams.ethAddress, operationParams.amount, erc20TokenDetails.decimals, (hash) => operation_helpers_1.confirmCallback(api, hash, burnToken.type, operationParams.id));
        logs_1.logger.info({ prefix, message: 'Status: ' + res.status });
        logs_1.logger.success({ prefix, message: 'burnToken' });
    }
    const unlockToken = await operation_helpers_1.waitAction(api, operationParams.id, interfaces_1.ACTION_TYPE.unlockToken, maxWaitingTime, prefix);
    if (!operation_helpers_1.checkStatus(unlockToken, prefix, interfaces_1.ACTION_TYPE.unlockToken)) {
        return false;
    }
    return true;
};
