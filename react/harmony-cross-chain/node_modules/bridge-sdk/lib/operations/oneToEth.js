"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.oneToEth = void 0;
const interfaces_1 = require("../interfaces");
const logs_1 = require("../utils/logs");
const operation_helpers_1 = require("../operation-helpers");
exports.oneToEth = async (api, operationParams, ethMethods, hmyMethods, prefix, maxWaitingTime) => {
    let operation = await api.getOperation(operationParams.id);
    const approveHmyManger = operation_helpers_1.getActionByType(operation, interfaces_1.ACTION_TYPE.approveHmyManger);
    if (approveHmyManger && approveHmyManger.status === interfaces_1.STATUS.WAITING) {
        logs_1.logger.pending({ prefix, message: 'approveHmyManger' });
        const res = await hmyMethods.approveHmyManger(operationParams.amount, (hash) => operation_helpers_1.confirmCallback(api, hash, approveHmyManger.type, operation.id));
        logs_1.logger.info({ prefix, message: 'Status: ' + res.status });
        logs_1.logger.success({ prefix, message: 'approveHmyManger' });
    }
    operation = await api.getOperation(operationParams.id);
    const burnToken = operation_helpers_1.getActionByType(operation, interfaces_1.ACTION_TYPE.burnToken);
    if (burnToken && burnToken.status === interfaces_1.STATUS.WAITING) {
        logs_1.logger.pending({ prefix, message: 'burnToken' });
        const res = await hmyMethods.burnToken(operationParams.ethAddress, operationParams.amount, (hash) => operation_helpers_1.confirmCallback(api, hash, burnToken.type, operation.id));
        logs_1.logger.info({ prefix, message: 'Status: ' + res.status });
        logs_1.logger.success({ prefix, message: 'burnToken' });
    }
    const unlockToken = await operation_helpers_1.waitAction(api, operationParams.id, interfaces_1.ACTION_TYPE.unlockToken, maxWaitingTime, prefix);
    if (!operation_helpers_1.checkStatus(unlockToken, prefix, interfaces_1.ACTION_TYPE.unlockToken)) {
        return false;
    }
    return true;
};
