"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HmyMethodsERC20Web3 = void 0;
const tslib_1 = require("tslib");
const utils_1 = require("../utils");
const MyERC20_1 = tslib_1.__importDefault(require("../out/MyERC20"));
const crypto_1 = require("@harmony-js/crypto");
const BN = require('bn.js');
class HmyMethodsERC20Web3 {
    constructor(params) {
        this.useMetamask = false;
        this.setUseOneWallet = (value) => value;
        this.setUseMathWallet = (value) => value;
        this.setUseMetamask = (value) => (this.useMetamask = value);
        this.approveHmyManger = async (hrc20Address, amount, decimals, sendTxCallback) => {
            const hmyTokenContract = new this.hmy.eth.Contract(MyERC20_1.default, hrc20Address);
            let accounts;
            if (this.useMetamask) {
                accounts = await ethereum.enable();
            }
            const res = await hmyTokenContract.methods
                .approve(this.hmyManagerContractAddress, utils_1.withDecimals(amount, decimals))
                .send({
                from: this.useMetamask ? accounts[0] : this.hmy.eth.defaultAccount,
                gasLimit: 6721900,
                gasPrice: new BN(await this.hmy.eth.getGasPrice()).mul(new BN(1)),
            })
                .on('transactionHash', sendTxCallback);
            return res;
        };
        this.burnToken = async (hrc20Address, userAddr, amount, decimals, sendTxCallback) => {
            let accounts;
            if (this.useMetamask) {
                accounts = await ethereum.enable();
            }
            const userAddrHex = crypto_1.getAddress(userAddr).checksum;
            const response = await this.hmyManagerContract.methods
                .burnToken(hrc20Address, utils_1.withDecimals(amount, decimals), userAddrHex)
                .send({
                from: this.useMetamask ? accounts[0] : this.hmy.eth.defaultAccount,
                gasLimit: 6721900,
                gasPrice: new BN(await this.hmy.eth.getGasPrice()).mul(new BN(1)),
            })
                .on('transactionHash', sendTxCallback);
            return response;
        };
        this.getMappingFor = async (erc20TokenAddr) => {
            const res = await this.hmyManagerContract.methods.mappings(erc20TokenAddr).call();
            return res;
        };
        this.checkHmyBalance = async (hrc20Address, addr) => {
            const hmyTokenContract = new this.hmy.eth.Contract(MyERC20_1.default, hrc20Address);
            const addrHex = crypto_1.getAddress(addr).checksum;
            return await hmyTokenContract.methods.balanceOf(addrHex).call();
        };
        this.totalSupply = async (hrc20Address) => {
            const hmyTokenContract = new this.hmy.eth.Contract(MyERC20_1.default, hrc20Address);
            return await hmyTokenContract.methods.totalSupply().call();
        };
        this.setApprovalForAll = async (hrc20Address, sendTxCallback) => {
            const hmyTokenContract = new this.hmy.eth.Contract(MyERC20_1.default, hrc20Address);
            let accounts;
            if (this.useMetamask) {
                accounts = await ethereum.enable();
            }
            let res = await hmyTokenContract.methods
                .isApprovedForAll(this.useMetamask ? accounts[0] : this.hmy.eth.defaultAccount, this.hmyManagerContractAddress)
                .call({
                from: this.useMetamask ? accounts[0] : this.hmy.eth.defaultAccount,
                gasLimit: 6721900,
                gasPrice: new BN(await this.hmy.eth.getGasPrice()).mul(new BN(1)),
            });
            if (!res) {
                res = await hmyTokenContract.methods
                    .setApprovalForAll(this.hmyManagerContractAddress, true)
                    .send({
                    from: this.useMetamask ? accounts[0] : this.hmy.eth.defaultAccount,
                    gasLimit: 6721900,
                    gasPrice: new BN(await this.hmy.eth.getGasPrice()).mul(new BN(1)),
                })
                    .on('transactionHash', sendTxCallback);
                return res;
            }
            else {
                sendTxCallback('skip');
                return res;
            }
        };
        this.burnTokens = async (hrc20Address, userAddr, amount, sendTxCallback) => {
            let accounts;
            if (this.useMetamask) {
                accounts = await ethereum.enable();
            }
            const userAddrHex = crypto_1.getAddress(userAddr).checksum;
            const response = await this.hmyManagerContract.methods
                .burnTokens(hrc20Address, amount, userAddrHex)
                .send({
                from: this.useMetamask ? accounts[0] : this.hmy.eth.defaultAccount,
                gasLimit: 6721900,
                gasPrice: new BN(await this.hmy.eth.getGasPrice()).mul(new BN(1)),
            })
                .on('transactionHash', sendTxCallback);
            return response;
        };
        this.hmy = params.hmy;
        this.hmyManagerContract = params.hmyManagerContract;
        this.hmyManagerContractAddress = params.hmyManagerContractAddress;
    }
}
exports.HmyMethodsERC20Web3 = HmyMethodsERC20Web3;
