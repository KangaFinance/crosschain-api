"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EthMethodsERC20 = void 0;
const tslib_1 = require("tslib");
const crypto_1 = require("@harmony-js/crypto");
const utils_1 = require("../utils");
const MyERC20_1 = tslib_1.__importDefault(require("../out/MyERC20"));
const BN = require('bn.js');
class EthMethodsERC20 {
    constructor(params) {
        this.useMetamask = false;
        this.setUseMetamask = (value) => (this.useMetamask = value);
        this.approveEthManger = async (erc20Address, amount, decimals, sendTxCallback) => {
            let accounts;
            if (this.useMetamask) {
                accounts = await ethereum.enable();
            }
            const erc20Contract = new this.web3.eth.Contract(MyERC20_1.default, erc20Address);
            return await erc20Contract.methods
                .approve(this.ethManagerAddress, utils_1.withDecimals(amount, decimals))
                .send({
                from: this.useMetamask ? accounts[0] : this.web3.eth.defaultAccount,
                gas: this.gasLimit,
                gasPrice: new BN(await this.web3.eth.getGasPrice()).mul(new BN(1)),
            })
                .on('transactionHash', (hash) => sendTxCallback(hash));
        };
        this.lockToken = async (erc20Address, userAddr, amount, decimals, sendTxCallback) => {
            let accounts;
            if (this.useMetamask) {
                accounts = await ethereum.enable();
            }
            const hmyAddrHex = crypto_1.getAddress(userAddr).checksum;
            const transaction = await this.ethManagerContract.methods
                .lockToken(erc20Address, utils_1.withDecimals(amount, decimals), hmyAddrHex)
                .send({
                from: this.useMetamask ? accounts[0] : this.web3.eth.defaultAccount,
                gas: this.gasLimit,
                gasPrice: new BN(await this.web3.eth.getGasPrice()).mul(new BN(1)),
            })
                .on('transactionHash', (hash) => sendTxCallback(hash));
            return transaction.events.Locked;
        };
        this.checkEthBalance = async (erc20Address, addr) => {
            const erc20Contract = new this.web3.eth.Contract(MyERC20_1.default, erc20Address);
            return await erc20Contract.methods.balanceOf(addr).call();
        };
        this.tokenDetails = async (erc20Address) => {
            if (!this.web3.utils.isAddress(erc20Address)) {
                throw new Error('Invalid token address');
            }
            const erc20Contract = new this.web3.eth.Contract(MyERC20_1.default, erc20Address);
            const name = await erc20Contract.methods.name().call();
            const symbol = await erc20Contract.methods.symbol().call();
            const decimals = await erc20Contract.methods.decimals().call();
            return { name, symbol, decimals, erc20Address };
        };
        this.setApprovalForAllEthManger = async (erc20Address, sendTxCallback) => {
            let accounts;
            if (this.useMetamask) {
                accounts = await ethereum.enable();
            }
            const erc20Contract = new this.web3.eth.Contract(MyERC20_1.default, erc20Address);
            const res = await erc20Contract.methods
                .isApprovedForAll(this.useMetamask ? accounts[0] : this.web3.eth.defaultAccount, this.ethManagerAddress)
                .call();
            if (!res) {
                return await erc20Contract.methods
                    .setApprovalForAll(this.ethManagerAddress, true)
                    .send({
                    from: this.useMetamask ? accounts[0] : this.web3.eth.defaultAccount,
                    gas: this.gasLimit,
                    gasPrice: new BN(await this.web3.eth.getGasPrice()).mul(new BN(1)),
                })
                    .on('transactionHash', (hash) => sendTxCallback(hash));
            }
            else {
                sendTxCallback('skip');
            }
        };
        this.lockTokens = async (erc20Address, userAddr, amount, sendTxCallback) => {
            let accounts;
            if (this.useMetamask) {
                accounts = await ethereum.enable();
            }
            const hmyAddrHex = crypto_1.getAddress(userAddr).checksum;
            const estimateGas = await this.ethManagerContract.methods
                .lockTokens(erc20Address, amount, hmyAddrHex)
                .estimateGas({ from: this.useMetamask ? accounts[0] : this.web3.eth.defaultAccount });
            const gasLimit = Math.max(estimateGas + estimateGas * 0.3, Number(this.gasLimit));
            const transaction = await this.ethManagerContract.methods
                .lockTokens(erc20Address, amount, hmyAddrHex)
                .send({
                from: this.useMetamask ? accounts[0] : this.web3.eth.defaultAccount,
                gas: gasLimit.toFixed(0),
                gasPrice: new BN(await this.web3.eth.getGasPrice()).mul(new BN(1)),
            })
                .on('transactionHash', (hash) => sendTxCallback(hash));
            return transaction;
        };
        this.tokenDetailsERC721 = async (erc20Address) => {
            if (!this.web3.utils.isAddress(erc20Address)) {
                throw new Error('Invalid token address');
            }
            const erc20Contract = new this.web3.eth.Contract(MyERC20_1.default, erc20Address);
            const name = await erc20Contract.methods.name().call();
            const symbol = await erc20Contract.methods.symbol().call();
            return { name, symbol, erc20Address };
        };
        this.web3 = params.web3;
        this.ethManagerContract = params.ethManagerContract;
        this.ethManagerAddress = params.ethManagerAddress;
        this.gasPrice = params.gasPrice;
        this.gasLimit = params.gasLimit;
        this.gasApiKey = params.gasApiKey;
    }
}
exports.EthMethodsERC20 = EthMethodsERC20;
